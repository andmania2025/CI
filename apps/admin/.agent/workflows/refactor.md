---
description: リファクタリングの目標、プロセス、パターン、チェックリスト
---

# リファクタリングプロンプト

## リファクタリングの目標

### 1. コードの整理

- 「3のルール (Rule of Three)」に従って再利用可能なコンポーネントを抽出する
- プレゼンテーションとビジネスロジックの間の関心を分離する
- 共有ロジックをカスタムフックに移動する
- 適切な場合、機能ごとにコードを整理する

### 2. パフォーマンスの最適化

- 不要な再レンダリングを特定して修正する
- 以下のガイドラインに従って useMemo/useCallback で重い計算を最適化する：
  - **useCallback**: メモ化された子コンポーネントに渡される関数やフックの依存関係で使用される関数用
  - **useMemo**: 高価な計算、フィルタリング/ソートされたデータ、またはオブジェクト/配列の作成用
  - **過剰な最適化を避ける**: まずプロファイリングし、次に最適化する - すべてをメモ化しない
- 適切な遅延読み込みを実装する
- データベースクエリを最適化し、N+1 問題を削減する

### 3. 保守性

- コードの重複を減らす
- 命名とドキュメントを改善する
- 複雑なロジックを簡素化する
- デッドコードと未使用のインポートを削除する

### 4. 型安全性

- TypeScript の型を強化する
- any 型を削除し、型推論を改善する
- 適切なエラー境界を追加する
- Zod スキーマでデータを検証する

## リファクタリングプロセス

### リファクタリング前

1. **現在のコードを理解する**: コードが何をするか、なぜそうするかを分析する
2. **問題点を特定する**: コードスメルや困難な領域を探す
3. **変更を計画する**: リファクタリングの手順を概説する
4. **テストカバレッジを確保する**: テストが存在しない場合は作成する

### リファクタリング中

1. **小さく段階的な変更を行う**: 小さなステップでリファクタリングする
2. **機能をそのまま維持する**: 意図しない限り動作を変更しない
3. **頻繁にテストする**: 各変更後にテストを実行する
4. **頻繁にコミットする**: 論理的な変更ごとにアトミックなコミットを行う

### リファクタリング後

1. **すべてのテストが合格することを確認する**: 何も壊れていないことを確認する
2. **ドキュメントを更新する**: アーキテクチャの変更を反映する
3. **パフォーマンスを確認する**: 改善が達成されたことを確認する
4. **チームレビューを受ける**: 他の人に変更をレビューしてもらう

## 一般的なリファクタリングパターン

### コンポーネントの抽出

```typescript
// Before: 複数のことを行う大きなコンポーネント
const UserDashboard = () => {
  // 100行以上の混合した関心事
};

// After: 抽出された小さなコンポーネント
const UserDashboard = () => {
  return (
    <div>
      <UserProfile />
      <UserStats />
      <UserActions />
    </div>
  );
};
```

### カスタムフックの抽出

```typescript
// Before: コンポーネントに散在するロジック
const [data, setData] = useState();
const [loading, setLoading] = useState(false);
// ... フェッチロジック

// After: カスタムフックに抽出
const { data, loading, error } = useUserData(userId);
```

### Server Action の最適化

```typescript
// Before: 複数のデータベース呼び出し
const getUserWithPosts = async (userId: string) => {
  const user = await prisma.user.findUnique({ where: { id: userId } });
  const posts = await prisma.post.findMany({ where: { userId } });
  return { user, posts };
};

// After: 単一の最適化されたクエリ
const getUserWithPosts = async (userId: string) => {
  return prisma.user.findUnique({
    where: { id: userId },
    include: { posts: true },
  });
};
```

## リファクタリングチェックリスト

- [ ] 重複コードを再利用可能な関数/コンポーネントに抽出する
- [ ] ビジネスロジックをカスタムフックまたは Server Actions に移動する
- [ ] データベースクエリを最適化し、ラウンドトリップを削減する
- [ ] コンポーネントの prop インターフェースを改善する
- [ ] 適切なエラーハンドリングとローディング状態を追加する
- [ ] 適切な TypeScript 型を実装する
- [ ] 未使用のコードと依存関係を削除する
- [ ] 変更を反映するようにテストを更新する
- [ ] アクセシビリティが維持されていることを確認する
- [ ] パフォーマンスの改善を確認する
