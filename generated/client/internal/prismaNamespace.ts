
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models.ts"
import { type PrismaClient } from "./class.ts"

export type * from '../models.ts'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.2.0
 * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
 */
export const prismaVersion: PrismaVersion = {
  client: "7.2.0",
  engine: "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  User: 'User',
  Role: 'Role',
  UserRole: 'UserRole',
  Company: 'Company',
  Branch: 'Branch',
  Agent: 'Agent',
  Property: 'Property',
  PropertyPublication: 'PropertyPublication',
  PropertyPriceHistory: 'PropertyPriceHistory',
  PropertyStatusHistory: 'PropertyStatusHistory',
  PropertyImage: 'PropertyImage',
  PropertyFeature: 'PropertyFeature',
  PropertyStation: 'PropertyStation',
  Favorite: 'Favorite',
  PropertyView: 'PropertyView',
  PropertyViewDaily: 'PropertyViewDaily',
  Inquiry: 'Inquiry',
  InquiryMessage: 'InquiryMessage',
  BulkAssessment: 'BulkAssessment',
  BulkAssessmentResponse: 'BulkAssessmentResponse',
  Question: 'Question',
  Answer: 'Answer',
  FeatureMaster: 'FeatureMaster',
  RegionMaster: 'RegionMaster',
  AreaMaster: 'AreaMaster',
  PropertyTypeMaster: 'PropertyTypeMaster',
  PropertyCategoryMaster: 'PropertyCategoryMaster',
  FloorPlanMaster: 'FloorPlanMaster',
  RouteMaster: 'RouteMaster',
  Station: 'Station',
  QuestionCategory: 'QuestionCategory',
  Mail: 'Mail',
  FileBox: 'FileBox',
  SystemSetting: 'SystemSetting',
  AuditLog: 'AuditLog',
  Notification: 'Notification'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "user" | "role" | "userRole" | "company" | "branch" | "agent" | "property" | "propertyPublication" | "propertyPriceHistory" | "propertyStatusHistory" | "propertyImage" | "propertyFeature" | "propertyStation" | "favorite" | "propertyView" | "propertyViewDaily" | "inquiry" | "inquiryMessage" | "bulkAssessment" | "bulkAssessmentResponse" | "question" | "answer" | "featureMaster" | "regionMaster" | "areaMaster" | "propertyTypeMaster" | "propertyCategoryMaster" | "floorPlanMaster" | "routeMaster" | "station" | "questionCategory" | "mail" | "fileBox" | "systemSetting" | "auditLog" | "notification"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    Role: {
      payload: Prisma.$RolePayload<ExtArgs>
      fields: Prisma.RoleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RoleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        findFirst: {
          args: Prisma.RoleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        findMany: {
          args: Prisma.RoleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        create: {
          args: Prisma.RoleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        createMany: {
          args: Prisma.RoleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        delete: {
          args: Prisma.RoleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        update: {
          args: Prisma.RoleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        deleteMany: {
          args: Prisma.RoleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RoleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        upsert: {
          args: Prisma.RoleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        aggregate: {
          args: Prisma.RoleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRole>
        }
        groupBy: {
          args: Prisma.RoleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleGroupByOutputType>[]
        }
        count: {
          args: Prisma.RoleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleCountAggregateOutputType> | number
        }
      }
    }
    UserRole: {
      payload: Prisma.$UserRolePayload<ExtArgs>
      fields: Prisma.UserRoleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        findFirst: {
          args: Prisma.UserRoleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        findMany: {
          args: Prisma.UserRoleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>[]
        }
        create: {
          args: Prisma.UserRoleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        createMany: {
          args: Prisma.UserRoleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>[]
        }
        delete: {
          args: Prisma.UserRoleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        update: {
          args: Prisma.UserRoleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        deleteMany: {
          args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>[]
        }
        upsert: {
          args: Prisma.UserRoleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        aggregate: {
          args: Prisma.UserRoleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserRole>
        }
        groupBy: {
          args: Prisma.UserRoleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserRoleGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserRoleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserRoleCountAggregateOutputType> | number
        }
      }
    }
    Company: {
      payload: Prisma.$CompanyPayload<ExtArgs>
      fields: Prisma.CompanyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompanyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        findFirst: {
          args: Prisma.CompanyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        findMany: {
          args: Prisma.CompanyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[]
        }
        create: {
          args: Prisma.CompanyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        createMany: {
          args: Prisma.CompanyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[]
        }
        delete: {
          args: Prisma.CompanyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        update: {
          args: Prisma.CompanyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        deleteMany: {
          args: Prisma.CompanyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompanyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[]
        }
        upsert: {
          args: Prisma.CompanyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        aggregate: {
          args: Prisma.CompanyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompany>
        }
        groupBy: {
          args: Prisma.CompanyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompanyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyCountAggregateOutputType> | number
        }
      }
    }
    Branch: {
      payload: Prisma.$BranchPayload<ExtArgs>
      fields: Prisma.BranchFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BranchFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload>
        }
        findFirst: {
          args: Prisma.BranchFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload>
        }
        findMany: {
          args: Prisma.BranchFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload>[]
        }
        create: {
          args: Prisma.BranchCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload>
        }
        createMany: {
          args: Prisma.BranchCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload>[]
        }
        delete: {
          args: Prisma.BranchDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload>
        }
        update: {
          args: Prisma.BranchUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload>
        }
        deleteMany: {
          args: Prisma.BranchDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BranchUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BranchUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload>[]
        }
        upsert: {
          args: Prisma.BranchUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BranchPayload>
        }
        aggregate: {
          args: Prisma.BranchAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBranch>
        }
        groupBy: {
          args: Prisma.BranchGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BranchGroupByOutputType>[]
        }
        count: {
          args: Prisma.BranchCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BranchCountAggregateOutputType> | number
        }
      }
    }
    Agent: {
      payload: Prisma.$AgentPayload<ExtArgs>
      fields: Prisma.AgentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AgentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload>
        }
        findFirst: {
          args: Prisma.AgentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload>
        }
        findMany: {
          args: Prisma.AgentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload>[]
        }
        create: {
          args: Prisma.AgentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload>
        }
        createMany: {
          args: Prisma.AgentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AgentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload>[]
        }
        delete: {
          args: Prisma.AgentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload>
        }
        update: {
          args: Prisma.AgentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload>
        }
        deleteMany: {
          args: Prisma.AgentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AgentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AgentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload>[]
        }
        upsert: {
          args: Prisma.AgentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload>
        }
        aggregate: {
          args: Prisma.AgentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAgent>
        }
        groupBy: {
          args: Prisma.AgentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AgentGroupByOutputType>[]
        }
        count: {
          args: Prisma.AgentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AgentCountAggregateOutputType> | number
        }
      }
    }
    Property: {
      payload: Prisma.$PropertyPayload<ExtArgs>
      fields: Prisma.PropertyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        findFirst: {
          args: Prisma.PropertyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        findMany: {
          args: Prisma.PropertyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>[]
        }
        create: {
          args: Prisma.PropertyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        createMany: {
          args: Prisma.PropertyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>[]
        }
        delete: {
          args: Prisma.PropertyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        update: {
          args: Prisma.PropertyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        deleteMany: {
          args: Prisma.PropertyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PropertyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>[]
        }
        upsert: {
          args: Prisma.PropertyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        aggregate: {
          args: Prisma.PropertyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProperty>
        }
        groupBy: {
          args: Prisma.PropertyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyCountAggregateOutputType> | number
        }
      }
    }
    PropertyPublication: {
      payload: Prisma.$PropertyPublicationPayload<ExtArgs>
      fields: Prisma.PropertyPublicationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyPublicationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPublicationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyPublicationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPublicationPayload>
        }
        findFirst: {
          args: Prisma.PropertyPublicationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPublicationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyPublicationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPublicationPayload>
        }
        findMany: {
          args: Prisma.PropertyPublicationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPublicationPayload>[]
        }
        create: {
          args: Prisma.PropertyPublicationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPublicationPayload>
        }
        createMany: {
          args: Prisma.PropertyPublicationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PropertyPublicationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPublicationPayload>[]
        }
        delete: {
          args: Prisma.PropertyPublicationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPublicationPayload>
        }
        update: {
          args: Prisma.PropertyPublicationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPublicationPayload>
        }
        deleteMany: {
          args: Prisma.PropertyPublicationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyPublicationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PropertyPublicationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPublicationPayload>[]
        }
        upsert: {
          args: Prisma.PropertyPublicationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPublicationPayload>
        }
        aggregate: {
          args: Prisma.PropertyPublicationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyPublication>
        }
        groupBy: {
          args: Prisma.PropertyPublicationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyPublicationGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyPublicationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyPublicationCountAggregateOutputType> | number
        }
      }
    }
    PropertyPriceHistory: {
      payload: Prisma.$PropertyPriceHistoryPayload<ExtArgs>
      fields: Prisma.PropertyPriceHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyPriceHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyPriceHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload>
        }
        findFirst: {
          args: Prisma.PropertyPriceHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyPriceHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload>
        }
        findMany: {
          args: Prisma.PropertyPriceHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload>[]
        }
        create: {
          args: Prisma.PropertyPriceHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload>
        }
        createMany: {
          args: Prisma.PropertyPriceHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PropertyPriceHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload>[]
        }
        delete: {
          args: Prisma.PropertyPriceHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload>
        }
        update: {
          args: Prisma.PropertyPriceHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload>
        }
        deleteMany: {
          args: Prisma.PropertyPriceHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyPriceHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PropertyPriceHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload>[]
        }
        upsert: {
          args: Prisma.PropertyPriceHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload>
        }
        aggregate: {
          args: Prisma.PropertyPriceHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyPriceHistory>
        }
        groupBy: {
          args: Prisma.PropertyPriceHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyPriceHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyPriceHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyPriceHistoryCountAggregateOutputType> | number
        }
      }
    }
    PropertyStatusHistory: {
      payload: Prisma.$PropertyStatusHistoryPayload<ExtArgs>
      fields: Prisma.PropertyStatusHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyStatusHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyStatusHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload>
        }
        findFirst: {
          args: Prisma.PropertyStatusHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyStatusHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload>
        }
        findMany: {
          args: Prisma.PropertyStatusHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload>[]
        }
        create: {
          args: Prisma.PropertyStatusHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload>
        }
        createMany: {
          args: Prisma.PropertyStatusHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PropertyStatusHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload>[]
        }
        delete: {
          args: Prisma.PropertyStatusHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload>
        }
        update: {
          args: Prisma.PropertyStatusHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload>
        }
        deleteMany: {
          args: Prisma.PropertyStatusHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyStatusHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PropertyStatusHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload>[]
        }
        upsert: {
          args: Prisma.PropertyStatusHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload>
        }
        aggregate: {
          args: Prisma.PropertyStatusHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyStatusHistory>
        }
        groupBy: {
          args: Prisma.PropertyStatusHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyStatusHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyStatusHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyStatusHistoryCountAggregateOutputType> | number
        }
      }
    }
    PropertyImage: {
      payload: Prisma.$PropertyImagePayload<ExtArgs>
      fields: Prisma.PropertyImageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyImageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyImagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyImageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyImagePayload>
        }
        findFirst: {
          args: Prisma.PropertyImageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyImagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyImageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyImagePayload>
        }
        findMany: {
          args: Prisma.PropertyImageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyImagePayload>[]
        }
        create: {
          args: Prisma.PropertyImageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyImagePayload>
        }
        createMany: {
          args: Prisma.PropertyImageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PropertyImageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyImagePayload>[]
        }
        delete: {
          args: Prisma.PropertyImageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyImagePayload>
        }
        update: {
          args: Prisma.PropertyImageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyImagePayload>
        }
        deleteMany: {
          args: Prisma.PropertyImageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyImageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PropertyImageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyImagePayload>[]
        }
        upsert: {
          args: Prisma.PropertyImageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyImagePayload>
        }
        aggregate: {
          args: Prisma.PropertyImageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyImage>
        }
        groupBy: {
          args: Prisma.PropertyImageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyImageGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyImageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyImageCountAggregateOutputType> | number
        }
      }
    }
    PropertyFeature: {
      payload: Prisma.$PropertyFeaturePayload<ExtArgs>
      fields: Prisma.PropertyFeatureFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyFeatureFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyFeaturePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyFeatureFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>
        }
        findFirst: {
          args: Prisma.PropertyFeatureFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyFeaturePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyFeatureFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>
        }
        findMany: {
          args: Prisma.PropertyFeatureFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>[]
        }
        create: {
          args: Prisma.PropertyFeatureCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>
        }
        createMany: {
          args: Prisma.PropertyFeatureCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PropertyFeatureCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>[]
        }
        delete: {
          args: Prisma.PropertyFeatureDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>
        }
        update: {
          args: Prisma.PropertyFeatureUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>
        }
        deleteMany: {
          args: Prisma.PropertyFeatureDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyFeatureUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PropertyFeatureUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>[]
        }
        upsert: {
          args: Prisma.PropertyFeatureUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>
        }
        aggregate: {
          args: Prisma.PropertyFeatureAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyFeature>
        }
        groupBy: {
          args: Prisma.PropertyFeatureGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyFeatureGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyFeatureCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyFeatureCountAggregateOutputType> | number
        }
      }
    }
    PropertyStation: {
      payload: Prisma.$PropertyStationPayload<ExtArgs>
      fields: Prisma.PropertyStationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyStationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyStationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStationPayload>
        }
        findFirst: {
          args: Prisma.PropertyStationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyStationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStationPayload>
        }
        findMany: {
          args: Prisma.PropertyStationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStationPayload>[]
        }
        create: {
          args: Prisma.PropertyStationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStationPayload>
        }
        createMany: {
          args: Prisma.PropertyStationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PropertyStationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStationPayload>[]
        }
        delete: {
          args: Prisma.PropertyStationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStationPayload>
        }
        update: {
          args: Prisma.PropertyStationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStationPayload>
        }
        deleteMany: {
          args: Prisma.PropertyStationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyStationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PropertyStationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStationPayload>[]
        }
        upsert: {
          args: Prisma.PropertyStationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyStationPayload>
        }
        aggregate: {
          args: Prisma.PropertyStationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyStation>
        }
        groupBy: {
          args: Prisma.PropertyStationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyStationGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyStationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyStationCountAggregateOutputType> | number
        }
      }
    }
    Favorite: {
      payload: Prisma.$FavoritePayload<ExtArgs>
      fields: Prisma.FavoriteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FavoriteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FavoriteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload>
        }
        findFirst: {
          args: Prisma.FavoriteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FavoriteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload>
        }
        findMany: {
          args: Prisma.FavoriteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload>[]
        }
        create: {
          args: Prisma.FavoriteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload>
        }
        createMany: {
          args: Prisma.FavoriteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FavoriteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload>[]
        }
        delete: {
          args: Prisma.FavoriteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload>
        }
        update: {
          args: Prisma.FavoriteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload>
        }
        deleteMany: {
          args: Prisma.FavoriteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FavoriteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FavoriteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload>[]
        }
        upsert: {
          args: Prisma.FavoriteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FavoritePayload>
        }
        aggregate: {
          args: Prisma.FavoriteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFavorite>
        }
        groupBy: {
          args: Prisma.FavoriteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FavoriteGroupByOutputType>[]
        }
        count: {
          args: Prisma.FavoriteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FavoriteCountAggregateOutputType> | number
        }
      }
    }
    PropertyView: {
      payload: Prisma.$PropertyViewPayload<ExtArgs>
      fields: Prisma.PropertyViewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyViewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyViewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewPayload>
        }
        findFirst: {
          args: Prisma.PropertyViewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyViewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewPayload>
        }
        findMany: {
          args: Prisma.PropertyViewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewPayload>[]
        }
        create: {
          args: Prisma.PropertyViewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewPayload>
        }
        createMany: {
          args: Prisma.PropertyViewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PropertyViewCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewPayload>[]
        }
        delete: {
          args: Prisma.PropertyViewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewPayload>
        }
        update: {
          args: Prisma.PropertyViewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewPayload>
        }
        deleteMany: {
          args: Prisma.PropertyViewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyViewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PropertyViewUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewPayload>[]
        }
        upsert: {
          args: Prisma.PropertyViewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewPayload>
        }
        aggregate: {
          args: Prisma.PropertyViewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyView>
        }
        groupBy: {
          args: Prisma.PropertyViewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyViewGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyViewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyViewCountAggregateOutputType> | number
        }
      }
    }
    PropertyViewDaily: {
      payload: Prisma.$PropertyViewDailyPayload<ExtArgs>
      fields: Prisma.PropertyViewDailyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyViewDailyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyViewDailyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload>
        }
        findFirst: {
          args: Prisma.PropertyViewDailyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyViewDailyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload>
        }
        findMany: {
          args: Prisma.PropertyViewDailyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload>[]
        }
        create: {
          args: Prisma.PropertyViewDailyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload>
        }
        createMany: {
          args: Prisma.PropertyViewDailyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PropertyViewDailyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload>[]
        }
        delete: {
          args: Prisma.PropertyViewDailyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload>
        }
        update: {
          args: Prisma.PropertyViewDailyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload>
        }
        deleteMany: {
          args: Prisma.PropertyViewDailyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyViewDailyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PropertyViewDailyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload>[]
        }
        upsert: {
          args: Prisma.PropertyViewDailyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload>
        }
        aggregate: {
          args: Prisma.PropertyViewDailyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyViewDaily>
        }
        groupBy: {
          args: Prisma.PropertyViewDailyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyViewDailyGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyViewDailyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyViewDailyCountAggregateOutputType> | number
        }
      }
    }
    Inquiry: {
      payload: Prisma.$InquiryPayload<ExtArgs>
      fields: Prisma.InquiryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InquiryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InquiryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryPayload>
        }
        findFirst: {
          args: Prisma.InquiryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InquiryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryPayload>
        }
        findMany: {
          args: Prisma.InquiryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryPayload>[]
        }
        create: {
          args: Prisma.InquiryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryPayload>
        }
        createMany: {
          args: Prisma.InquiryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InquiryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryPayload>[]
        }
        delete: {
          args: Prisma.InquiryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryPayload>
        }
        update: {
          args: Prisma.InquiryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryPayload>
        }
        deleteMany: {
          args: Prisma.InquiryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InquiryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InquiryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryPayload>[]
        }
        upsert: {
          args: Prisma.InquiryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryPayload>
        }
        aggregate: {
          args: Prisma.InquiryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInquiry>
        }
        groupBy: {
          args: Prisma.InquiryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InquiryGroupByOutputType>[]
        }
        count: {
          args: Prisma.InquiryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InquiryCountAggregateOutputType> | number
        }
      }
    }
    InquiryMessage: {
      payload: Prisma.$InquiryMessagePayload<ExtArgs>
      fields: Prisma.InquiryMessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InquiryMessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryMessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InquiryMessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryMessagePayload>
        }
        findFirst: {
          args: Prisma.InquiryMessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryMessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InquiryMessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryMessagePayload>
        }
        findMany: {
          args: Prisma.InquiryMessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryMessagePayload>[]
        }
        create: {
          args: Prisma.InquiryMessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryMessagePayload>
        }
        createMany: {
          args: Prisma.InquiryMessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InquiryMessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryMessagePayload>[]
        }
        delete: {
          args: Prisma.InquiryMessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryMessagePayload>
        }
        update: {
          args: Prisma.InquiryMessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryMessagePayload>
        }
        deleteMany: {
          args: Prisma.InquiryMessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InquiryMessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InquiryMessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryMessagePayload>[]
        }
        upsert: {
          args: Prisma.InquiryMessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InquiryMessagePayload>
        }
        aggregate: {
          args: Prisma.InquiryMessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInquiryMessage>
        }
        groupBy: {
          args: Prisma.InquiryMessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InquiryMessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.InquiryMessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InquiryMessageCountAggregateOutputType> | number
        }
      }
    }
    BulkAssessment: {
      payload: Prisma.$BulkAssessmentPayload<ExtArgs>
      fields: Prisma.BulkAssessmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BulkAssessmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BulkAssessmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentPayload>
        }
        findFirst: {
          args: Prisma.BulkAssessmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BulkAssessmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentPayload>
        }
        findMany: {
          args: Prisma.BulkAssessmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentPayload>[]
        }
        create: {
          args: Prisma.BulkAssessmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentPayload>
        }
        createMany: {
          args: Prisma.BulkAssessmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BulkAssessmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentPayload>[]
        }
        delete: {
          args: Prisma.BulkAssessmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentPayload>
        }
        update: {
          args: Prisma.BulkAssessmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentPayload>
        }
        deleteMany: {
          args: Prisma.BulkAssessmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BulkAssessmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BulkAssessmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentPayload>[]
        }
        upsert: {
          args: Prisma.BulkAssessmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentPayload>
        }
        aggregate: {
          args: Prisma.BulkAssessmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBulkAssessment>
        }
        groupBy: {
          args: Prisma.BulkAssessmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BulkAssessmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.BulkAssessmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BulkAssessmentCountAggregateOutputType> | number
        }
      }
    }
    BulkAssessmentResponse: {
      payload: Prisma.$BulkAssessmentResponsePayload<ExtArgs>
      fields: Prisma.BulkAssessmentResponseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BulkAssessmentResponseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BulkAssessmentResponseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload>
        }
        findFirst: {
          args: Prisma.BulkAssessmentResponseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BulkAssessmentResponseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload>
        }
        findMany: {
          args: Prisma.BulkAssessmentResponseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload>[]
        }
        create: {
          args: Prisma.BulkAssessmentResponseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload>
        }
        createMany: {
          args: Prisma.BulkAssessmentResponseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BulkAssessmentResponseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload>[]
        }
        delete: {
          args: Prisma.BulkAssessmentResponseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload>
        }
        update: {
          args: Prisma.BulkAssessmentResponseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload>
        }
        deleteMany: {
          args: Prisma.BulkAssessmentResponseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BulkAssessmentResponseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BulkAssessmentResponseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload>[]
        }
        upsert: {
          args: Prisma.BulkAssessmentResponseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload>
        }
        aggregate: {
          args: Prisma.BulkAssessmentResponseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBulkAssessmentResponse>
        }
        groupBy: {
          args: Prisma.BulkAssessmentResponseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BulkAssessmentResponseGroupByOutputType>[]
        }
        count: {
          args: Prisma.BulkAssessmentResponseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BulkAssessmentResponseCountAggregateOutputType> | number
        }
      }
    }
    Question: {
      payload: Prisma.$QuestionPayload<ExtArgs>
      fields: Prisma.QuestionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QuestionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QuestionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionPayload>
        }
        findFirst: {
          args: Prisma.QuestionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QuestionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionPayload>
        }
        findMany: {
          args: Prisma.QuestionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionPayload>[]
        }
        create: {
          args: Prisma.QuestionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionPayload>
        }
        createMany: {
          args: Prisma.QuestionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.QuestionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionPayload>[]
        }
        delete: {
          args: Prisma.QuestionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionPayload>
        }
        update: {
          args: Prisma.QuestionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionPayload>
        }
        deleteMany: {
          args: Prisma.QuestionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QuestionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.QuestionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionPayload>[]
        }
        upsert: {
          args: Prisma.QuestionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionPayload>
        }
        aggregate: {
          args: Prisma.QuestionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQuestion>
        }
        groupBy: {
          args: Prisma.QuestionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuestionGroupByOutputType>[]
        }
        count: {
          args: Prisma.QuestionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuestionCountAggregateOutputType> | number
        }
      }
    }
    Answer: {
      payload: Prisma.$AnswerPayload<ExtArgs>
      fields: Prisma.AnswerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AnswerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnswerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AnswerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnswerPayload>
        }
        findFirst: {
          args: Prisma.AnswerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnswerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AnswerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnswerPayload>
        }
        findMany: {
          args: Prisma.AnswerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnswerPayload>[]
        }
        create: {
          args: Prisma.AnswerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnswerPayload>
        }
        createMany: {
          args: Prisma.AnswerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AnswerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnswerPayload>[]
        }
        delete: {
          args: Prisma.AnswerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnswerPayload>
        }
        update: {
          args: Prisma.AnswerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnswerPayload>
        }
        deleteMany: {
          args: Prisma.AnswerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AnswerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AnswerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnswerPayload>[]
        }
        upsert: {
          args: Prisma.AnswerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnswerPayload>
        }
        aggregate: {
          args: Prisma.AnswerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAnswer>
        }
        groupBy: {
          args: Prisma.AnswerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AnswerGroupByOutputType>[]
        }
        count: {
          args: Prisma.AnswerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AnswerCountAggregateOutputType> | number
        }
      }
    }
    FeatureMaster: {
      payload: Prisma.$FeatureMasterPayload<ExtArgs>
      fields: Prisma.FeatureMasterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FeatureMasterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeatureMasterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FeatureMasterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeatureMasterPayload>
        }
        findFirst: {
          args: Prisma.FeatureMasterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeatureMasterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FeatureMasterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeatureMasterPayload>
        }
        findMany: {
          args: Prisma.FeatureMasterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeatureMasterPayload>[]
        }
        create: {
          args: Prisma.FeatureMasterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeatureMasterPayload>
        }
        createMany: {
          args: Prisma.FeatureMasterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FeatureMasterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeatureMasterPayload>[]
        }
        delete: {
          args: Prisma.FeatureMasterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeatureMasterPayload>
        }
        update: {
          args: Prisma.FeatureMasterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeatureMasterPayload>
        }
        deleteMany: {
          args: Prisma.FeatureMasterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FeatureMasterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FeatureMasterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeatureMasterPayload>[]
        }
        upsert: {
          args: Prisma.FeatureMasterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeatureMasterPayload>
        }
        aggregate: {
          args: Prisma.FeatureMasterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFeatureMaster>
        }
        groupBy: {
          args: Prisma.FeatureMasterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FeatureMasterGroupByOutputType>[]
        }
        count: {
          args: Prisma.FeatureMasterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FeatureMasterCountAggregateOutputType> | number
        }
      }
    }
    RegionMaster: {
      payload: Prisma.$RegionMasterPayload<ExtArgs>
      fields: Prisma.RegionMasterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RegionMasterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegionMasterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RegionMasterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegionMasterPayload>
        }
        findFirst: {
          args: Prisma.RegionMasterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegionMasterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RegionMasterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegionMasterPayload>
        }
        findMany: {
          args: Prisma.RegionMasterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegionMasterPayload>[]
        }
        create: {
          args: Prisma.RegionMasterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegionMasterPayload>
        }
        createMany: {
          args: Prisma.RegionMasterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RegionMasterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegionMasterPayload>[]
        }
        delete: {
          args: Prisma.RegionMasterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegionMasterPayload>
        }
        update: {
          args: Prisma.RegionMasterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegionMasterPayload>
        }
        deleteMany: {
          args: Prisma.RegionMasterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RegionMasterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RegionMasterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegionMasterPayload>[]
        }
        upsert: {
          args: Prisma.RegionMasterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegionMasterPayload>
        }
        aggregate: {
          args: Prisma.RegionMasterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRegionMaster>
        }
        groupBy: {
          args: Prisma.RegionMasterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RegionMasterGroupByOutputType>[]
        }
        count: {
          args: Prisma.RegionMasterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RegionMasterCountAggregateOutputType> | number
        }
      }
    }
    AreaMaster: {
      payload: Prisma.$AreaMasterPayload<ExtArgs>
      fields: Prisma.AreaMasterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AreaMasterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaMasterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AreaMasterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaMasterPayload>
        }
        findFirst: {
          args: Prisma.AreaMasterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaMasterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AreaMasterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaMasterPayload>
        }
        findMany: {
          args: Prisma.AreaMasterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaMasterPayload>[]
        }
        create: {
          args: Prisma.AreaMasterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaMasterPayload>
        }
        createMany: {
          args: Prisma.AreaMasterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AreaMasterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaMasterPayload>[]
        }
        delete: {
          args: Prisma.AreaMasterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaMasterPayload>
        }
        update: {
          args: Prisma.AreaMasterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaMasterPayload>
        }
        deleteMany: {
          args: Prisma.AreaMasterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AreaMasterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AreaMasterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaMasterPayload>[]
        }
        upsert: {
          args: Prisma.AreaMasterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaMasterPayload>
        }
        aggregate: {
          args: Prisma.AreaMasterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAreaMaster>
        }
        groupBy: {
          args: Prisma.AreaMasterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AreaMasterGroupByOutputType>[]
        }
        count: {
          args: Prisma.AreaMasterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AreaMasterCountAggregateOutputType> | number
        }
      }
    }
    PropertyTypeMaster: {
      payload: Prisma.$PropertyTypeMasterPayload<ExtArgs>
      fields: Prisma.PropertyTypeMasterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyTypeMasterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyTypeMasterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>
        }
        findFirst: {
          args: Prisma.PropertyTypeMasterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyTypeMasterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>
        }
        findMany: {
          args: Prisma.PropertyTypeMasterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>[]
        }
        create: {
          args: Prisma.PropertyTypeMasterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>
        }
        createMany: {
          args: Prisma.PropertyTypeMasterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PropertyTypeMasterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>[]
        }
        delete: {
          args: Prisma.PropertyTypeMasterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>
        }
        update: {
          args: Prisma.PropertyTypeMasterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>
        }
        deleteMany: {
          args: Prisma.PropertyTypeMasterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyTypeMasterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PropertyTypeMasterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>[]
        }
        upsert: {
          args: Prisma.PropertyTypeMasterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>
        }
        aggregate: {
          args: Prisma.PropertyTypeMasterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyTypeMaster>
        }
        groupBy: {
          args: Prisma.PropertyTypeMasterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyTypeMasterGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyTypeMasterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyTypeMasterCountAggregateOutputType> | number
        }
      }
    }
    PropertyCategoryMaster: {
      payload: Prisma.$PropertyCategoryMasterPayload<ExtArgs>
      fields: Prisma.PropertyCategoryMasterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyCategoryMasterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyCategoryMasterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload>
        }
        findFirst: {
          args: Prisma.PropertyCategoryMasterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyCategoryMasterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload>
        }
        findMany: {
          args: Prisma.PropertyCategoryMasterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload>[]
        }
        create: {
          args: Prisma.PropertyCategoryMasterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload>
        }
        createMany: {
          args: Prisma.PropertyCategoryMasterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PropertyCategoryMasterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload>[]
        }
        delete: {
          args: Prisma.PropertyCategoryMasterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload>
        }
        update: {
          args: Prisma.PropertyCategoryMasterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload>
        }
        deleteMany: {
          args: Prisma.PropertyCategoryMasterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyCategoryMasterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PropertyCategoryMasterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload>[]
        }
        upsert: {
          args: Prisma.PropertyCategoryMasterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload>
        }
        aggregate: {
          args: Prisma.PropertyCategoryMasterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyCategoryMaster>
        }
        groupBy: {
          args: Prisma.PropertyCategoryMasterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyCategoryMasterGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyCategoryMasterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyCategoryMasterCountAggregateOutputType> | number
        }
      }
    }
    FloorPlanMaster: {
      payload: Prisma.$FloorPlanMasterPayload<ExtArgs>
      fields: Prisma.FloorPlanMasterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FloorPlanMasterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FloorPlanMasterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload>
        }
        findFirst: {
          args: Prisma.FloorPlanMasterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FloorPlanMasterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload>
        }
        findMany: {
          args: Prisma.FloorPlanMasterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload>[]
        }
        create: {
          args: Prisma.FloorPlanMasterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload>
        }
        createMany: {
          args: Prisma.FloorPlanMasterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FloorPlanMasterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload>[]
        }
        delete: {
          args: Prisma.FloorPlanMasterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload>
        }
        update: {
          args: Prisma.FloorPlanMasterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload>
        }
        deleteMany: {
          args: Prisma.FloorPlanMasterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FloorPlanMasterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FloorPlanMasterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload>[]
        }
        upsert: {
          args: Prisma.FloorPlanMasterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload>
        }
        aggregate: {
          args: Prisma.FloorPlanMasterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFloorPlanMaster>
        }
        groupBy: {
          args: Prisma.FloorPlanMasterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FloorPlanMasterGroupByOutputType>[]
        }
        count: {
          args: Prisma.FloorPlanMasterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FloorPlanMasterCountAggregateOutputType> | number
        }
      }
    }
    RouteMaster: {
      payload: Prisma.$RouteMasterPayload<ExtArgs>
      fields: Prisma.RouteMasterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RouteMasterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteMasterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RouteMasterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteMasterPayload>
        }
        findFirst: {
          args: Prisma.RouteMasterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteMasterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RouteMasterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteMasterPayload>
        }
        findMany: {
          args: Prisma.RouteMasterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteMasterPayload>[]
        }
        create: {
          args: Prisma.RouteMasterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteMasterPayload>
        }
        createMany: {
          args: Prisma.RouteMasterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RouteMasterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteMasterPayload>[]
        }
        delete: {
          args: Prisma.RouteMasterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteMasterPayload>
        }
        update: {
          args: Prisma.RouteMasterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteMasterPayload>
        }
        deleteMany: {
          args: Prisma.RouteMasterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RouteMasterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RouteMasterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteMasterPayload>[]
        }
        upsert: {
          args: Prisma.RouteMasterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteMasterPayload>
        }
        aggregate: {
          args: Prisma.RouteMasterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRouteMaster>
        }
        groupBy: {
          args: Prisma.RouteMasterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RouteMasterGroupByOutputType>[]
        }
        count: {
          args: Prisma.RouteMasterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RouteMasterCountAggregateOutputType> | number
        }
      }
    }
    Station: {
      payload: Prisma.$StationPayload<ExtArgs>
      fields: Prisma.StationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StationPayload>
        }
        findFirst: {
          args: Prisma.StationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StationPayload>
        }
        findMany: {
          args: Prisma.StationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StationPayload>[]
        }
        create: {
          args: Prisma.StationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StationPayload>
        }
        createMany: {
          args: Prisma.StationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StationPayload>[]
        }
        delete: {
          args: Prisma.StationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StationPayload>
        }
        update: {
          args: Prisma.StationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StationPayload>
        }
        deleteMany: {
          args: Prisma.StationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StationPayload>[]
        }
        upsert: {
          args: Prisma.StationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StationPayload>
        }
        aggregate: {
          args: Prisma.StationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStation>
        }
        groupBy: {
          args: Prisma.StationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StationGroupByOutputType>[]
        }
        count: {
          args: Prisma.StationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StationCountAggregateOutputType> | number
        }
      }
    }
    QuestionCategory: {
      payload: Prisma.$QuestionCategoryPayload<ExtArgs>
      fields: Prisma.QuestionCategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QuestionCategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionCategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QuestionCategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionCategoryPayload>
        }
        findFirst: {
          args: Prisma.QuestionCategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionCategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QuestionCategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionCategoryPayload>
        }
        findMany: {
          args: Prisma.QuestionCategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionCategoryPayload>[]
        }
        create: {
          args: Prisma.QuestionCategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionCategoryPayload>
        }
        createMany: {
          args: Prisma.QuestionCategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.QuestionCategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionCategoryPayload>[]
        }
        delete: {
          args: Prisma.QuestionCategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionCategoryPayload>
        }
        update: {
          args: Prisma.QuestionCategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionCategoryPayload>
        }
        deleteMany: {
          args: Prisma.QuestionCategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QuestionCategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.QuestionCategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionCategoryPayload>[]
        }
        upsert: {
          args: Prisma.QuestionCategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionCategoryPayload>
        }
        aggregate: {
          args: Prisma.QuestionCategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQuestionCategory>
        }
        groupBy: {
          args: Prisma.QuestionCategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuestionCategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.QuestionCategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuestionCategoryCountAggregateOutputType> | number
        }
      }
    }
    Mail: {
      payload: Prisma.$MailPayload<ExtArgs>
      fields: Prisma.MailFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MailFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MailPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MailFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MailPayload>
        }
        findFirst: {
          args: Prisma.MailFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MailPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MailFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MailPayload>
        }
        findMany: {
          args: Prisma.MailFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MailPayload>[]
        }
        create: {
          args: Prisma.MailCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MailPayload>
        }
        createMany: {
          args: Prisma.MailCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MailCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MailPayload>[]
        }
        delete: {
          args: Prisma.MailDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MailPayload>
        }
        update: {
          args: Prisma.MailUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MailPayload>
        }
        deleteMany: {
          args: Prisma.MailDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MailUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MailUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MailPayload>[]
        }
        upsert: {
          args: Prisma.MailUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MailPayload>
        }
        aggregate: {
          args: Prisma.MailAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMail>
        }
        groupBy: {
          args: Prisma.MailGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MailGroupByOutputType>[]
        }
        count: {
          args: Prisma.MailCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MailCountAggregateOutputType> | number
        }
      }
    }
    FileBox: {
      payload: Prisma.$FileBoxPayload<ExtArgs>
      fields: Prisma.FileBoxFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FileBoxFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileBoxPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FileBoxFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileBoxPayload>
        }
        findFirst: {
          args: Prisma.FileBoxFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileBoxPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FileBoxFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileBoxPayload>
        }
        findMany: {
          args: Prisma.FileBoxFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileBoxPayload>[]
        }
        create: {
          args: Prisma.FileBoxCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileBoxPayload>
        }
        createMany: {
          args: Prisma.FileBoxCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FileBoxCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileBoxPayload>[]
        }
        delete: {
          args: Prisma.FileBoxDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileBoxPayload>
        }
        update: {
          args: Prisma.FileBoxUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileBoxPayload>
        }
        deleteMany: {
          args: Prisma.FileBoxDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FileBoxUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FileBoxUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileBoxPayload>[]
        }
        upsert: {
          args: Prisma.FileBoxUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileBoxPayload>
        }
        aggregate: {
          args: Prisma.FileBoxAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFileBox>
        }
        groupBy: {
          args: Prisma.FileBoxGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FileBoxGroupByOutputType>[]
        }
        count: {
          args: Prisma.FileBoxCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FileBoxCountAggregateOutputType> | number
        }
      }
    }
    SystemSetting: {
      payload: Prisma.$SystemSettingPayload<ExtArgs>
      fields: Prisma.SystemSettingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingPayload>
        }
        findFirst: {
          args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingPayload>
        }
        findMany: {
          args: Prisma.SystemSettingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
        }
        create: {
          args: Prisma.SystemSettingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingPayload>
        }
        createMany: {
          args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SystemSettingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
        }
        delete: {
          args: Prisma.SystemSettingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingPayload>
        }
        update: {
          args: Prisma.SystemSettingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingPayload>
        }
        deleteMany: {
          args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SystemSettingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
        }
        upsert: {
          args: Prisma.SystemSettingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingPayload>
        }
        aggregate: {
          args: Prisma.SystemSettingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSystemSetting>
        }
        groupBy: {
          args: Prisma.SystemSettingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SystemSettingGroupByOutputType>[]
        }
        count: {
          args: Prisma.SystemSettingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SystemSettingCountAggregateOutputType> | number
        }
      }
    }
    AuditLog: {
      payload: Prisma.$AuditLogPayload<ExtArgs>
      fields: Prisma.AuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findFirst: {
          args: Prisma.AuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findMany: {
          args: Prisma.AuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        create: {
          args: Prisma.AuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        createMany: {
          args: Prisma.AuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        delete: {
          args: Prisma.AuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        update: {
          args: Prisma.AuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        deleteMany: {
          args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        upsert: {
          args: Prisma.AuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        aggregate: {
          args: Prisma.AuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAuditLog>
        }
        groupBy: {
          args: Prisma.AuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.AuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogCountAggregateOutputType> | number
        }
      }
    }
    Notification: {
      payload: Prisma.$NotificationPayload<ExtArgs>
      fields: Prisma.NotificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findFirst: {
          args: Prisma.NotificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findMany: {
          args: Prisma.NotificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        create: {
          args: Prisma.NotificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        createMany: {
          args: Prisma.NotificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        delete: {
          args: Prisma.NotificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        update: {
          args: Prisma.NotificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        deleteMany: {
          args: Prisma.NotificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        upsert: {
          args: Prisma.NotificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        aggregate: {
          args: Prisma.NotificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotification>
        }
        groupBy: {
          args: Prisma.NotificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const UserScalarFieldEnum = {
  id: 'id',
  email: 'email',
  name: 'name',
  furigana: 'furigana',
  gender: 'gender',
  birthDate: 'birthDate',
  phone: 'phone',
  avatarUrl: 'avatarUrl',
  status: 'status',
  emailVerifiedAt: 'emailVerifiedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  lastLoginAt: 'lastLoginAt'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const RoleScalarFieldEnum = {
  id: 'id',
  name: 'name',
  permissions: 'permissions',
  description: 'description',
  createdAt: 'createdAt'
} as const

export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


export const UserRoleScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  roleId: 'roleId',
  createdAt: 'createdAt'
} as const

export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


export const CompanyScalarFieldEnum = {
  id: 'id',
  companyName: 'companyName',
  companyNameKana: 'companyNameKana',
  representativeName: 'representativeName',
  postalCode: 'postalCode',
  prefecture: 'prefecture',
  city: 'city',
  address: 'address',
  latitude: 'latitude',
  longitude: 'longitude',
  phone: 'phone',
  fax: 'fax',
  website: 'website',
  licenseNumber: 'licenseNumber',
  associationMembership: 'associationMembership',
  accountType: 'accountType',
  status: 'status',
  metadata: 'metadata',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


export const BranchScalarFieldEnum = {
  id: 'id',
  branchName: 'branchName',
  postalCode: 'postalCode',
  prefecture: 'prefecture',
  city: 'city',
  address: 'address',
  latitude: 'latitude',
  longitude: 'longitude',
  phone: 'phone',
  fax: 'fax',
  businessHours: 'businessHours',
  isHeadquarters: 'isHeadquarters',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


export const AgentScalarFieldEnum = {
  id: 'id',
  position: 'position',
  department: 'department',
  licenseNumber: 'licenseNumber',
  licenseExpireDate: 'licenseExpireDate',
  goodCount: 'goodCount',
  responseRate: 'responseRate',
  avgResponseMinutes: 'avgResponseMinutes',
  userId: 'userId',
  branchId: 'branchId',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


export const PropertyScalarFieldEnum = {
  id: 'id',
  propertyCode: 'propertyCode',
  propertyName: 'propertyName',
  propertyNameKana: 'propertyNameKana',
  propertyTypeId: 'propertyTypeId',
  propertyCategoryId: 'propertyCategoryId',
  areaId: 'areaId',
  transactionType: 'transactionType',
  propertyCondition: 'propertyCondition',
  postalCode: 'postalCode',
  prefecture: 'prefecture',
  city: 'city',
  town: 'town',
  block: 'block',
  building: 'building',
  roomNumber: 'roomNumber',
  fullAddress: 'fullAddress',
  latitude: 'latitude',
  longitude: 'longitude',
  layoutNumber: 'layoutNumber',
  layoutTypeId: 'layoutTypeId',
  layoutDisplay: 'layoutDisplay',
  buildingArea: 'buildingArea',
  landArea: 'landArea',
  balconyArea: 'balconyArea',
  buildingStructure: 'buildingStructure',
  constructionDate: 'constructionDate',
  constructionYearMonth: 'constructionYearMonth',
  totalFloors: 'totalFloors',
  floor: 'floor',
  currentPrice: 'currentPrice',
  pricePerTsubo: 'pricePerTsubo',
  managementFee: 'managementFee',
  commonServiceFee: 'commonServiceFee',
  depositMonths: 'depositMonths',
  keyMoneyMonths: 'keyMoneyMonths',
  mainImageUrl: 'mainImageUrl',
  primaryStationName: 'primaryStationName',
  primaryStationWalkMinutes: 'primaryStationWalkMinutes',
  featureTags: 'featureTags',
  viewCount: 'viewCount',
  inquiryCount: 'inquiryCount',
  favoriteCount: 'favoriteCount',
  agentId: 'agentId',
  remarks: 'remarks',
  internalMemo: 'internalMemo',
  metadata: 'metadata',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  userId: 'userId'
} as const

export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


export const PropertyPublicationScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  status: 'status',
  scope: 'scope',
  featured: 'featured',
  featuredOrder: 'featuredOrder',
  publishedAt: 'publishedAt',
  unpublishedAt: 'unpublishedAt',
  soldAt: 'soldAt',
  expiresAt: 'expiresAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PropertyPublicationScalarFieldEnum = (typeof PropertyPublicationScalarFieldEnum)[keyof typeof PropertyPublicationScalarFieldEnum]


export const PropertyPriceHistoryScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  previousPrice: 'previousPrice',
  newPrice: 'newPrice',
  changePercent: 'changePercent',
  changeReason: 'changeReason',
  changedById: 'changedById',
  createdAt: 'createdAt'
} as const

export type PropertyPriceHistoryScalarFieldEnum = (typeof PropertyPriceHistoryScalarFieldEnum)[keyof typeof PropertyPriceHistoryScalarFieldEnum]


export const PropertyStatusHistoryScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  previousStatus: 'previousStatus',
  newStatus: 'newStatus',
  changeReason: 'changeReason',
  changedById: 'changedById',
  createdAt: 'createdAt'
} as const

export type PropertyStatusHistoryScalarFieldEnum = (typeof PropertyStatusHistoryScalarFieldEnum)[keyof typeof PropertyStatusHistoryScalarFieldEnum]


export const PropertyImageScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  fileBoxId: 'fileBoxId',
  url: 'url',
  thumbnailUrl: 'thumbnailUrl',
  caption: 'caption',
  imageType: 'imageType',
  displayOrder: 'displayOrder',
  isMain: 'isMain',
  width: 'width',
  height: 'height',
  createdAt: 'createdAt'
} as const

export type PropertyImageScalarFieldEnum = (typeof PropertyImageScalarFieldEnum)[keyof typeof PropertyImageScalarFieldEnum]


export const PropertyFeatureScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  featureId: 'featureId'
} as const

export type PropertyFeatureScalarFieldEnum = (typeof PropertyFeatureScalarFieldEnum)[keyof typeof PropertyFeatureScalarFieldEnum]


export const PropertyStationScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  stationId: 'stationId',
  walkMinutes: 'walkMinutes',
  busMinutes: 'busMinutes',
  busStopName: 'busStopName',
  isPrimary: 'isPrimary'
} as const

export type PropertyStationScalarFieldEnum = (typeof PropertyStationScalarFieldEnum)[keyof typeof PropertyStationScalarFieldEnum]


export const FavoriteScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  propertyId: 'propertyId',
  createdAt: 'createdAt'
} as const

export type FavoriteScalarFieldEnum = (typeof FavoriteScalarFieldEnum)[keyof typeof FavoriteScalarFieldEnum]


export const PropertyViewScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  userId: 'userId',
  sessionId: 'sessionId',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  referer: 'referer',
  viewedAt: 'viewedAt',
  viewDurationSeconds: 'viewDurationSeconds'
} as const

export type PropertyViewScalarFieldEnum = (typeof PropertyViewScalarFieldEnum)[keyof typeof PropertyViewScalarFieldEnum]


export const PropertyViewDailyScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  viewDate: 'viewDate',
  totalViews: 'totalViews',
  uniqueUsers: 'uniqueUsers',
  avgDurationSeconds: 'avgDurationSeconds',
  createdAt: 'createdAt'
} as const

export type PropertyViewDailyScalarFieldEnum = (typeof PropertyViewDailyScalarFieldEnum)[keyof typeof PropertyViewDailyScalarFieldEnum]


export const InquiryScalarFieldEnum = {
  id: 'id',
  inquiryNumber: 'inquiryNumber',
  targetType: 'targetType',
  targetId: 'targetId',
  name: 'name',
  furigana: 'furigana',
  email: 'email',
  phone: 'phone',
  companyName: 'companyName',
  inquiryType: 'inquiryType',
  subject: 'subject',
  message: 'message',
  status: 'status',
  priority: 'priority',
  userId: 'userId',
  assignedAgentId: 'assignedAgentId',
  assignedAt: 'assignedAt',
  responseCount: 'responseCount',
  lastRespondedAt: 'lastRespondedAt',
  closedAt: 'closedAt',
  closedReason: 'closedReason',
  source: 'source',
  metadata: 'metadata',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InquiryScalarFieldEnum = (typeof InquiryScalarFieldEnum)[keyof typeof InquiryScalarFieldEnum]


export const InquiryMessageScalarFieldEnum = {
  id: 'id',
  inquiryId: 'inquiryId',
  senderId: 'senderId',
  senderType: 'senderType',
  message: 'message',
  attachments: 'attachments',
  isInternal: 'isInternal',
  createdAt: 'createdAt'
} as const

export type InquiryMessageScalarFieldEnum = (typeof InquiryMessageScalarFieldEnum)[keyof typeof InquiryMessageScalarFieldEnum]


export const BulkAssessmentScalarFieldEnum = {
  id: 'id',
  assessmentNumber: 'assessmentNumber',
  propertyAddress: 'propertyAddress',
  propertyTypeId: 'propertyTypeId',
  buildingArea: 'buildingArea',
  landArea: 'landArea',
  constructionYear: 'constructionYear',
  ownerName: 'ownerName',
  email: 'email',
  phone: 'phone',
  preferredContactMethod: 'preferredContactMethod',
  preferredContactTime: 'preferredContactTime',
  status: 'status',
  agentCount: 'agentCount',
  responseCount: 'responseCount',
  userId: 'userId',
  metadata: 'metadata',
  createdAt: 'createdAt',
  completedAt: 'completedAt'
} as const

export type BulkAssessmentScalarFieldEnum = (typeof BulkAssessmentScalarFieldEnum)[keyof typeof BulkAssessmentScalarFieldEnum]


export const BulkAssessmentResponseScalarFieldEnum = {
  id: 'id',
  assessmentId: 'assessmentId',
  agentId: 'agentId',
  assessedPrice: 'assessedPrice',
  priceRangeMin: 'priceRangeMin',
  priceRangeMax: 'priceRangeMax',
  comments: 'comments',
  proposalDocument: 'proposalDocument',
  status: 'status',
  submittedAt: 'submittedAt',
  viewedAt: 'viewedAt',
  createdAt: 'createdAt'
} as const

export type BulkAssessmentResponseScalarFieldEnum = (typeof BulkAssessmentResponseScalarFieldEnum)[keyof typeof BulkAssessmentResponseScalarFieldEnum]


export const QuestionScalarFieldEnum = {
  id: 'id',
  questionNumber: 'questionNumber',
  title: 'title',
  content: 'content',
  categoryId: 'categoryId',
  tags: 'tags',
  viewCount: 'viewCount',
  answerCount: 'answerCount',
  status: 'status',
  authorId: 'authorId',
  bestAnswerId: 'bestAnswerId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


export const AnswerScalarFieldEnum = {
  id: 'id',
  questionId: 'questionId',
  content: 'content',
  goodCount: 'goodCount',
  isBestAnswer: 'isBestAnswer',
  authorId: 'authorId',
  agentId: 'agentId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type AnswerScalarFieldEnum = (typeof AnswerScalarFieldEnum)[keyof typeof AnswerScalarFieldEnum]


export const FeatureMasterScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  category: 'category',
  icon: 'icon',
  displayOrder: 'displayOrder',
  isActive: 'isActive'
} as const

export type FeatureMasterScalarFieldEnum = (typeof FeatureMasterScalarFieldEnum)[keyof typeof FeatureMasterScalarFieldEnum]


export const RegionMasterScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  displayOrder: 'displayOrder',
  isActive: 'isActive'
} as const

export type RegionMasterScalarFieldEnum = (typeof RegionMasterScalarFieldEnum)[keyof typeof RegionMasterScalarFieldEnum]


export const AreaMasterScalarFieldEnum = {
  id: 'id',
  regionId: 'regionId',
  prefectureCode: 'prefectureCode',
  prefecture: 'prefecture',
  cityCode: 'cityCode',
  city: 'city',
  displayOrder: 'displayOrder',
  isActive: 'isActive'
} as const

export type AreaMasterScalarFieldEnum = (typeof AreaMasterScalarFieldEnum)[keyof typeof AreaMasterScalarFieldEnum]


export const PropertyTypeMasterScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  description: 'description',
  displayOrder: 'displayOrder',
  isActive: 'isActive'
} as const

export type PropertyTypeMasterScalarFieldEnum = (typeof PropertyTypeMasterScalarFieldEnum)[keyof typeof PropertyTypeMasterScalarFieldEnum]


export const PropertyCategoryMasterScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  displayOrder: 'displayOrder',
  isActive: 'isActive'
} as const

export type PropertyCategoryMasterScalarFieldEnum = (typeof PropertyCategoryMasterScalarFieldEnum)[keyof typeof PropertyCategoryMasterScalarFieldEnum]


export const FloorPlanMasterScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  roomCount: 'roomCount',
  displayOrder: 'displayOrder',
  isActive: 'isActive'
} as const

export type FloorPlanMasterScalarFieldEnum = (typeof FloorPlanMasterScalarFieldEnum)[keyof typeof FloorPlanMasterScalarFieldEnum]


export const RouteMasterScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  companyName: 'companyName',
  lineColor: 'lineColor',
  displayOrder: 'displayOrder',
  isActive: 'isActive'
} as const

export type RouteMasterScalarFieldEnum = (typeof RouteMasterScalarFieldEnum)[keyof typeof RouteMasterScalarFieldEnum]


export const StationScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  nameKana: 'nameKana',
  routeId: 'routeId',
  prefecture: 'prefecture',
  city: 'city',
  latitude: 'latitude',
  longitude: 'longitude',
  displayOrder: 'displayOrder',
  isActive: 'isActive'
} as const

export type StationScalarFieldEnum = (typeof StationScalarFieldEnum)[keyof typeof StationScalarFieldEnum]


export const QuestionCategoryScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  description: 'description',
  displayOrder: 'displayOrder',
  isActive: 'isActive'
} as const

export type QuestionCategoryScalarFieldEnum = (typeof QuestionCategoryScalarFieldEnum)[keyof typeof QuestionCategoryScalarFieldEnum]


export const MailScalarFieldEnum = {
  id: 'id',
  fromEmail: 'fromEmail',
  fromName: 'fromName',
  toEmail: 'toEmail',
  toName: 'toName',
  ccEmail: 'ccEmail',
  bccEmail: 'bccEmail',
  subject: 'subject',
  bodyText: 'bodyText',
  bodyHtml: 'bodyHtml',
  status: 'status',
  mailType: 'mailType',
  templateCode: 'templateCode',
  templateVariables: 'templateVariables',
  errorMessage: 'errorMessage',
  userId: 'userId',
  retryCount: 'retryCount',
  scheduledAt: 'scheduledAt',
  sentAt: 'sentAt',
  createdAt: 'createdAt'
} as const

export type MailScalarFieldEnum = (typeof MailScalarFieldEnum)[keyof typeof MailScalarFieldEnum]


export const FileBoxScalarFieldEnum = {
  id: 'id',
  bucketName: 'bucketName',
  storagePath: 'storagePath',
  fileName: 'fileName',
  originalName: 'originalName',
  publicUrl: 'publicUrl',
  mimeType: 'mimeType',
  fileSize: 'fileSize',
  category: 'category',
  metadata: 'metadata',
  userId: 'userId',
  isPublic: 'isPublic',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type FileBoxScalarFieldEnum = (typeof FileBoxScalarFieldEnum)[keyof typeof FileBoxScalarFieldEnum]


export const SystemSettingScalarFieldEnum = {
  id: 'id',
  key: 'key',
  value: 'value',
  valueType: 'valueType',
  category: 'category',
  description: 'description',
  isPublic: 'isPublic',
  updatedById: 'updatedById',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


export const AuditLogScalarFieldEnum = {
  id: 'id',
  tableName: 'tableName',
  recordId: 'recordId',
  action: 'action',
  oldData: 'oldData',
  newData: 'newData',
  changedFields: 'changedFields',
  userId: 'userId',
  userEmail: 'userEmail',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  sessionId: 'sessionId',
  createdAt: 'createdAt'
} as const

export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


export const NotificationScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  type: 'type',
  title: 'title',
  message: 'message',
  linkUrl: 'linkUrl',
  isRead: 'isRead',
  readAt: 'readAt',
  metadata: 'metadata',
  createdAt: 'createdAt'
} as const

export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'Gender'
 */
export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


/**
 * Reference to a field of type 'Gender[]'
 */
export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'UserStatus'
 */
export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


/**
 * Reference to a field of type 'UserStatus[]'
 */
export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'Decimal[]'
 */
export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


/**
 * Reference to a field of type 'AccountType'
 */
export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


/**
 * Reference to a field of type 'AccountType[]'
 */
export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


/**
 * Reference to a field of type 'CompanyStatus'
 */
export type EnumCompanyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStatus'>
    


/**
 * Reference to a field of type 'CompanyStatus[]'
 */
export type ListEnumCompanyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStatus[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'TransactionType'
 */
export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


/**
 * Reference to a field of type 'TransactionType[]'
 */
export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


/**
 * Reference to a field of type 'PropertyCondition'
 */
export type EnumPropertyConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyCondition'>
    


/**
 * Reference to a field of type 'PropertyCondition[]'
 */
export type ListEnumPropertyConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyCondition[]'>
    


/**
 * Reference to a field of type 'BigInt'
 */
export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


/**
 * Reference to a field of type 'BigInt[]'
 */
export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


/**
 * Reference to a field of type 'PublicationStatus'
 */
export type EnumPublicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublicationStatus'>
    


/**
 * Reference to a field of type 'PublicationStatus[]'
 */
export type ListEnumPublicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublicationStatus[]'>
    


/**
 * Reference to a field of type 'PublicScope'
 */
export type EnumPublicScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublicScope'>
    


/**
 * Reference to a field of type 'PublicScope[]'
 */
export type ListEnumPublicScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublicScope[]'>
    


/**
 * Reference to a field of type 'ImageType'
 */
export type EnumImageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImageType'>
    


/**
 * Reference to a field of type 'ImageType[]'
 */
export type ListEnumImageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImageType[]'>
    


/**
 * Reference to a field of type 'TargetType'
 */
export type EnumTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TargetType'>
    


/**
 * Reference to a field of type 'TargetType[]'
 */
export type ListEnumTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TargetType[]'>
    


/**
 * Reference to a field of type 'InquiryType'
 */
export type EnumInquiryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryType'>
    


/**
 * Reference to a field of type 'InquiryType[]'
 */
export type ListEnumInquiryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryType[]'>
    


/**
 * Reference to a field of type 'InquiryStatus'
 */
export type EnumInquiryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryStatus'>
    


/**
 * Reference to a field of type 'InquiryStatus[]'
 */
export type ListEnumInquiryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryStatus[]'>
    


/**
 * Reference to a field of type 'InquiryPriority'
 */
export type EnumInquiryPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryPriority'>
    


/**
 * Reference to a field of type 'InquiryPriority[]'
 */
export type ListEnumInquiryPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryPriority[]'>
    


/**
 * Reference to a field of type 'SenderType'
 */
export type EnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType'>
    


/**
 * Reference to a field of type 'SenderType[]'
 */
export type ListEnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType[]'>
    


/**
 * Reference to a field of type 'AssessmentStatus'
 */
export type EnumAssessmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssessmentStatus'>
    


/**
 * Reference to a field of type 'AssessmentStatus[]'
 */
export type ListEnumAssessmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssessmentStatus[]'>
    


/**
 * Reference to a field of type 'ResponseStatus'
 */
export type EnumResponseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResponseStatus'>
    


/**
 * Reference to a field of type 'ResponseStatus[]'
 */
export type ListEnumResponseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResponseStatus[]'>
    


/**
 * Reference to a field of type 'QuestionStatus'
 */
export type EnumQuestionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionStatus'>
    


/**
 * Reference to a field of type 'QuestionStatus[]'
 */
export type ListEnumQuestionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionStatus[]'>
    


/**
 * Reference to a field of type 'FeatureCategory'
 */
export type EnumFeatureCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeatureCategory'>
    


/**
 * Reference to a field of type 'FeatureCategory[]'
 */
export type ListEnumFeatureCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeatureCategory[]'>
    


/**
 * Reference to a field of type 'MailStatus'
 */
export type EnumMailStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MailStatus'>
    


/**
 * Reference to a field of type 'MailStatus[]'
 */
export type ListEnumMailStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MailStatus[]'>
    


/**
 * Reference to a field of type 'MailType'
 */
export type EnumMailTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MailType'>
    


/**
 * Reference to a field of type 'MailType[]'
 */
export type ListEnumMailTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MailType[]'>
    


/**
 * Reference to a field of type 'AuditAction'
 */
export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


/**
 * Reference to a field of type 'AuditAction[]'
 */
export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  user?: Prisma.UserOmit
  role?: Prisma.RoleOmit
  userRole?: Prisma.UserRoleOmit
  company?: Prisma.CompanyOmit
  branch?: Prisma.BranchOmit
  agent?: Prisma.AgentOmit
  property?: Prisma.PropertyOmit
  propertyPublication?: Prisma.PropertyPublicationOmit
  propertyPriceHistory?: Prisma.PropertyPriceHistoryOmit
  propertyStatusHistory?: Prisma.PropertyStatusHistoryOmit
  propertyImage?: Prisma.PropertyImageOmit
  propertyFeature?: Prisma.PropertyFeatureOmit
  propertyStation?: Prisma.PropertyStationOmit
  favorite?: Prisma.FavoriteOmit
  propertyView?: Prisma.PropertyViewOmit
  propertyViewDaily?: Prisma.PropertyViewDailyOmit
  inquiry?: Prisma.InquiryOmit
  inquiryMessage?: Prisma.InquiryMessageOmit
  bulkAssessment?: Prisma.BulkAssessmentOmit
  bulkAssessmentResponse?: Prisma.BulkAssessmentResponseOmit
  question?: Prisma.QuestionOmit
  answer?: Prisma.AnswerOmit
  featureMaster?: Prisma.FeatureMasterOmit
  regionMaster?: Prisma.RegionMasterOmit
  areaMaster?: Prisma.AreaMasterOmit
  propertyTypeMaster?: Prisma.PropertyTypeMasterOmit
  propertyCategoryMaster?: Prisma.PropertyCategoryMasterOmit
  floorPlanMaster?: Prisma.FloorPlanMasterOmit
  routeMaster?: Prisma.RouteMasterOmit
  station?: Prisma.StationOmit
  questionCategory?: Prisma.QuestionCategoryOmit
  mail?: Prisma.MailOmit
  fileBox?: Prisma.FileBoxOmit
  systemSetting?: Prisma.SystemSettingOmit
  auditLog?: Prisma.AuditLogOmit
  notification?: Prisma.NotificationOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

