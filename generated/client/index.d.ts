
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * ユーザー情報
 * Supabase Auth と連携し、システム全体の認証・認可の基盤となるテーブル
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * ロール（権限グループ）
 * admin（管理者）、agent（不動産業者）、general（一般ユーザー）等を管理
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UserRole
 * ユーザーとロールの中間テーブル（多対多）
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model Company
 * 不動産会社
 * 会社情報と免許情報を管理。支店（Branch）を複数持つことができる
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Branch
 * 支店
 * 会社に紐づく支店情報。本店フラグで本店と支店を区別
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model Agent
 * 不動産担当者（エージェント）
 * Userと1対1で紐づき、宅建士資格情報や評価を管理
 */
export type Agent = $Result.DefaultSelection<Prisma.$AgentPayload>
/**
 * Model Property
 * 物件情報
 * 不動産物件の詳細情報を管理するメインテーブル。検索高速化のため一部フィールドを非正規化
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>
/**
 * Model PropertyPublication
 * 物件公開情報
 * 物件の公開状態、掲載期間、注目物件設定を管理
 */
export type PropertyPublication = $Result.DefaultSelection<Prisma.$PropertyPublicationPayload>
/**
 * Model PropertyPriceHistory
 * 物件価格変更履歴
 * 価格変更のトラッキング用。変動率も自動計算して保存
 */
export type PropertyPriceHistory = $Result.DefaultSelection<Prisma.$PropertyPriceHistoryPayload>
/**
 * Model PropertyStatusHistory
 * 物件ステータス変更履歴
 * 公開状態等のステータス変更をトラッキング
 */
export type PropertyStatusHistory = $Result.DefaultSelection<Prisma.$PropertyStatusHistoryPayload>
/**
 * Model PropertyImage
 * 物件画像
 * 物件に紐づく画像情報。メイン画像フラグで一覧表示用画像を指定
 */
export type PropertyImage = $Result.DefaultSelection<Prisma.$PropertyImagePayload>
/**
 * Model PropertyFeature
 * 物件設備（中間テーブル）
 * 物件と設備マスタの多対多関係
 */
export type PropertyFeature = $Result.DefaultSelection<Prisma.$PropertyFeaturePayload>
/**
 * Model PropertyStation
 * 物件最寄り駅（中間テーブル）
 * 物件と駅の多対多関係。徒歩分数やバス利用時間も管理
 */
export type PropertyStation = $Result.DefaultSelection<Prisma.$PropertyStationPayload>
/**
 * Model Favorite
 * お気に入り物件
 * ユーザーと物件の多対多関係
 */
export type Favorite = $Result.DefaultSelection<Prisma.$FavoritePayload>
/**
 * Model PropertyView
 * 物件閲覧履歴
 * 物件詳細ページの閲覧をトラッキング。非ログインユーザーも記録可能
 */
export type PropertyView = $Result.DefaultSelection<Prisma.$PropertyViewPayload>
/**
 * Model PropertyViewDaily
 * 物件日別閲覧統計
 * 物件ごとの日別アクセス集計データ
 */
export type PropertyViewDaily = $Result.DefaultSelection<Prisma.$PropertyViewDailyPayload>
/**
 * Model Inquiry
 * 問い合わせ
 * 物件・会社・サイトへの問い合わせを管理。担当者アサインとステータス追跡
 */
export type Inquiry = $Result.DefaultSelection<Prisma.$InquiryPayload>
/**
 * Model InquiryMessage
 * 問い合わせメッセージ
 * 問い合わせに対するやり取りを記録
 */
export type InquiryMessage = $Result.DefaultSelection<Prisma.$InquiryMessagePayload>
/**
 * Model BulkAssessment
 * 一括査定依頼
 * 複数の不動産会社に一括で査定依頼を行う機能
 */
export type BulkAssessment = $Result.DefaultSelection<Prisma.$BulkAssessmentPayload>
/**
 * Model BulkAssessmentResponse
 * 一括査定回答
 * 不動産業者からの査定回答
 */
export type BulkAssessmentResponse = $Result.DefaultSelection<Prisma.$BulkAssessmentResponsePayload>
/**
 * Model Question
 * 質問
 * ユーザーからの質問を管理。カテゴリ・タグで分類
 */
export type Question = $Result.DefaultSelection<Prisma.$QuestionPayload>
/**
 * Model Answer
 * 回答
 * 質問に対する回答。ベストアンサー選択可能
 */
export type Answer = $Result.DefaultSelection<Prisma.$AnswerPayload>
/**
 * Model FeatureMaster
 * 設備マスタ
 * 物件の設備・条件を管理するマスタテーブル
 */
export type FeatureMaster = $Result.DefaultSelection<Prisma.$FeatureMasterPayload>
/**
 * Model RegionMaster
 * 地域マスタ
 * 都道府県をグループ化した地域（関東、関西等）
 */
export type RegionMaster = $Result.DefaultSelection<Prisma.$RegionMasterPayload>
/**
 * Model AreaMaster
 * エリアマスタ
 * 都道府県・市区町村のマスタ
 */
export type AreaMaster = $Result.DefaultSelection<Prisma.$AreaMasterPayload>
/**
 * Model PropertyTypeMaster
 * 物件種別マスタ
 * マンション、戸建て、土地等の物件種別
 */
export type PropertyTypeMaster = $Result.DefaultSelection<Prisma.$PropertyTypeMasterPayload>
/**
 * Model PropertyCategoryMaster
 * 物件カテゴリマスタ
 * 物件の詳細カテゴリ
 */
export type PropertyCategoryMaster = $Result.DefaultSelection<Prisma.$PropertyCategoryMasterPayload>
/**
 * Model FloorPlanMaster
 * 間取りマスタ
 * 1R、1K、2LDK等の間取りタイプ
 */
export type FloorPlanMaster = $Result.DefaultSelection<Prisma.$FloorPlanMasterPayload>
/**
 * Model RouteMaster
 * 路線マスタ
 * 電車・バスの路線情報
 */
export type RouteMaster = $Result.DefaultSelection<Prisma.$RouteMasterPayload>
/**
 * Model Station
 * 駅マスタ
 * 電車・バスの駅情報
 */
export type Station = $Result.DefaultSelection<Prisma.$StationPayload>
/**
 * Model QuestionCategory
 * 質問カテゴリマスタ
 * Q&Aの質問カテゴリ
 */
export type QuestionCategory = $Result.DefaultSelection<Prisma.$QuestionCategoryPayload>
/**
 * Model Mail
 * メール送信ログ
 * システムから送信するメールを管理
 */
export type Mail = $Result.DefaultSelection<Prisma.$MailPayload>
/**
 * Model FileBox
 * ファイルボックス
 * Supabase Storageにアップロードされたファイルのメタ情報
 */
export type FileBox = $Result.DefaultSelection<Prisma.$FileBoxPayload>
/**
 * Model SystemSetting
 * システム設定
 * アプリケーション全体の設定を管理
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>
/**
 * Model AuditLog
 * 監査ログ
 * データ変更履歴を記録（コンプライアンス対応）
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Notification
 * 通知
 * ユーザーへのアプリ内通知
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  WITHDRAWN: 'WITHDRAWN'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const AccountType: {
  FREE: 'FREE',
  BASIC: 'BASIC',
  PREMIUM: 'PREMIUM'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const CompanyStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type CompanyStatus = (typeof CompanyStatus)[keyof typeof CompanyStatus]


export const ImageType: {
  EXTERIOR: 'EXTERIOR',
  INTERIOR: 'INTERIOR',
  FLOOR_PLAN: 'FLOOR_PLAN',
  MAP: 'MAP',
  OTHER: 'OTHER'
};

export type ImageType = (typeof ImageType)[keyof typeof ImageType]


export const TransactionType: {
  SALE: 'SALE',
  RENT: 'RENT',
  BOTH: 'BOTH'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const PropertyCondition: {
  NEW: 'NEW',
  USED: 'USED',
  RENOVATED: 'RENOVATED'
};

export type PropertyCondition = (typeof PropertyCondition)[keyof typeof PropertyCondition]


export const PublicationStatus: {
  DRAFT: 'DRAFT',
  PENDING_REVIEW: 'PENDING_REVIEW',
  PUBLISHED: 'PUBLISHED',
  SOLD: 'SOLD',
  HIDDEN: 'HIDDEN'
};

export type PublicationStatus = (typeof PublicationStatus)[keyof typeof PublicationStatus]


export const PublicScope: {
  PUBLIC: 'PUBLIC',
  PRIVATE: 'PRIVATE',
  MEMBERS: 'MEMBERS',
  AGENTS: 'AGENTS'
};

export type PublicScope = (typeof PublicScope)[keyof typeof PublicScope]


export const TargetType: {
  PROPERTY: 'PROPERTY',
  SITE: 'SITE',
  COMPANY: 'COMPANY',
  AGENT: 'AGENT'
};

export type TargetType = (typeof TargetType)[keyof typeof TargetType]


export const InquiryType: {
  DOCUMENT_REQUEST: 'DOCUMENT_REQUEST',
  VIEWING: 'VIEWING',
  PRICE_NEGOTIATION: 'PRICE_NEGOTIATION',
  ENVIRONMENT: 'ENVIRONMENT',
  MOVE_IN: 'MOVE_IN',
  OTHER: 'OTHER'
};

export type InquiryType = (typeof InquiryType)[keyof typeof InquiryType]


export const InquiryStatus: {
  NEW: 'NEW',
  ASSIGNED: 'ASSIGNED',
  IN_PROGRESS: 'IN_PROGRESS',
  RESPONDED: 'RESPONDED',
  CLOSED: 'CLOSED'
};

export type InquiryStatus = (typeof InquiryStatus)[keyof typeof InquiryStatus]


export const InquiryPriority: {
  LOW: 'LOW',
  NORMAL: 'NORMAL',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type InquiryPriority = (typeof InquiryPriority)[keyof typeof InquiryPriority]


export const SenderType: {
  USER: 'USER',
  AGENT: 'AGENT',
  SYSTEM: 'SYSTEM'
};

export type SenderType = (typeof SenderType)[keyof typeof SenderType]


export const AssessmentStatus: {
  PENDING: 'PENDING',
  SENT_TO_AGENTS: 'SENT_TO_AGENTS',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type AssessmentStatus = (typeof AssessmentStatus)[keyof typeof AssessmentStatus]


export const ResponseStatus: {
  PENDING: 'PENDING',
  SUBMITTED: 'SUBMITTED',
  VIEWED: 'VIEWED'
};

export type ResponseStatus = (typeof ResponseStatus)[keyof typeof ResponseStatus]


export const QuestionStatus: {
  OPEN: 'OPEN',
  ANSWERED: 'ANSWERED',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type QuestionStatus = (typeof QuestionStatus)[keyof typeof QuestionStatus]


export const FeatureCategory: {
  EQUIPMENT: 'EQUIPMENT',
  CONDITION: 'CONDITION',
  ENVIRONMENT: 'ENVIRONMENT',
  SECURITY: 'SECURITY',
  OTHER: 'OTHER'
};

export type FeatureCategory = (typeof FeatureCategory)[keyof typeof FeatureCategory]


export const MailStatus: {
  DRAFT: 'DRAFT',
  QUEUED: 'QUEUED',
  SENDING: 'SENDING',
  SENT: 'SENT',
  FAILED: 'FAILED'
};

export type MailStatus = (typeof MailStatus)[keyof typeof MailStatus]


export const MailType: {
  GENERAL: 'GENERAL',
  INQUIRY_REPLY: 'INQUIRY_REPLY',
  NOTIFICATION: 'NOTIFICATION',
  CAMPAIGN: 'CAMPAIGN',
  SYSTEM: 'SYSTEM'
};

export type MailType = (typeof MailType)[keyof typeof MailType]


export const AuditAction: {
  INSERT: 'INSERT',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]

}

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type CompanyStatus = $Enums.CompanyStatus

export const CompanyStatus: typeof $Enums.CompanyStatus

export type ImageType = $Enums.ImageType

export const ImageType: typeof $Enums.ImageType

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type PropertyCondition = $Enums.PropertyCondition

export const PropertyCondition: typeof $Enums.PropertyCondition

export type PublicationStatus = $Enums.PublicationStatus

export const PublicationStatus: typeof $Enums.PublicationStatus

export type PublicScope = $Enums.PublicScope

export const PublicScope: typeof $Enums.PublicScope

export type TargetType = $Enums.TargetType

export const TargetType: typeof $Enums.TargetType

export type InquiryType = $Enums.InquiryType

export const InquiryType: typeof $Enums.InquiryType

export type InquiryStatus = $Enums.InquiryStatus

export const InquiryStatus: typeof $Enums.InquiryStatus

export type InquiryPriority = $Enums.InquiryPriority

export const InquiryPriority: typeof $Enums.InquiryPriority

export type SenderType = $Enums.SenderType

export const SenderType: typeof $Enums.SenderType

export type AssessmentStatus = $Enums.AssessmentStatus

export const AssessmentStatus: typeof $Enums.AssessmentStatus

export type ResponseStatus = $Enums.ResponseStatus

export const ResponseStatus: typeof $Enums.ResponseStatus

export type QuestionStatus = $Enums.QuestionStatus

export const QuestionStatus: typeof $Enums.QuestionStatus

export type FeatureCategory = $Enums.FeatureCategory

export const FeatureCategory: typeof $Enums.FeatureCategory

export type MailStatus = $Enums.MailStatus

export const MailStatus: typeof $Enums.MailStatus

export type MailType = $Enums.MailType

export const MailType: typeof $Enums.MailType

export type AuditAction = $Enums.AuditAction

export const AuditAction: typeof $Enums.AuditAction

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.AgentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyPublication`: Exposes CRUD operations for the **PropertyPublication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyPublications
    * const propertyPublications = await prisma.propertyPublication.findMany()
    * ```
    */
  get propertyPublication(): Prisma.PropertyPublicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyPriceHistory`: Exposes CRUD operations for the **PropertyPriceHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyPriceHistories
    * const propertyPriceHistories = await prisma.propertyPriceHistory.findMany()
    * ```
    */
  get propertyPriceHistory(): Prisma.PropertyPriceHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyStatusHistory`: Exposes CRUD operations for the **PropertyStatusHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyStatusHistories
    * const propertyStatusHistories = await prisma.propertyStatusHistory.findMany()
    * ```
    */
  get propertyStatusHistory(): Prisma.PropertyStatusHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyImage`: Exposes CRUD operations for the **PropertyImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyImages
    * const propertyImages = await prisma.propertyImage.findMany()
    * ```
    */
  get propertyImage(): Prisma.PropertyImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyFeature`: Exposes CRUD operations for the **PropertyFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyFeatures
    * const propertyFeatures = await prisma.propertyFeature.findMany()
    * ```
    */
  get propertyFeature(): Prisma.PropertyFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyStation`: Exposes CRUD operations for the **PropertyStation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyStations
    * const propertyStations = await prisma.propertyStation.findMany()
    * ```
    */
  get propertyStation(): Prisma.PropertyStationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favorite`: Exposes CRUD operations for the **Favorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Favorites
    * const favorites = await prisma.favorite.findMany()
    * ```
    */
  get favorite(): Prisma.FavoriteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyView`: Exposes CRUD operations for the **PropertyView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyViews
    * const propertyViews = await prisma.propertyView.findMany()
    * ```
    */
  get propertyView(): Prisma.PropertyViewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyViewDaily`: Exposes CRUD operations for the **PropertyViewDaily** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyViewDailies
    * const propertyViewDailies = await prisma.propertyViewDaily.findMany()
    * ```
    */
  get propertyViewDaily(): Prisma.PropertyViewDailyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inquiry`: Exposes CRUD operations for the **Inquiry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inquiries
    * const inquiries = await prisma.inquiry.findMany()
    * ```
    */
  get inquiry(): Prisma.InquiryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inquiryMessage`: Exposes CRUD operations for the **InquiryMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InquiryMessages
    * const inquiryMessages = await prisma.inquiryMessage.findMany()
    * ```
    */
  get inquiryMessage(): Prisma.InquiryMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bulkAssessment`: Exposes CRUD operations for the **BulkAssessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BulkAssessments
    * const bulkAssessments = await prisma.bulkAssessment.findMany()
    * ```
    */
  get bulkAssessment(): Prisma.BulkAssessmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bulkAssessmentResponse`: Exposes CRUD operations for the **BulkAssessmentResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BulkAssessmentResponses
    * const bulkAssessmentResponses = await prisma.bulkAssessmentResponse.findMany()
    * ```
    */
  get bulkAssessmentResponse(): Prisma.BulkAssessmentResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.answer`: Exposes CRUD operations for the **Answer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answers
    * const answers = await prisma.answer.findMany()
    * ```
    */
  get answer(): Prisma.AnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featureMaster`: Exposes CRUD operations for the **FeatureMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeatureMasters
    * const featureMasters = await prisma.featureMaster.findMany()
    * ```
    */
  get featureMaster(): Prisma.FeatureMasterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.regionMaster`: Exposes CRUD operations for the **RegionMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegionMasters
    * const regionMasters = await prisma.regionMaster.findMany()
    * ```
    */
  get regionMaster(): Prisma.RegionMasterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.areaMaster`: Exposes CRUD operations for the **AreaMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AreaMasters
    * const areaMasters = await prisma.areaMaster.findMany()
    * ```
    */
  get areaMaster(): Prisma.AreaMasterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyTypeMaster`: Exposes CRUD operations for the **PropertyTypeMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyTypeMasters
    * const propertyTypeMasters = await prisma.propertyTypeMaster.findMany()
    * ```
    */
  get propertyTypeMaster(): Prisma.PropertyTypeMasterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyCategoryMaster`: Exposes CRUD operations for the **PropertyCategoryMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyCategoryMasters
    * const propertyCategoryMasters = await prisma.propertyCategoryMaster.findMany()
    * ```
    */
  get propertyCategoryMaster(): Prisma.PropertyCategoryMasterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.floorPlanMaster`: Exposes CRUD operations for the **FloorPlanMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FloorPlanMasters
    * const floorPlanMasters = await prisma.floorPlanMaster.findMany()
    * ```
    */
  get floorPlanMaster(): Prisma.FloorPlanMasterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.routeMaster`: Exposes CRUD operations for the **RouteMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RouteMasters
    * const routeMasters = await prisma.routeMaster.findMany()
    * ```
    */
  get routeMaster(): Prisma.RouteMasterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.station`: Exposes CRUD operations for the **Station** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stations
    * const stations = await prisma.station.findMany()
    * ```
    */
  get station(): Prisma.StationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questionCategory`: Exposes CRUD operations for the **QuestionCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionCategories
    * const questionCategories = await prisma.questionCategory.findMany()
    * ```
    */
  get questionCategory(): Prisma.QuestionCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mail`: Exposes CRUD operations for the **Mail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mail
    * const mail = await prisma.mail.findMany()
    * ```
    */
  get mail(): Prisma.MailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fileBox`: Exposes CRUD operations for the **FileBox** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileBoxes
    * const fileBoxes = await prisma.fileBox.findMany()
    * ```
    */
  get fileBox(): Prisma.FileBoxDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    UserRole: 'UserRole',
    Company: 'Company',
    Branch: 'Branch',
    Agent: 'Agent',
    Property: 'Property',
    PropertyPublication: 'PropertyPublication',
    PropertyPriceHistory: 'PropertyPriceHistory',
    PropertyStatusHistory: 'PropertyStatusHistory',
    PropertyImage: 'PropertyImage',
    PropertyFeature: 'PropertyFeature',
    PropertyStation: 'PropertyStation',
    Favorite: 'Favorite',
    PropertyView: 'PropertyView',
    PropertyViewDaily: 'PropertyViewDaily',
    Inquiry: 'Inquiry',
    InquiryMessage: 'InquiryMessage',
    BulkAssessment: 'BulkAssessment',
    BulkAssessmentResponse: 'BulkAssessmentResponse',
    Question: 'Question',
    Answer: 'Answer',
    FeatureMaster: 'FeatureMaster',
    RegionMaster: 'RegionMaster',
    AreaMaster: 'AreaMaster',
    PropertyTypeMaster: 'PropertyTypeMaster',
    PropertyCategoryMaster: 'PropertyCategoryMaster',
    FloorPlanMaster: 'FloorPlanMaster',
    RouteMaster: 'RouteMaster',
    Station: 'Station',
    QuestionCategory: 'QuestionCategory',
    Mail: 'Mail',
    FileBox: 'FileBox',
    SystemSetting: 'SystemSetting',
    AuditLog: 'AuditLog',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "role" | "userRole" | "company" | "branch" | "agent" | "property" | "propertyPublication" | "propertyPriceHistory" | "propertyStatusHistory" | "propertyImage" | "propertyFeature" | "propertyStation" | "favorite" | "propertyView" | "propertyViewDaily" | "inquiry" | "inquiryMessage" | "bulkAssessment" | "bulkAssessmentResponse" | "question" | "answer" | "featureMaster" | "regionMaster" | "areaMaster" | "propertyTypeMaster" | "propertyCategoryMaster" | "floorPlanMaster" | "routeMaster" | "station" | "questionCategory" | "mail" | "fileBox" | "systemSetting" | "auditLog" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BranchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      Agent: {
        payload: Prisma.$AgentPayload<ExtArgs>
        fields: Prisma.AgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findFirst: {
            args: Prisma.AgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findMany: {
            args: Prisma.AgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          create: {
            args: Prisma.AgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          createMany: {
            args: Prisma.AgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          delete: {
            args: Prisma.AgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          update: {
            args: Prisma.AgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          upsert: {
            args: Prisma.AgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.AgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>
        fields: Prisma.PropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperty>
          }
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number
          }
        }
      }
      PropertyPublication: {
        payload: Prisma.$PropertyPublicationPayload<ExtArgs>
        fields: Prisma.PropertyPublicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyPublicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPublicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyPublicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPublicationPayload>
          }
          findFirst: {
            args: Prisma.PropertyPublicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPublicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyPublicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPublicationPayload>
          }
          findMany: {
            args: Prisma.PropertyPublicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPublicationPayload>[]
          }
          create: {
            args: Prisma.PropertyPublicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPublicationPayload>
          }
          createMany: {
            args: Prisma.PropertyPublicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyPublicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPublicationPayload>[]
          }
          delete: {
            args: Prisma.PropertyPublicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPublicationPayload>
          }
          update: {
            args: Prisma.PropertyPublicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPublicationPayload>
          }
          deleteMany: {
            args: Prisma.PropertyPublicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyPublicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyPublicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPublicationPayload>[]
          }
          upsert: {
            args: Prisma.PropertyPublicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPublicationPayload>
          }
          aggregate: {
            args: Prisma.PropertyPublicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyPublication>
          }
          groupBy: {
            args: Prisma.PropertyPublicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyPublicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyPublicationCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyPublicationCountAggregateOutputType> | number
          }
        }
      }
      PropertyPriceHistory: {
        payload: Prisma.$PropertyPriceHistoryPayload<ExtArgs>
        fields: Prisma.PropertyPriceHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyPriceHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyPriceHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload>
          }
          findFirst: {
            args: Prisma.PropertyPriceHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyPriceHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload>
          }
          findMany: {
            args: Prisma.PropertyPriceHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload>[]
          }
          create: {
            args: Prisma.PropertyPriceHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload>
          }
          createMany: {
            args: Prisma.PropertyPriceHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyPriceHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload>[]
          }
          delete: {
            args: Prisma.PropertyPriceHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload>
          }
          update: {
            args: Prisma.PropertyPriceHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PropertyPriceHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyPriceHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyPriceHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload>[]
          }
          upsert: {
            args: Prisma.PropertyPriceHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPriceHistoryPayload>
          }
          aggregate: {
            args: Prisma.PropertyPriceHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyPriceHistory>
          }
          groupBy: {
            args: Prisma.PropertyPriceHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyPriceHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyPriceHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyPriceHistoryCountAggregateOutputType> | number
          }
        }
      }
      PropertyStatusHistory: {
        payload: Prisma.$PropertyStatusHistoryPayload<ExtArgs>
        fields: Prisma.PropertyStatusHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyStatusHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyStatusHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload>
          }
          findFirst: {
            args: Prisma.PropertyStatusHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyStatusHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload>
          }
          findMany: {
            args: Prisma.PropertyStatusHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload>[]
          }
          create: {
            args: Prisma.PropertyStatusHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload>
          }
          createMany: {
            args: Prisma.PropertyStatusHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyStatusHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload>[]
          }
          delete: {
            args: Prisma.PropertyStatusHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload>
          }
          update: {
            args: Prisma.PropertyStatusHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PropertyStatusHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyStatusHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyStatusHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload>[]
          }
          upsert: {
            args: Prisma.PropertyStatusHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStatusHistoryPayload>
          }
          aggregate: {
            args: Prisma.PropertyStatusHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyStatusHistory>
          }
          groupBy: {
            args: Prisma.PropertyStatusHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyStatusHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyStatusHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyStatusHistoryCountAggregateOutputType> | number
          }
        }
      }
      PropertyImage: {
        payload: Prisma.$PropertyImagePayload<ExtArgs>
        fields: Prisma.PropertyImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload>
          }
          findFirst: {
            args: Prisma.PropertyImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload>
          }
          findMany: {
            args: Prisma.PropertyImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload>[]
          }
          create: {
            args: Prisma.PropertyImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload>
          }
          createMany: {
            args: Prisma.PropertyImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload>[]
          }
          delete: {
            args: Prisma.PropertyImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload>
          }
          update: {
            args: Prisma.PropertyImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload>
          }
          deleteMany: {
            args: Prisma.PropertyImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload>[]
          }
          upsert: {
            args: Prisma.PropertyImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload>
          }
          aggregate: {
            args: Prisma.PropertyImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyImage>
          }
          groupBy: {
            args: Prisma.PropertyImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyImageCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyImageCountAggregateOutputType> | number
          }
        }
      }
      PropertyFeature: {
        payload: Prisma.$PropertyFeaturePayload<ExtArgs>
        fields: Prisma.PropertyFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>
          }
          findFirst: {
            args: Prisma.PropertyFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>
          }
          findMany: {
            args: Prisma.PropertyFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>[]
          }
          create: {
            args: Prisma.PropertyFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>
          }
          createMany: {
            args: Prisma.PropertyFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>[]
          }
          delete: {
            args: Prisma.PropertyFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>
          }
          update: {
            args: Prisma.PropertyFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>
          }
          deleteMany: {
            args: Prisma.PropertyFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyFeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>[]
          }
          upsert: {
            args: Prisma.PropertyFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>
          }
          aggregate: {
            args: Prisma.PropertyFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyFeature>
          }
          groupBy: {
            args: Prisma.PropertyFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyFeatureCountAggregateOutputType> | number
          }
        }
      }
      PropertyStation: {
        payload: Prisma.$PropertyStationPayload<ExtArgs>
        fields: Prisma.PropertyStationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyStationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyStationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStationPayload>
          }
          findFirst: {
            args: Prisma.PropertyStationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyStationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStationPayload>
          }
          findMany: {
            args: Prisma.PropertyStationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStationPayload>[]
          }
          create: {
            args: Prisma.PropertyStationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStationPayload>
          }
          createMany: {
            args: Prisma.PropertyStationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyStationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStationPayload>[]
          }
          delete: {
            args: Prisma.PropertyStationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStationPayload>
          }
          update: {
            args: Prisma.PropertyStationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStationPayload>
          }
          deleteMany: {
            args: Prisma.PropertyStationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyStationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyStationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStationPayload>[]
          }
          upsert: {
            args: Prisma.PropertyStationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyStationPayload>
          }
          aggregate: {
            args: Prisma.PropertyStationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyStation>
          }
          groupBy: {
            args: Prisma.PropertyStationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyStationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyStationCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyStationCountAggregateOutputType> | number
          }
        }
      }
      Favorite: {
        payload: Prisma.$FavoritePayload<ExtArgs>
        fields: Prisma.FavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findFirst: {
            args: Prisma.FavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findMany: {
            args: Prisma.FavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          create: {
            args: Prisma.FavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          createMany: {
            args: Prisma.FavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          delete: {
            args: Prisma.FavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          update: {
            args: Prisma.FavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          deleteMany: {
            args: Prisma.FavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FavoriteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          upsert: {
            args: Prisma.FavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          aggregate: {
            args: Prisma.FavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavorite>
          }
          groupBy: {
            args: Prisma.FavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<FavoriteCountAggregateOutputType> | number
          }
        }
      }
      PropertyView: {
        payload: Prisma.$PropertyViewPayload<ExtArgs>
        fields: Prisma.PropertyViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          findFirst: {
            args: Prisma.PropertyViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          findMany: {
            args: Prisma.PropertyViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>[]
          }
          create: {
            args: Prisma.PropertyViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          createMany: {
            args: Prisma.PropertyViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>[]
          }
          delete: {
            args: Prisma.PropertyViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          update: {
            args: Prisma.PropertyViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          deleteMany: {
            args: Prisma.PropertyViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyViewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>[]
          }
          upsert: {
            args: Prisma.PropertyViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          aggregate: {
            args: Prisma.PropertyViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyView>
          }
          groupBy: {
            args: Prisma.PropertyViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyViewCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyViewCountAggregateOutputType> | number
          }
        }
      }
      PropertyViewDaily: {
        payload: Prisma.$PropertyViewDailyPayload<ExtArgs>
        fields: Prisma.PropertyViewDailyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyViewDailyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyViewDailyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload>
          }
          findFirst: {
            args: Prisma.PropertyViewDailyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyViewDailyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload>
          }
          findMany: {
            args: Prisma.PropertyViewDailyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload>[]
          }
          create: {
            args: Prisma.PropertyViewDailyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload>
          }
          createMany: {
            args: Prisma.PropertyViewDailyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyViewDailyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload>[]
          }
          delete: {
            args: Prisma.PropertyViewDailyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload>
          }
          update: {
            args: Prisma.PropertyViewDailyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyViewDailyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyViewDailyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyViewDailyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload>[]
          }
          upsert: {
            args: Prisma.PropertyViewDailyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewDailyPayload>
          }
          aggregate: {
            args: Prisma.PropertyViewDailyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyViewDaily>
          }
          groupBy: {
            args: Prisma.PropertyViewDailyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyViewDailyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyViewDailyCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyViewDailyCountAggregateOutputType> | number
          }
        }
      }
      Inquiry: {
        payload: Prisma.$InquiryPayload<ExtArgs>
        fields: Prisma.InquiryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InquiryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InquiryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          findFirst: {
            args: Prisma.InquiryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InquiryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          findMany: {
            args: Prisma.InquiryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>[]
          }
          create: {
            args: Prisma.InquiryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          createMany: {
            args: Prisma.InquiryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InquiryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>[]
          }
          delete: {
            args: Prisma.InquiryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          update: {
            args: Prisma.InquiryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          deleteMany: {
            args: Prisma.InquiryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InquiryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InquiryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>[]
          }
          upsert: {
            args: Prisma.InquiryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          aggregate: {
            args: Prisma.InquiryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInquiry>
          }
          groupBy: {
            args: Prisma.InquiryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InquiryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InquiryCountArgs<ExtArgs>
            result: $Utils.Optional<InquiryCountAggregateOutputType> | number
          }
        }
      }
      InquiryMessage: {
        payload: Prisma.$InquiryMessagePayload<ExtArgs>
        fields: Prisma.InquiryMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InquiryMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InquiryMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryMessagePayload>
          }
          findFirst: {
            args: Prisma.InquiryMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InquiryMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryMessagePayload>
          }
          findMany: {
            args: Prisma.InquiryMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryMessagePayload>[]
          }
          create: {
            args: Prisma.InquiryMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryMessagePayload>
          }
          createMany: {
            args: Prisma.InquiryMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InquiryMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryMessagePayload>[]
          }
          delete: {
            args: Prisma.InquiryMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryMessagePayload>
          }
          update: {
            args: Prisma.InquiryMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryMessagePayload>
          }
          deleteMany: {
            args: Prisma.InquiryMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InquiryMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InquiryMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryMessagePayload>[]
          }
          upsert: {
            args: Prisma.InquiryMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryMessagePayload>
          }
          aggregate: {
            args: Prisma.InquiryMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInquiryMessage>
          }
          groupBy: {
            args: Prisma.InquiryMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<InquiryMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.InquiryMessageCountArgs<ExtArgs>
            result: $Utils.Optional<InquiryMessageCountAggregateOutputType> | number
          }
        }
      }
      BulkAssessment: {
        payload: Prisma.$BulkAssessmentPayload<ExtArgs>
        fields: Prisma.BulkAssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BulkAssessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BulkAssessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentPayload>
          }
          findFirst: {
            args: Prisma.BulkAssessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BulkAssessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentPayload>
          }
          findMany: {
            args: Prisma.BulkAssessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentPayload>[]
          }
          create: {
            args: Prisma.BulkAssessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentPayload>
          }
          createMany: {
            args: Prisma.BulkAssessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BulkAssessmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentPayload>[]
          }
          delete: {
            args: Prisma.BulkAssessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentPayload>
          }
          update: {
            args: Prisma.BulkAssessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentPayload>
          }
          deleteMany: {
            args: Prisma.BulkAssessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BulkAssessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BulkAssessmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentPayload>[]
          }
          upsert: {
            args: Prisma.BulkAssessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentPayload>
          }
          aggregate: {
            args: Prisma.BulkAssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBulkAssessment>
          }
          groupBy: {
            args: Prisma.BulkAssessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<BulkAssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.BulkAssessmentCountArgs<ExtArgs>
            result: $Utils.Optional<BulkAssessmentCountAggregateOutputType> | number
          }
        }
      }
      BulkAssessmentResponse: {
        payload: Prisma.$BulkAssessmentResponsePayload<ExtArgs>
        fields: Prisma.BulkAssessmentResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BulkAssessmentResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BulkAssessmentResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload>
          }
          findFirst: {
            args: Prisma.BulkAssessmentResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BulkAssessmentResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload>
          }
          findMany: {
            args: Prisma.BulkAssessmentResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload>[]
          }
          create: {
            args: Prisma.BulkAssessmentResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload>
          }
          createMany: {
            args: Prisma.BulkAssessmentResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BulkAssessmentResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload>[]
          }
          delete: {
            args: Prisma.BulkAssessmentResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload>
          }
          update: {
            args: Prisma.BulkAssessmentResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload>
          }
          deleteMany: {
            args: Prisma.BulkAssessmentResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BulkAssessmentResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BulkAssessmentResponseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload>[]
          }
          upsert: {
            args: Prisma.BulkAssessmentResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkAssessmentResponsePayload>
          }
          aggregate: {
            args: Prisma.BulkAssessmentResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBulkAssessmentResponse>
          }
          groupBy: {
            args: Prisma.BulkAssessmentResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<BulkAssessmentResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.BulkAssessmentResponseCountArgs<ExtArgs>
            result: $Utils.Optional<BulkAssessmentResponseCountAggregateOutputType> | number
          }
        }
      }
      Question: {
        payload: Prisma.$QuestionPayload<ExtArgs>
        fields: Prisma.QuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findFirst: {
            args: Prisma.QuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findMany: {
            args: Prisma.QuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          create: {
            args: Prisma.QuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          createMany: {
            args: Prisma.QuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          delete: {
            args: Prisma.QuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          update: {
            args: Prisma.QuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.QuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      Answer: {
        payload: Prisma.$AnswerPayload<ExtArgs>
        fields: Prisma.AnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          findFirst: {
            args: Prisma.AnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          findMany: {
            args: Prisma.AnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>[]
          }
          create: {
            args: Prisma.AnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          createMany: {
            args: Prisma.AnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>[]
          }
          delete: {
            args: Prisma.AnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          update: {
            args: Prisma.AnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          deleteMany: {
            args: Prisma.AnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnswerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>[]
          }
          upsert: {
            args: Prisma.AnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          aggregate: {
            args: Prisma.AnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnswer>
          }
          groupBy: {
            args: Prisma.AnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnswerCountArgs<ExtArgs>
            result: $Utils.Optional<AnswerCountAggregateOutputType> | number
          }
        }
      }
      FeatureMaster: {
        payload: Prisma.$FeatureMasterPayload<ExtArgs>
        fields: Prisma.FeatureMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureMasterPayload>
          }
          findFirst: {
            args: Prisma.FeatureMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureMasterPayload>
          }
          findMany: {
            args: Prisma.FeatureMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureMasterPayload>[]
          }
          create: {
            args: Prisma.FeatureMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureMasterPayload>
          }
          createMany: {
            args: Prisma.FeatureMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatureMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureMasterPayload>[]
          }
          delete: {
            args: Prisma.FeatureMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureMasterPayload>
          }
          update: {
            args: Prisma.FeatureMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureMasterPayload>
          }
          deleteMany: {
            args: Prisma.FeatureMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeatureMasterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureMasterPayload>[]
          }
          upsert: {
            args: Prisma.FeatureMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureMasterPayload>
          }
          aggregate: {
            args: Prisma.FeatureMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeatureMaster>
          }
          groupBy: {
            args: Prisma.FeatureMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatureMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatureMasterCountArgs<ExtArgs>
            result: $Utils.Optional<FeatureMasterCountAggregateOutputType> | number
          }
        }
      }
      RegionMaster: {
        payload: Prisma.$RegionMasterPayload<ExtArgs>
        fields: Prisma.RegionMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMasterPayload>
          }
          findFirst: {
            args: Prisma.RegionMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMasterPayload>
          }
          findMany: {
            args: Prisma.RegionMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMasterPayload>[]
          }
          create: {
            args: Prisma.RegionMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMasterPayload>
          }
          createMany: {
            args: Prisma.RegionMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegionMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMasterPayload>[]
          }
          delete: {
            args: Prisma.RegionMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMasterPayload>
          }
          update: {
            args: Prisma.RegionMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMasterPayload>
          }
          deleteMany: {
            args: Prisma.RegionMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegionMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RegionMasterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMasterPayload>[]
          }
          upsert: {
            args: Prisma.RegionMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMasterPayload>
          }
          aggregate: {
            args: Prisma.RegionMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegionMaster>
          }
          groupBy: {
            args: Prisma.RegionMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegionMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionMasterCountArgs<ExtArgs>
            result: $Utils.Optional<RegionMasterCountAggregateOutputType> | number
          }
        }
      }
      AreaMaster: {
        payload: Prisma.$AreaMasterPayload<ExtArgs>
        fields: Prisma.AreaMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AreaMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AreaMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaMasterPayload>
          }
          findFirst: {
            args: Prisma.AreaMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AreaMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaMasterPayload>
          }
          findMany: {
            args: Prisma.AreaMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaMasterPayload>[]
          }
          create: {
            args: Prisma.AreaMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaMasterPayload>
          }
          createMany: {
            args: Prisma.AreaMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AreaMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaMasterPayload>[]
          }
          delete: {
            args: Prisma.AreaMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaMasterPayload>
          }
          update: {
            args: Prisma.AreaMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaMasterPayload>
          }
          deleteMany: {
            args: Prisma.AreaMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AreaMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AreaMasterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaMasterPayload>[]
          }
          upsert: {
            args: Prisma.AreaMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaMasterPayload>
          }
          aggregate: {
            args: Prisma.AreaMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAreaMaster>
          }
          groupBy: {
            args: Prisma.AreaMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<AreaMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.AreaMasterCountArgs<ExtArgs>
            result: $Utils.Optional<AreaMasterCountAggregateOutputType> | number
          }
        }
      }
      PropertyTypeMaster: {
        payload: Prisma.$PropertyTypeMasterPayload<ExtArgs>
        fields: Prisma.PropertyTypeMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyTypeMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyTypeMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>
          }
          findFirst: {
            args: Prisma.PropertyTypeMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyTypeMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>
          }
          findMany: {
            args: Prisma.PropertyTypeMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>[]
          }
          create: {
            args: Prisma.PropertyTypeMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>
          }
          createMany: {
            args: Prisma.PropertyTypeMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyTypeMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>[]
          }
          delete: {
            args: Prisma.PropertyTypeMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>
          }
          update: {
            args: Prisma.PropertyTypeMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>
          }
          deleteMany: {
            args: Prisma.PropertyTypeMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyTypeMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyTypeMasterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>[]
          }
          upsert: {
            args: Prisma.PropertyTypeMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTypeMasterPayload>
          }
          aggregate: {
            args: Prisma.PropertyTypeMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyTypeMaster>
          }
          groupBy: {
            args: Prisma.PropertyTypeMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyTypeMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyTypeMasterCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyTypeMasterCountAggregateOutputType> | number
          }
        }
      }
      PropertyCategoryMaster: {
        payload: Prisma.$PropertyCategoryMasterPayload<ExtArgs>
        fields: Prisma.PropertyCategoryMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyCategoryMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyCategoryMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload>
          }
          findFirst: {
            args: Prisma.PropertyCategoryMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyCategoryMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload>
          }
          findMany: {
            args: Prisma.PropertyCategoryMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload>[]
          }
          create: {
            args: Prisma.PropertyCategoryMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload>
          }
          createMany: {
            args: Prisma.PropertyCategoryMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCategoryMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload>[]
          }
          delete: {
            args: Prisma.PropertyCategoryMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload>
          }
          update: {
            args: Prisma.PropertyCategoryMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload>
          }
          deleteMany: {
            args: Prisma.PropertyCategoryMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyCategoryMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyCategoryMasterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload>[]
          }
          upsert: {
            args: Prisma.PropertyCategoryMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyCategoryMasterPayload>
          }
          aggregate: {
            args: Prisma.PropertyCategoryMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyCategoryMaster>
          }
          groupBy: {
            args: Prisma.PropertyCategoryMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyCategoryMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCategoryMasterCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCategoryMasterCountAggregateOutputType> | number
          }
        }
      }
      FloorPlanMaster: {
        payload: Prisma.$FloorPlanMasterPayload<ExtArgs>
        fields: Prisma.FloorPlanMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FloorPlanMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FloorPlanMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload>
          }
          findFirst: {
            args: Prisma.FloorPlanMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FloorPlanMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload>
          }
          findMany: {
            args: Prisma.FloorPlanMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload>[]
          }
          create: {
            args: Prisma.FloorPlanMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload>
          }
          createMany: {
            args: Prisma.FloorPlanMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FloorPlanMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload>[]
          }
          delete: {
            args: Prisma.FloorPlanMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload>
          }
          update: {
            args: Prisma.FloorPlanMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload>
          }
          deleteMany: {
            args: Prisma.FloorPlanMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FloorPlanMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FloorPlanMasterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload>[]
          }
          upsert: {
            args: Prisma.FloorPlanMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanMasterPayload>
          }
          aggregate: {
            args: Prisma.FloorPlanMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFloorPlanMaster>
          }
          groupBy: {
            args: Prisma.FloorPlanMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<FloorPlanMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.FloorPlanMasterCountArgs<ExtArgs>
            result: $Utils.Optional<FloorPlanMasterCountAggregateOutputType> | number
          }
        }
      }
      RouteMaster: {
        payload: Prisma.$RouteMasterPayload<ExtArgs>
        fields: Prisma.RouteMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteMasterPayload>
          }
          findFirst: {
            args: Prisma.RouteMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteMasterPayload>
          }
          findMany: {
            args: Prisma.RouteMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteMasterPayload>[]
          }
          create: {
            args: Prisma.RouteMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteMasterPayload>
          }
          createMany: {
            args: Prisma.RouteMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RouteMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteMasterPayload>[]
          }
          delete: {
            args: Prisma.RouteMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteMasterPayload>
          }
          update: {
            args: Prisma.RouteMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteMasterPayload>
          }
          deleteMany: {
            args: Prisma.RouteMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RouteMasterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteMasterPayload>[]
          }
          upsert: {
            args: Prisma.RouteMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteMasterPayload>
          }
          aggregate: {
            args: Prisma.RouteMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRouteMaster>
          }
          groupBy: {
            args: Prisma.RouteMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteMasterCountArgs<ExtArgs>
            result: $Utils.Optional<RouteMasterCountAggregateOutputType> | number
          }
        }
      }
      Station: {
        payload: Prisma.$StationPayload<ExtArgs>
        fields: Prisma.StationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload>
          }
          findFirst: {
            args: Prisma.StationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload>
          }
          findMany: {
            args: Prisma.StationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload>[]
          }
          create: {
            args: Prisma.StationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload>
          }
          createMany: {
            args: Prisma.StationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload>[]
          }
          delete: {
            args: Prisma.StationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload>
          }
          update: {
            args: Prisma.StationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload>
          }
          deleteMany: {
            args: Prisma.StationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload>[]
          }
          upsert: {
            args: Prisma.StationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload>
          }
          aggregate: {
            args: Prisma.StationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStation>
          }
          groupBy: {
            args: Prisma.StationGroupByArgs<ExtArgs>
            result: $Utils.Optional<StationGroupByOutputType>[]
          }
          count: {
            args: Prisma.StationCountArgs<ExtArgs>
            result: $Utils.Optional<StationCountAggregateOutputType> | number
          }
        }
      }
      QuestionCategory: {
        payload: Prisma.$QuestionCategoryPayload<ExtArgs>
        fields: Prisma.QuestionCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCategoryPayload>
          }
          findFirst: {
            args: Prisma.QuestionCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCategoryPayload>
          }
          findMany: {
            args: Prisma.QuestionCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCategoryPayload>[]
          }
          create: {
            args: Prisma.QuestionCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCategoryPayload>
          }
          createMany: {
            args: Prisma.QuestionCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCategoryPayload>[]
          }
          delete: {
            args: Prisma.QuestionCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCategoryPayload>
          }
          update: {
            args: Prisma.QuestionCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCategoryPayload>
          }
          deleteMany: {
            args: Prisma.QuestionCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCategoryPayload>[]
          }
          upsert: {
            args: Prisma.QuestionCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCategoryPayload>
          }
          aggregate: {
            args: Prisma.QuestionCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionCategory>
          }
          groupBy: {
            args: Prisma.QuestionCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCategoryCountAggregateOutputType> | number
          }
        }
      }
      Mail: {
        payload: Prisma.$MailPayload<ExtArgs>
        fields: Prisma.MailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailPayload>
          }
          findFirst: {
            args: Prisma.MailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailPayload>
          }
          findMany: {
            args: Prisma.MailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailPayload>[]
          }
          create: {
            args: Prisma.MailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailPayload>
          }
          createMany: {
            args: Prisma.MailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailPayload>[]
          }
          delete: {
            args: Prisma.MailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailPayload>
          }
          update: {
            args: Prisma.MailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailPayload>
          }
          deleteMany: {
            args: Prisma.MailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailPayload>[]
          }
          upsert: {
            args: Prisma.MailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailPayload>
          }
          aggregate: {
            args: Prisma.MailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMail>
          }
          groupBy: {
            args: Prisma.MailGroupByArgs<ExtArgs>
            result: $Utils.Optional<MailGroupByOutputType>[]
          }
          count: {
            args: Prisma.MailCountArgs<ExtArgs>
            result: $Utils.Optional<MailCountAggregateOutputType> | number
          }
        }
      }
      FileBox: {
        payload: Prisma.$FileBoxPayload<ExtArgs>
        fields: Prisma.FileBoxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileBoxFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileBoxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileBoxFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileBoxPayload>
          }
          findFirst: {
            args: Prisma.FileBoxFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileBoxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileBoxFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileBoxPayload>
          }
          findMany: {
            args: Prisma.FileBoxFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileBoxPayload>[]
          }
          create: {
            args: Prisma.FileBoxCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileBoxPayload>
          }
          createMany: {
            args: Prisma.FileBoxCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileBoxCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileBoxPayload>[]
          }
          delete: {
            args: Prisma.FileBoxDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileBoxPayload>
          }
          update: {
            args: Prisma.FileBoxUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileBoxPayload>
          }
          deleteMany: {
            args: Prisma.FileBoxDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileBoxUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileBoxUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileBoxPayload>[]
          }
          upsert: {
            args: Prisma.FileBoxUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileBoxPayload>
          }
          aggregate: {
            args: Prisma.FileBoxAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileBox>
          }
          groupBy: {
            args: Prisma.FileBoxGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileBoxGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileBoxCountArgs<ExtArgs>
            result: $Utils.Optional<FileBoxCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    role?: RoleOmit
    userRole?: UserRoleOmit
    company?: CompanyOmit
    branch?: BranchOmit
    agent?: AgentOmit
    property?: PropertyOmit
    propertyPublication?: PropertyPublicationOmit
    propertyPriceHistory?: PropertyPriceHistoryOmit
    propertyStatusHistory?: PropertyStatusHistoryOmit
    propertyImage?: PropertyImageOmit
    propertyFeature?: PropertyFeatureOmit
    propertyStation?: PropertyStationOmit
    favorite?: FavoriteOmit
    propertyView?: PropertyViewOmit
    propertyViewDaily?: PropertyViewDailyOmit
    inquiry?: InquiryOmit
    inquiryMessage?: InquiryMessageOmit
    bulkAssessment?: BulkAssessmentOmit
    bulkAssessmentResponse?: BulkAssessmentResponseOmit
    question?: QuestionOmit
    answer?: AnswerOmit
    featureMaster?: FeatureMasterOmit
    regionMaster?: RegionMasterOmit
    areaMaster?: AreaMasterOmit
    propertyTypeMaster?: PropertyTypeMasterOmit
    propertyCategoryMaster?: PropertyCategoryMasterOmit
    floorPlanMaster?: FloorPlanMasterOmit
    routeMaster?: RouteMasterOmit
    station?: StationOmit
    questionCategory?: QuestionCategoryOmit
    mail?: MailOmit
    fileBox?: FileBoxOmit
    systemSetting?: SystemSettingOmit
    auditLog?: AuditLogOmit
    notification?: NotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    userRoles: number
    properties: number
    inquiries: number
    favorites: number
    propertyViews: number
    questions: number
    answers: number
    bulkAssessments: number
    mails: number
    fileBoxes: number
    notifications: number
    systemSettingsUpdated: number
    auditLogs: number
    priceHistoryChanges: number
    statusHistoryChanges: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | UserCountOutputTypeCountUserRolesArgs
    properties?: boolean | UserCountOutputTypeCountPropertiesArgs
    inquiries?: boolean | UserCountOutputTypeCountInquiriesArgs
    favorites?: boolean | UserCountOutputTypeCountFavoritesArgs
    propertyViews?: boolean | UserCountOutputTypeCountPropertyViewsArgs
    questions?: boolean | UserCountOutputTypeCountQuestionsArgs
    answers?: boolean | UserCountOutputTypeCountAnswersArgs
    bulkAssessments?: boolean | UserCountOutputTypeCountBulkAssessmentsArgs
    mails?: boolean | UserCountOutputTypeCountMailsArgs
    fileBoxes?: boolean | UserCountOutputTypeCountFileBoxesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    systemSettingsUpdated?: boolean | UserCountOutputTypeCountSystemSettingsUpdatedArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    priceHistoryChanges?: boolean | UserCountOutputTypeCountPriceHistoryChangesArgs
    statusHistoryChanges?: boolean | UserCountOutputTypeCountStatusHistoryChangesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPropertyViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyViewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBulkAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BulkAssessmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MailWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFileBoxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileBoxWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSystemSettingsUpdatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPriceHistoryChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyPriceHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStatusHistoryChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyStatusHistoryWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    userRoles: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | RoleCountOutputTypeCountUserRolesArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    branches: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | CompanyCountOutputTypeCountBranchesArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
  }


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    agents: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agents?: boolean | BranchCountOutputTypeCountAgentsArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
  }


  /**
   * Count Type AgentCountOutputType
   */

  export type AgentCountOutputType = {
    properties: number
    assignedInquiries: number
    answers: number
    bulkAssessmentResponses: number
  }

  export type AgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | AgentCountOutputTypeCountPropertiesArgs
    assignedInquiries?: boolean | AgentCountOutputTypeCountAssignedInquiriesArgs
    answers?: boolean | AgentCountOutputTypeCountAnswersArgs
    bulkAssessmentResponses?: boolean | AgentCountOutputTypeCountBulkAssessmentResponsesArgs
  }

  // Custom InputTypes
  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentCountOutputType
     */
    select?: AgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountAssignedInquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswerWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountBulkAssessmentResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BulkAssessmentResponseWhereInput
  }


  /**
   * Count Type PropertyCountOutputType
   */

  export type PropertyCountOutputType = {
    priceHistories: number
    statusHistories: number
    images: number
    features: number
    stations: number
    inquiries: number
    favorites: number
    propertyViews: number
    propertyViewDailies: number
  }

  export type PropertyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceHistories?: boolean | PropertyCountOutputTypeCountPriceHistoriesArgs
    statusHistories?: boolean | PropertyCountOutputTypeCountStatusHistoriesArgs
    images?: boolean | PropertyCountOutputTypeCountImagesArgs
    features?: boolean | PropertyCountOutputTypeCountFeaturesArgs
    stations?: boolean | PropertyCountOutputTypeCountStationsArgs
    inquiries?: boolean | PropertyCountOutputTypeCountInquiriesArgs
    favorites?: boolean | PropertyCountOutputTypeCountFavoritesArgs
    propertyViews?: boolean | PropertyCountOutputTypeCountPropertyViewsArgs
    propertyViewDailies?: boolean | PropertyCountOutputTypeCountPropertyViewDailiesArgs
  }

  // Custom InputTypes
  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCountOutputType
     */
    select?: PropertyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountPriceHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyPriceHistoryWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountStatusHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyStatusHistoryWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyImageWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyFeatureWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountStationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyStationWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountInquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountPropertyViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyViewWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountPropertyViewDailiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyViewDailyWhereInput
  }


  /**
   * Count Type InquiryCountOutputType
   */

  export type InquiryCountOutputType = {
    messages: number
  }

  export type InquiryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | InquiryCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * InquiryCountOutputType without action
   */
  export type InquiryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryCountOutputType
     */
    select?: InquiryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InquiryCountOutputType without action
   */
  export type InquiryCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryMessageWhereInput
  }


  /**
   * Count Type BulkAssessmentCountOutputType
   */

  export type BulkAssessmentCountOutputType = {
    responses: number
  }

  export type BulkAssessmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | BulkAssessmentCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * BulkAssessmentCountOutputType without action
   */
  export type BulkAssessmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessmentCountOutputType
     */
    select?: BulkAssessmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BulkAssessmentCountOutputType without action
   */
  export type BulkAssessmentCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BulkAssessmentResponseWhereInput
  }


  /**
   * Count Type QuestionCountOutputType
   */

  export type QuestionCountOutputType = {
    answers: number
  }

  export type QuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | QuestionCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCountOutputType
     */
    select?: QuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswerWhereInput
  }


  /**
   * Count Type FeatureMasterCountOutputType
   */

  export type FeatureMasterCountOutputType = {
    properties: number
  }

  export type FeatureMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | FeatureMasterCountOutputTypeCountPropertiesArgs
  }

  // Custom InputTypes
  /**
   * FeatureMasterCountOutputType without action
   */
  export type FeatureMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureMasterCountOutputType
     */
    select?: FeatureMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeatureMasterCountOutputType without action
   */
  export type FeatureMasterCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyFeatureWhereInput
  }


  /**
   * Count Type RegionMasterCountOutputType
   */

  export type RegionMasterCountOutputType = {
    areas: number
  }

  export type RegionMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    areas?: boolean | RegionMasterCountOutputTypeCountAreasArgs
  }

  // Custom InputTypes
  /**
   * RegionMasterCountOutputType without action
   */
  export type RegionMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMasterCountOutputType
     */
    select?: RegionMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegionMasterCountOutputType without action
   */
  export type RegionMasterCountOutputTypeCountAreasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaMasterWhereInput
  }


  /**
   * Count Type AreaMasterCountOutputType
   */

  export type AreaMasterCountOutputType = {
    properties: number
  }

  export type AreaMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | AreaMasterCountOutputTypeCountPropertiesArgs
  }

  // Custom InputTypes
  /**
   * AreaMasterCountOutputType without action
   */
  export type AreaMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaMasterCountOutputType
     */
    select?: AreaMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AreaMasterCountOutputType without action
   */
  export type AreaMasterCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }


  /**
   * Count Type PropertyTypeMasterCountOutputType
   */

  export type PropertyTypeMasterCountOutputType = {
    properties: number
    bulkAssessments: number
  }

  export type PropertyTypeMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | PropertyTypeMasterCountOutputTypeCountPropertiesArgs
    bulkAssessments?: boolean | PropertyTypeMasterCountOutputTypeCountBulkAssessmentsArgs
  }

  // Custom InputTypes
  /**
   * PropertyTypeMasterCountOutputType without action
   */
  export type PropertyTypeMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMasterCountOutputType
     */
    select?: PropertyTypeMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyTypeMasterCountOutputType without action
   */
  export type PropertyTypeMasterCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * PropertyTypeMasterCountOutputType without action
   */
  export type PropertyTypeMasterCountOutputTypeCountBulkAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BulkAssessmentWhereInput
  }


  /**
   * Count Type PropertyCategoryMasterCountOutputType
   */

  export type PropertyCategoryMasterCountOutputType = {
    properties: number
  }

  export type PropertyCategoryMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | PropertyCategoryMasterCountOutputTypeCountPropertiesArgs
  }

  // Custom InputTypes
  /**
   * PropertyCategoryMasterCountOutputType without action
   */
  export type PropertyCategoryMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategoryMasterCountOutputType
     */
    select?: PropertyCategoryMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyCategoryMasterCountOutputType without action
   */
  export type PropertyCategoryMasterCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }


  /**
   * Count Type FloorPlanMasterCountOutputType
   */

  export type FloorPlanMasterCountOutputType = {
    properties: number
  }

  export type FloorPlanMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | FloorPlanMasterCountOutputTypeCountPropertiesArgs
  }

  // Custom InputTypes
  /**
   * FloorPlanMasterCountOutputType without action
   */
  export type FloorPlanMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlanMasterCountOutputType
     */
    select?: FloorPlanMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FloorPlanMasterCountOutputType without action
   */
  export type FloorPlanMasterCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }


  /**
   * Count Type RouteMasterCountOutputType
   */

  export type RouteMasterCountOutputType = {
    stations: number
  }

  export type RouteMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stations?: boolean | RouteMasterCountOutputTypeCountStationsArgs
  }

  // Custom InputTypes
  /**
   * RouteMasterCountOutputType without action
   */
  export type RouteMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteMasterCountOutputType
     */
    select?: RouteMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RouteMasterCountOutputType without action
   */
  export type RouteMasterCountOutputTypeCountStationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StationWhereInput
  }


  /**
   * Count Type StationCountOutputType
   */

  export type StationCountOutputType = {
    propertyStations: number
  }

  export type StationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyStations?: boolean | StationCountOutputTypeCountPropertyStationsArgs
  }

  // Custom InputTypes
  /**
   * StationCountOutputType without action
   */
  export type StationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationCountOutputType
     */
    select?: StationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StationCountOutputType without action
   */
  export type StationCountOutputTypeCountPropertyStationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyStationWhereInput
  }


  /**
   * Count Type QuestionCategoryCountOutputType
   */

  export type QuestionCategoryCountOutputType = {
    questions: number
  }

  export type QuestionCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | QuestionCategoryCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * QuestionCategoryCountOutputType without action
   */
  export type QuestionCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCategoryCountOutputType
     */
    select?: QuestionCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionCategoryCountOutputType without action
   */
  export type QuestionCategoryCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }


  /**
   * Count Type FileBoxCountOutputType
   */

  export type FileBoxCountOutputType = {
    propertyImages: number
  }

  export type FileBoxCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyImages?: boolean | FileBoxCountOutputTypeCountPropertyImagesArgs
  }

  // Custom InputTypes
  /**
   * FileBoxCountOutputType without action
   */
  export type FileBoxCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileBoxCountOutputType
     */
    select?: FileBoxCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileBoxCountOutputType without action
   */
  export type FileBoxCountOutputTypeCountPropertyImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyImageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    furigana: string | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    phone: string | null
    avatarUrl: string | null
    status: $Enums.UserStatus | null
    emailVerifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    furigana: string | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    phone: string | null
    avatarUrl: string | null
    status: $Enums.UserStatus | null
    emailVerifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    furigana: number
    gender: number
    birthDate: number
    phone: number
    avatarUrl: number
    status: number
    emailVerifiedAt: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    lastLoginAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    furigana?: true
    gender?: true
    birthDate?: true
    phone?: true
    avatarUrl?: true
    status?: true
    emailVerifiedAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    lastLoginAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    furigana?: true
    gender?: true
    birthDate?: true
    phone?: true
    avatarUrl?: true
    status?: true
    emailVerifiedAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    lastLoginAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    furigana?: true
    gender?: true
    birthDate?: true
    phone?: true
    avatarUrl?: true
    status?: true
    emailVerifiedAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    furigana: string | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    phone: string | null
    avatarUrl: string | null
    status: $Enums.UserStatus
    emailVerifiedAt: Date | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    lastLoginAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    furigana?: boolean
    gender?: boolean
    birthDate?: boolean
    phone?: boolean
    avatarUrl?: boolean
    status?: boolean
    emailVerifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lastLoginAt?: boolean
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    agent?: boolean | User$agentArgs<ExtArgs>
    properties?: boolean | User$propertiesArgs<ExtArgs>
    inquiries?: boolean | User$inquiriesArgs<ExtArgs>
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    propertyViews?: boolean | User$propertyViewsArgs<ExtArgs>
    questions?: boolean | User$questionsArgs<ExtArgs>
    answers?: boolean | User$answersArgs<ExtArgs>
    bulkAssessments?: boolean | User$bulkAssessmentsArgs<ExtArgs>
    mails?: boolean | User$mailsArgs<ExtArgs>
    fileBoxes?: boolean | User$fileBoxesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    systemSettingsUpdated?: boolean | User$systemSettingsUpdatedArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    priceHistoryChanges?: boolean | User$priceHistoryChangesArgs<ExtArgs>
    statusHistoryChanges?: boolean | User$statusHistoryChangesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    furigana?: boolean
    gender?: boolean
    birthDate?: boolean
    phone?: boolean
    avatarUrl?: boolean
    status?: boolean
    emailVerifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    furigana?: boolean
    gender?: boolean
    birthDate?: boolean
    phone?: boolean
    avatarUrl?: boolean
    status?: boolean
    emailVerifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    furigana?: boolean
    gender?: boolean
    birthDate?: boolean
    phone?: boolean
    avatarUrl?: boolean
    status?: boolean
    emailVerifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lastLoginAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "furigana" | "gender" | "birthDate" | "phone" | "avatarUrl" | "status" | "emailVerifiedAt" | "createdAt" | "updatedAt" | "deletedAt" | "lastLoginAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    agent?: boolean | User$agentArgs<ExtArgs>
    properties?: boolean | User$propertiesArgs<ExtArgs>
    inquiries?: boolean | User$inquiriesArgs<ExtArgs>
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    propertyViews?: boolean | User$propertyViewsArgs<ExtArgs>
    questions?: boolean | User$questionsArgs<ExtArgs>
    answers?: boolean | User$answersArgs<ExtArgs>
    bulkAssessments?: boolean | User$bulkAssessmentsArgs<ExtArgs>
    mails?: boolean | User$mailsArgs<ExtArgs>
    fileBoxes?: boolean | User$fileBoxesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    systemSettingsUpdated?: boolean | User$systemSettingsUpdatedArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    priceHistoryChanges?: boolean | User$priceHistoryChangesArgs<ExtArgs>
    statusHistoryChanges?: boolean | User$statusHistoryChangesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
      agent: Prisma.$AgentPayload<ExtArgs> | null
      properties: Prisma.$PropertyPayload<ExtArgs>[]
      inquiries: Prisma.$InquiryPayload<ExtArgs>[]
      favorites: Prisma.$FavoritePayload<ExtArgs>[]
      propertyViews: Prisma.$PropertyViewPayload<ExtArgs>[]
      questions: Prisma.$QuestionPayload<ExtArgs>[]
      answers: Prisma.$AnswerPayload<ExtArgs>[]
      bulkAssessments: Prisma.$BulkAssessmentPayload<ExtArgs>[]
      mails: Prisma.$MailPayload<ExtArgs>[]
      fileBoxes: Prisma.$FileBoxPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      systemSettingsUpdated: Prisma.$SystemSettingPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      priceHistoryChanges: Prisma.$PropertyPriceHistoryPayload<ExtArgs>[]
      statusHistoryChanges: Prisma.$PropertyStatusHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      furigana: string | null
      gender: $Enums.Gender | null
      birthDate: Date | null
      phone: string | null
      avatarUrl: string | null
      status: $Enums.UserStatus
      emailVerifiedAt: Date | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      lastLoginAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRoles<T extends User$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agent<T extends User$agentArgs<ExtArgs> = {}>(args?: Subset<T, User$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    properties<T extends User$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, User$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inquiries<T extends User$inquiriesArgs<ExtArgs> = {}>(args?: Subset<T, User$inquiriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favorites<T extends User$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, User$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    propertyViews<T extends User$propertyViewsArgs<ExtArgs> = {}>(args?: Subset<T, User$propertyViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questions<T extends User$questionsArgs<ExtArgs> = {}>(args?: Subset<T, User$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    answers<T extends User$answersArgs<ExtArgs> = {}>(args?: Subset<T, User$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bulkAssessments<T extends User$bulkAssessmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$bulkAssessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkAssessmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mails<T extends User$mailsArgs<ExtArgs> = {}>(args?: Subset<T, User$mailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fileBoxes<T extends User$fileBoxesArgs<ExtArgs> = {}>(args?: Subset<T, User$fileBoxesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileBoxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    systemSettingsUpdated<T extends User$systemSettingsUpdatedArgs<ExtArgs> = {}>(args?: Subset<T, User$systemSettingsUpdatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    priceHistoryChanges<T extends User$priceHistoryChangesArgs<ExtArgs> = {}>(args?: Subset<T, User$priceHistoryChangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPriceHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    statusHistoryChanges<T extends User$statusHistoryChangesArgs<ExtArgs> = {}>(args?: Subset<T, User$statusHistoryChangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyStatusHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly furigana: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'Gender'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly phone: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly emailVerifiedAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.userRoles
   */
  export type User$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.agent
   */
  export type User$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * User.properties
   */
  export type User$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * User.inquiries
   */
  export type User$inquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    where?: InquiryWhereInput
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    cursor?: InquiryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * User.favorites
   */
  export type User$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * User.propertyViews
   */
  export type User$propertyViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    where?: PropertyViewWhereInput
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    cursor?: PropertyViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
  }

  /**
   * User.questions
   */
  export type User$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * User.answers
   */
  export type User$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    where?: AnswerWhereInput
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    cursor?: AnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * User.bulkAssessments
   */
  export type User$bulkAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessment
     */
    select?: BulkAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessment
     */
    omit?: BulkAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentInclude<ExtArgs> | null
    where?: BulkAssessmentWhereInput
    orderBy?: BulkAssessmentOrderByWithRelationInput | BulkAssessmentOrderByWithRelationInput[]
    cursor?: BulkAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BulkAssessmentScalarFieldEnum | BulkAssessmentScalarFieldEnum[]
  }

  /**
   * User.mails
   */
  export type User$mailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mail
     */
    select?: MailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mail
     */
    omit?: MailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailInclude<ExtArgs> | null
    where?: MailWhereInput
    orderBy?: MailOrderByWithRelationInput | MailOrderByWithRelationInput[]
    cursor?: MailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MailScalarFieldEnum | MailScalarFieldEnum[]
  }

  /**
   * User.fileBoxes
   */
  export type User$fileBoxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileBox
     */
    select?: FileBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileBox
     */
    omit?: FileBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileBoxInclude<ExtArgs> | null
    where?: FileBoxWhereInput
    orderBy?: FileBoxOrderByWithRelationInput | FileBoxOrderByWithRelationInput[]
    cursor?: FileBoxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileBoxScalarFieldEnum | FileBoxScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.systemSettingsUpdated
   */
  export type User$systemSettingsUpdatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    cursor?: SystemSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.priceHistoryChanges
   */
  export type User$priceHistoryChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPriceHistory
     */
    select?: PropertyPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPriceHistory
     */
    omit?: PropertyPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPriceHistoryInclude<ExtArgs> | null
    where?: PropertyPriceHistoryWhereInput
    orderBy?: PropertyPriceHistoryOrderByWithRelationInput | PropertyPriceHistoryOrderByWithRelationInput[]
    cursor?: PropertyPriceHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyPriceHistoryScalarFieldEnum | PropertyPriceHistoryScalarFieldEnum[]
  }

  /**
   * User.statusHistoryChanges
   */
  export type User$statusHistoryChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStatusHistory
     */
    select?: PropertyStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStatusHistory
     */
    omit?: PropertyStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStatusHistoryInclude<ExtArgs> | null
    where?: PropertyStatusHistoryWhereInput
    orderBy?: PropertyStatusHistoryOrderByWithRelationInput | PropertyStatusHistoryOrderByWithRelationInput[]
    cursor?: PropertyStatusHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyStatusHistoryScalarFieldEnum | PropertyStatusHistoryScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    permissions: number
    description: number
    createdAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    permissions?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    permissions: JsonValue | null
    description: string | null
    createdAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    permissions?: boolean
    description?: boolean
    createdAt?: boolean
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    permissions?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    permissions?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    permissions?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "permissions" | "description" | "createdAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      permissions: Prisma.JsonValue | null
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRoles<T extends Role$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, Role$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly permissions: FieldRef<"Role", 'Json'>
    readonly description: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.userRoles
   */
  export type Role$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    createdAt: Date | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    createdAt: Date | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    createdAt: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    createdAt?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    createdAt?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    createdAt?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: string
    userId: string
    roleId: string
    createdAt: Date
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
    createdAt?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "roleId" | "createdAt", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roleId: string
      createdAt: Date
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'String'>
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'String'>
    readonly createdAt: FieldRef<"UserRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type CompanySumAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    companyName: string | null
    companyNameKana: string | null
    representativeName: string | null
    postalCode: string | null
    prefecture: string | null
    city: string | null
    address: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    phone: string | null
    fax: string | null
    website: string | null
    licenseNumber: string | null
    associationMembership: string | null
    accountType: $Enums.AccountType | null
    status: $Enums.CompanyStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    companyName: string | null
    companyNameKana: string | null
    representativeName: string | null
    postalCode: string | null
    prefecture: string | null
    city: string | null
    address: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    phone: string | null
    fax: string | null
    website: string | null
    licenseNumber: string | null
    associationMembership: string | null
    accountType: $Enums.AccountType | null
    status: $Enums.CompanyStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    companyName: number
    companyNameKana: number
    representativeName: number
    postalCode: number
    prefecture: number
    city: number
    address: number
    latitude: number
    longitude: number
    phone: number
    fax: number
    website: number
    licenseNumber: number
    associationMembership: number
    accountType: number
    status: number
    metadata: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type CompanySumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    companyName?: true
    companyNameKana?: true
    representativeName?: true
    postalCode?: true
    prefecture?: true
    city?: true
    address?: true
    latitude?: true
    longitude?: true
    phone?: true
    fax?: true
    website?: true
    licenseNumber?: true
    associationMembership?: true
    accountType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    companyName?: true
    companyNameKana?: true
    representativeName?: true
    postalCode?: true
    prefecture?: true
    city?: true
    address?: true
    latitude?: true
    longitude?: true
    phone?: true
    fax?: true
    website?: true
    licenseNumber?: true
    associationMembership?: true
    accountType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    companyName?: true
    companyNameKana?: true
    representativeName?: true
    postalCode?: true
    prefecture?: true
    city?: true
    address?: true
    latitude?: true
    longitude?: true
    phone?: true
    fax?: true
    website?: true
    licenseNumber?: true
    associationMembership?: true
    accountType?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    companyName: string
    companyNameKana: string | null
    representativeName: string
    postalCode: string
    prefecture: string
    city: string
    address: string
    latitude: Decimal | null
    longitude: Decimal | null
    phone: string
    fax: string | null
    website: string | null
    licenseNumber: string
    associationMembership: string | null
    accountType: $Enums.AccountType
    status: $Enums.CompanyStatus
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    companyNameKana?: boolean
    representativeName?: boolean
    postalCode?: boolean
    prefecture?: boolean
    city?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    fax?: boolean
    website?: boolean
    licenseNumber?: boolean
    associationMembership?: boolean
    accountType?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    branches?: boolean | Company$branchesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    companyNameKana?: boolean
    representativeName?: boolean
    postalCode?: boolean
    prefecture?: boolean
    city?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    fax?: boolean
    website?: boolean
    licenseNumber?: boolean
    associationMembership?: boolean
    accountType?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    companyNameKana?: boolean
    representativeName?: boolean
    postalCode?: boolean
    prefecture?: boolean
    city?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    fax?: boolean
    website?: boolean
    licenseNumber?: boolean
    associationMembership?: boolean
    accountType?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    companyName?: boolean
    companyNameKana?: boolean
    representativeName?: boolean
    postalCode?: boolean
    prefecture?: boolean
    city?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    fax?: boolean
    website?: boolean
    licenseNumber?: boolean
    associationMembership?: boolean
    accountType?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyName" | "companyNameKana" | "representativeName" | "postalCode" | "prefecture" | "city" | "address" | "latitude" | "longitude" | "phone" | "fax" | "website" | "licenseNumber" | "associationMembership" | "accountType" | "status" | "metadata" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | Company$branchesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      branches: Prisma.$BranchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyName: string
      companyNameKana: string | null
      representativeName: string
      postalCode: string
      prefecture: string
      city: string
      address: string
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      phone: string
      fax: string | null
      website: string | null
      licenseNumber: string
      associationMembership: string | null
      accountType: $Enums.AccountType
      status: $Enums.CompanyStatus
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branches<T extends Company$branchesArgs<ExtArgs> = {}>(args?: Subset<T, Company$branchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly companyName: FieldRef<"Company", 'String'>
    readonly companyNameKana: FieldRef<"Company", 'String'>
    readonly representativeName: FieldRef<"Company", 'String'>
    readonly postalCode: FieldRef<"Company", 'String'>
    readonly prefecture: FieldRef<"Company", 'String'>
    readonly city: FieldRef<"Company", 'String'>
    readonly address: FieldRef<"Company", 'String'>
    readonly latitude: FieldRef<"Company", 'Decimal'>
    readonly longitude: FieldRef<"Company", 'Decimal'>
    readonly phone: FieldRef<"Company", 'String'>
    readonly fax: FieldRef<"Company", 'String'>
    readonly website: FieldRef<"Company", 'String'>
    readonly licenseNumber: FieldRef<"Company", 'String'>
    readonly associationMembership: FieldRef<"Company", 'String'>
    readonly accountType: FieldRef<"Company", 'AccountType'>
    readonly status: FieldRef<"Company", 'CompanyStatus'>
    readonly metadata: FieldRef<"Company", 'Json'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
    readonly deletedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.branches
   */
  export type Company$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    cursor?: BranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchAvgAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type BranchSumAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type BranchMinAggregateOutputType = {
    id: string | null
    branchName: string | null
    postalCode: string | null
    prefecture: string | null
    city: string | null
    address: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    phone: string | null
    fax: string | null
    businessHours: string | null
    isHeadquarters: boolean | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    id: string | null
    branchName: string | null
    postalCode: string | null
    prefecture: string | null
    city: string | null
    address: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    phone: string | null
    fax: string | null
    businessHours: string | null
    isHeadquarters: boolean | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    branchName: number
    postalCode: number
    prefecture: number
    city: number
    address: number
    latitude: number
    longitude: number
    phone: number
    fax: number
    businessHours: number
    isHeadquarters: number
    companyId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type BranchAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type BranchSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type BranchMinAggregateInputType = {
    id?: true
    branchName?: true
    postalCode?: true
    prefecture?: true
    city?: true
    address?: true
    latitude?: true
    longitude?: true
    phone?: true
    fax?: true
    businessHours?: true
    isHeadquarters?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    branchName?: true
    postalCode?: true
    prefecture?: true
    city?: true
    address?: true
    latitude?: true
    longitude?: true
    phone?: true
    fax?: true
    businessHours?: true
    isHeadquarters?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    branchName?: true
    postalCode?: true
    prefecture?: true
    city?: true
    address?: true
    latitude?: true
    longitude?: true
    phone?: true
    fax?: true
    businessHours?: true
    isHeadquarters?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _avg?: BranchAvgAggregateInputType
    _sum?: BranchSumAggregateInputType
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: string
    branchName: string
    postalCode: string
    prefecture: string
    city: string
    address: string
    latitude: Decimal | null
    longitude: Decimal | null
    phone: string
    fax: string | null
    businessHours: string | null
    isHeadquarters: boolean
    companyId: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchName?: boolean
    postalCode?: boolean
    prefecture?: boolean
    city?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    fax?: boolean
    businessHours?: boolean
    isHeadquarters?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    agents?: boolean | Branch$agentsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchName?: boolean
    postalCode?: boolean
    prefecture?: boolean
    city?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    fax?: boolean
    businessHours?: boolean
    isHeadquarters?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchName?: boolean
    postalCode?: boolean
    prefecture?: boolean
    city?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    fax?: boolean
    businessHours?: boolean
    isHeadquarters?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    branchName?: boolean
    postalCode?: boolean
    prefecture?: boolean
    city?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    fax?: boolean
    businessHours?: boolean
    isHeadquarters?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type BranchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "branchName" | "postalCode" | "prefecture" | "city" | "address" | "latitude" | "longitude" | "phone" | "fax" | "businessHours" | "isHeadquarters" | "companyId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["branch"]>
  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    agents?: boolean | Branch$agentsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type BranchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      agents: Prisma.$AgentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchName: string
      postalCode: string
      prefecture: string
      city: string
      address: string
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      phone: string
      fax: string | null
      businessHours: string | null
      isHeadquarters: boolean
      companyId: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {BranchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches and returns the data updated in the database.
     * @param {BranchUpdateManyAndReturnArgs} args - Arguments to update many Branches.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BranchUpdateManyAndReturnArgs>(args: SelectSubset<T, BranchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agents<T extends Branch$agentsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$agentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'String'>
    readonly branchName: FieldRef<"Branch", 'String'>
    readonly postalCode: FieldRef<"Branch", 'String'>
    readonly prefecture: FieldRef<"Branch", 'String'>
    readonly city: FieldRef<"Branch", 'String'>
    readonly address: FieldRef<"Branch", 'String'>
    readonly latitude: FieldRef<"Branch", 'Decimal'>
    readonly longitude: FieldRef<"Branch", 'Decimal'>
    readonly phone: FieldRef<"Branch", 'String'>
    readonly fax: FieldRef<"Branch", 'String'>
    readonly businessHours: FieldRef<"Branch", 'String'>
    readonly isHeadquarters: FieldRef<"Branch", 'Boolean'>
    readonly companyId: FieldRef<"Branch", 'String'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
    readonly updatedAt: FieldRef<"Branch", 'DateTime'>
    readonly deletedAt: FieldRef<"Branch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch createManyAndReturn
   */
  export type BranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
  }

  /**
   * Branch updateManyAndReturn
   */
  export type BranchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to delete.
     */
    limit?: number
  }

  /**
   * Branch.agents
   */
  export type Branch$agentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    cursor?: AgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model Agent
   */

  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentAvgAggregateOutputType = {
    goodCount: number | null
    responseRate: Decimal | null
    avgResponseMinutes: number | null
  }

  export type AgentSumAggregateOutputType = {
    goodCount: number | null
    responseRate: Decimal | null
    avgResponseMinutes: number | null
  }

  export type AgentMinAggregateOutputType = {
    id: string | null
    position: string | null
    department: string | null
    licenseNumber: string | null
    licenseExpireDate: Date | null
    goodCount: number | null
    responseRate: Decimal | null
    avgResponseMinutes: number | null
    userId: string | null
    branchId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AgentMaxAggregateOutputType = {
    id: string | null
    position: string | null
    department: string | null
    licenseNumber: string | null
    licenseExpireDate: Date | null
    goodCount: number | null
    responseRate: Decimal | null
    avgResponseMinutes: number | null
    userId: string | null
    branchId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AgentCountAggregateOutputType = {
    id: number
    position: number
    department: number
    licenseNumber: number
    licenseExpireDate: number
    goodCount: number
    responseRate: number
    avgResponseMinutes: number
    userId: number
    branchId: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type AgentAvgAggregateInputType = {
    goodCount?: true
    responseRate?: true
    avgResponseMinutes?: true
  }

  export type AgentSumAggregateInputType = {
    goodCount?: true
    responseRate?: true
    avgResponseMinutes?: true
  }

  export type AgentMinAggregateInputType = {
    id?: true
    position?: true
    department?: true
    licenseNumber?: true
    licenseExpireDate?: true
    goodCount?: true
    responseRate?: true
    avgResponseMinutes?: true
    userId?: true
    branchId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AgentMaxAggregateInputType = {
    id?: true
    position?: true
    department?: true
    licenseNumber?: true
    licenseExpireDate?: true
    goodCount?: true
    responseRate?: true
    avgResponseMinutes?: true
    userId?: true
    branchId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AgentCountAggregateInputType = {
    id?: true
    position?: true
    department?: true
    licenseNumber?: true
    licenseExpireDate?: true
    goodCount?: true
    responseRate?: true
    avgResponseMinutes?: true
    userId?: true
    branchId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agent to aggregate.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type AgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithAggregationInput | AgentOrderByWithAggregationInput[]
    by: AgentScalarFieldEnum[] | AgentScalarFieldEnum
    having?: AgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _avg?: AgentAvgAggregateInputType
    _sum?: AgentSumAggregateInputType
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }

  export type AgentGroupByOutputType = {
    id: string
    position: string | null
    department: string | null
    licenseNumber: string | null
    licenseExpireDate: Date | null
    goodCount: number
    responseRate: Decimal | null
    avgResponseMinutes: number | null
    userId: string
    branchId: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends AgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type AgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    position?: boolean
    department?: boolean
    licenseNumber?: boolean
    licenseExpireDate?: boolean
    goodCount?: boolean
    responseRate?: boolean
    avgResponseMinutes?: boolean
    userId?: boolean
    branchId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    properties?: boolean | Agent$propertiesArgs<ExtArgs>
    assignedInquiries?: boolean | Agent$assignedInquiriesArgs<ExtArgs>
    answers?: boolean | Agent$answersArgs<ExtArgs>
    bulkAssessmentResponses?: boolean | Agent$bulkAssessmentResponsesArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    position?: boolean
    department?: boolean
    licenseNumber?: boolean
    licenseExpireDate?: boolean
    goodCount?: boolean
    responseRate?: boolean
    avgResponseMinutes?: boolean
    userId?: boolean
    branchId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    position?: boolean
    department?: boolean
    licenseNumber?: boolean
    licenseExpireDate?: boolean
    goodCount?: boolean
    responseRate?: boolean
    avgResponseMinutes?: boolean
    userId?: boolean
    branchId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectScalar = {
    id?: boolean
    position?: boolean
    department?: boolean
    licenseNumber?: boolean
    licenseExpireDate?: boolean
    goodCount?: boolean
    responseRate?: boolean
    avgResponseMinutes?: boolean
    userId?: boolean
    branchId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type AgentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "position" | "department" | "licenseNumber" | "licenseExpireDate" | "goodCount" | "responseRate" | "avgResponseMinutes" | "userId" | "branchId" | "isActive" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["agent"]>
  export type AgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    properties?: boolean | Agent$propertiesArgs<ExtArgs>
    assignedInquiries?: boolean | Agent$assignedInquiriesArgs<ExtArgs>
    answers?: boolean | Agent$answersArgs<ExtArgs>
    bulkAssessmentResponses?: boolean | Agent$bulkAssessmentResponsesArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type AgentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $AgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
      properties: Prisma.$PropertyPayload<ExtArgs>[]
      assignedInquiries: Prisma.$InquiryPayload<ExtArgs>[]
      answers: Prisma.$AnswerPayload<ExtArgs>[]
      bulkAssessmentResponses: Prisma.$BulkAssessmentResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      position: string | null
      department: string | null
      licenseNumber: string | null
      licenseExpireDate: Date | null
      goodCount: number
      responseRate: Prisma.Decimal | null
      avgResponseMinutes: number | null
      userId: string
      branchId: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["agent"]>
    composites: {}
  }

  type AgentGetPayload<S extends boolean | null | undefined | AgentDefaultArgs> = $Result.GetResult<Prisma.$AgentPayload, S>

  type AgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface AgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agent'], meta: { name: 'Agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {AgentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentFindUniqueArgs>(args: SelectSubset<T, AgentFindUniqueArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentFindFirstArgs>(args?: SelectSubset<T, AgentFindFirstArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentFindManyArgs>(args?: SelectSubset<T, AgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agent.
     * @param {AgentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
     */
    create<T extends AgentCreateArgs>(args: SelectSubset<T, AgentCreateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agents.
     * @param {AgentCreateManyArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentCreateManyArgs>(args?: SelectSubset<T, AgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agents and returns the data saved in the database.
     * @param {AgentCreateManyAndReturnArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agent.
     * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
     */
    delete<T extends AgentDeleteArgs>(args: SelectSubset<T, AgentDeleteArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agent.
     * @param {AgentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentUpdateArgs>(args: SelectSubset<T, AgentUpdateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agents.
     * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentDeleteManyArgs>(args?: SelectSubset<T, AgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentUpdateManyArgs>(args: SelectSubset<T, AgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents and returns the data updated in the database.
     * @param {AgentUpdateManyAndReturnArgs} args - Arguments to update many Agents.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agent.
     * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
     */
    upsert<T extends AgentUpsertArgs>(args: SelectSubset<T, AgentUpsertArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends AgentCountArgs>(
      args?: Subset<T, AgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentGroupByArgs['orderBy'] }
        : { orderBy?: AgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agent model
   */
  readonly fields: AgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    properties<T extends Agent$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, Agent$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedInquiries<T extends Agent$assignedInquiriesArgs<ExtArgs> = {}>(args?: Subset<T, Agent$assignedInquiriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    answers<T extends Agent$answersArgs<ExtArgs> = {}>(args?: Subset<T, Agent$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bulkAssessmentResponses<T extends Agent$bulkAssessmentResponsesArgs<ExtArgs> = {}>(args?: Subset<T, Agent$bulkAssessmentResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkAssessmentResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agent model
   */
  interface AgentFieldRefs {
    readonly id: FieldRef<"Agent", 'String'>
    readonly position: FieldRef<"Agent", 'String'>
    readonly department: FieldRef<"Agent", 'String'>
    readonly licenseNumber: FieldRef<"Agent", 'String'>
    readonly licenseExpireDate: FieldRef<"Agent", 'DateTime'>
    readonly goodCount: FieldRef<"Agent", 'Int'>
    readonly responseRate: FieldRef<"Agent", 'Decimal'>
    readonly avgResponseMinutes: FieldRef<"Agent", 'Int'>
    readonly userId: FieldRef<"Agent", 'String'>
    readonly branchId: FieldRef<"Agent", 'String'>
    readonly isActive: FieldRef<"Agent", 'Boolean'>
    readonly createdAt: FieldRef<"Agent", 'DateTime'>
    readonly updatedAt: FieldRef<"Agent", 'DateTime'>
    readonly deletedAt: FieldRef<"Agent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agent findUnique
   */
  export type AgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findUniqueOrThrow
   */
  export type AgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findFirst
   */
  export type AgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findFirstOrThrow
   */
  export type AgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findMany
   */
  export type AgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agents to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent create
   */
  export type AgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to create a Agent.
     */
    data: XOR<AgentCreateInput, AgentUncheckedCreateInput>
  }

  /**
   * Agent createMany
   */
  export type AgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent createManyAndReturn
   */
  export type AgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent update
   */
  export type AgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to update a Agent.
     */
    data: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
    /**
     * Choose, which Agent to update.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent updateMany
   */
  export type AgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
  }

  /**
   * Agent updateManyAndReturn
   */
  export type AgentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent upsert
   */
  export type AgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The filter to search for the Agent to update in case it exists.
     */
    where: AgentWhereUniqueInput
    /**
     * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
     */
    create: XOR<AgentCreateInput, AgentUncheckedCreateInput>
    /**
     * In case the Agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
  }

  /**
   * Agent delete
   */
  export type AgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter which Agent to delete.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent deleteMany
   */
  export type AgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agents to delete
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to delete.
     */
    limit?: number
  }

  /**
   * Agent.properties
   */
  export type Agent$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Agent.assignedInquiries
   */
  export type Agent$assignedInquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    where?: InquiryWhereInput
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    cursor?: InquiryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Agent.answers
   */
  export type Agent$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    where?: AnswerWhereInput
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    cursor?: AnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Agent.bulkAssessmentResponses
   */
  export type Agent$bulkAssessmentResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessmentResponse
     */
    select?: BulkAssessmentResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessmentResponse
     */
    omit?: BulkAssessmentResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentResponseInclude<ExtArgs> | null
    where?: BulkAssessmentResponseWhereInput
    orderBy?: BulkAssessmentResponseOrderByWithRelationInput | BulkAssessmentResponseOrderByWithRelationInput[]
    cursor?: BulkAssessmentResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BulkAssessmentResponseScalarFieldEnum | BulkAssessmentResponseScalarFieldEnum[]
  }

  /**
   * Agent without action
   */
  export type AgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
  }


  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyAvgAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
    layoutNumber: number | null
    buildingArea: Decimal | null
    landArea: Decimal | null
    balconyArea: Decimal | null
    totalFloors: number | null
    floor: number | null
    currentPrice: number | null
    pricePerTsubo: number | null
    managementFee: number | null
    commonServiceFee: number | null
    depositMonths: Decimal | null
    keyMoneyMonths: Decimal | null
    primaryStationWalkMinutes: number | null
    viewCount: number | null
    inquiryCount: number | null
    favoriteCount: number | null
  }

  export type PropertySumAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
    layoutNumber: number | null
    buildingArea: Decimal | null
    landArea: Decimal | null
    balconyArea: Decimal | null
    totalFloors: number | null
    floor: number | null
    currentPrice: bigint | null
    pricePerTsubo: bigint | null
    managementFee: number | null
    commonServiceFee: number | null
    depositMonths: Decimal | null
    keyMoneyMonths: Decimal | null
    primaryStationWalkMinutes: number | null
    viewCount: number | null
    inquiryCount: number | null
    favoriteCount: number | null
  }

  export type PropertyMinAggregateOutputType = {
    id: string | null
    propertyCode: string | null
    propertyName: string | null
    propertyNameKana: string | null
    propertyTypeId: string | null
    propertyCategoryId: string | null
    areaId: string | null
    transactionType: $Enums.TransactionType | null
    propertyCondition: $Enums.PropertyCondition | null
    postalCode: string | null
    prefecture: string | null
    city: string | null
    town: string | null
    block: string | null
    building: string | null
    roomNumber: string | null
    fullAddress: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    layoutNumber: number | null
    layoutTypeId: string | null
    layoutDisplay: string | null
    buildingArea: Decimal | null
    landArea: Decimal | null
    balconyArea: Decimal | null
    buildingStructure: string | null
    constructionDate: Date | null
    constructionYearMonth: string | null
    totalFloors: number | null
    floor: number | null
    currentPrice: bigint | null
    pricePerTsubo: bigint | null
    managementFee: number | null
    commonServiceFee: number | null
    depositMonths: Decimal | null
    keyMoneyMonths: Decimal | null
    mainImageUrl: string | null
    primaryStationName: string | null
    primaryStationWalkMinutes: number | null
    viewCount: number | null
    inquiryCount: number | null
    favoriteCount: number | null
    agentId: string | null
    remarks: string | null
    internalMemo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    userId: string | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: string | null
    propertyCode: string | null
    propertyName: string | null
    propertyNameKana: string | null
    propertyTypeId: string | null
    propertyCategoryId: string | null
    areaId: string | null
    transactionType: $Enums.TransactionType | null
    propertyCondition: $Enums.PropertyCondition | null
    postalCode: string | null
    prefecture: string | null
    city: string | null
    town: string | null
    block: string | null
    building: string | null
    roomNumber: string | null
    fullAddress: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    layoutNumber: number | null
    layoutTypeId: string | null
    layoutDisplay: string | null
    buildingArea: Decimal | null
    landArea: Decimal | null
    balconyArea: Decimal | null
    buildingStructure: string | null
    constructionDate: Date | null
    constructionYearMonth: string | null
    totalFloors: number | null
    floor: number | null
    currentPrice: bigint | null
    pricePerTsubo: bigint | null
    managementFee: number | null
    commonServiceFee: number | null
    depositMonths: Decimal | null
    keyMoneyMonths: Decimal | null
    mainImageUrl: string | null
    primaryStationName: string | null
    primaryStationWalkMinutes: number | null
    viewCount: number | null
    inquiryCount: number | null
    favoriteCount: number | null
    agentId: string | null
    remarks: string | null
    internalMemo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    userId: string | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    propertyCode: number
    propertyName: number
    propertyNameKana: number
    propertyTypeId: number
    propertyCategoryId: number
    areaId: number
    transactionType: number
    propertyCondition: number
    postalCode: number
    prefecture: number
    city: number
    town: number
    block: number
    building: number
    roomNumber: number
    fullAddress: number
    latitude: number
    longitude: number
    layoutNumber: number
    layoutTypeId: number
    layoutDisplay: number
    buildingArea: number
    landArea: number
    balconyArea: number
    buildingStructure: number
    constructionDate: number
    constructionYearMonth: number
    totalFloors: number
    floor: number
    currentPrice: number
    pricePerTsubo: number
    managementFee: number
    commonServiceFee: number
    depositMonths: number
    keyMoneyMonths: number
    mainImageUrl: number
    primaryStationName: number
    primaryStationWalkMinutes: number
    featureTags: number
    viewCount: number
    inquiryCount: number
    favoriteCount: number
    agentId: number
    remarks: number
    internalMemo: number
    metadata: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    userId: number
    _all: number
  }


  export type PropertyAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    layoutNumber?: true
    buildingArea?: true
    landArea?: true
    balconyArea?: true
    totalFloors?: true
    floor?: true
    currentPrice?: true
    pricePerTsubo?: true
    managementFee?: true
    commonServiceFee?: true
    depositMonths?: true
    keyMoneyMonths?: true
    primaryStationWalkMinutes?: true
    viewCount?: true
    inquiryCount?: true
    favoriteCount?: true
  }

  export type PropertySumAggregateInputType = {
    latitude?: true
    longitude?: true
    layoutNumber?: true
    buildingArea?: true
    landArea?: true
    balconyArea?: true
    totalFloors?: true
    floor?: true
    currentPrice?: true
    pricePerTsubo?: true
    managementFee?: true
    commonServiceFee?: true
    depositMonths?: true
    keyMoneyMonths?: true
    primaryStationWalkMinutes?: true
    viewCount?: true
    inquiryCount?: true
    favoriteCount?: true
  }

  export type PropertyMinAggregateInputType = {
    id?: true
    propertyCode?: true
    propertyName?: true
    propertyNameKana?: true
    propertyTypeId?: true
    propertyCategoryId?: true
    areaId?: true
    transactionType?: true
    propertyCondition?: true
    postalCode?: true
    prefecture?: true
    city?: true
    town?: true
    block?: true
    building?: true
    roomNumber?: true
    fullAddress?: true
    latitude?: true
    longitude?: true
    layoutNumber?: true
    layoutTypeId?: true
    layoutDisplay?: true
    buildingArea?: true
    landArea?: true
    balconyArea?: true
    buildingStructure?: true
    constructionDate?: true
    constructionYearMonth?: true
    totalFloors?: true
    floor?: true
    currentPrice?: true
    pricePerTsubo?: true
    managementFee?: true
    commonServiceFee?: true
    depositMonths?: true
    keyMoneyMonths?: true
    mainImageUrl?: true
    primaryStationName?: true
    primaryStationWalkMinutes?: true
    viewCount?: true
    inquiryCount?: true
    favoriteCount?: true
    agentId?: true
    remarks?: true
    internalMemo?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    userId?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    propertyCode?: true
    propertyName?: true
    propertyNameKana?: true
    propertyTypeId?: true
    propertyCategoryId?: true
    areaId?: true
    transactionType?: true
    propertyCondition?: true
    postalCode?: true
    prefecture?: true
    city?: true
    town?: true
    block?: true
    building?: true
    roomNumber?: true
    fullAddress?: true
    latitude?: true
    longitude?: true
    layoutNumber?: true
    layoutTypeId?: true
    layoutDisplay?: true
    buildingArea?: true
    landArea?: true
    balconyArea?: true
    buildingStructure?: true
    constructionDate?: true
    constructionYearMonth?: true
    totalFloors?: true
    floor?: true
    currentPrice?: true
    pricePerTsubo?: true
    managementFee?: true
    commonServiceFee?: true
    depositMonths?: true
    keyMoneyMonths?: true
    mainImageUrl?: true
    primaryStationName?: true
    primaryStationWalkMinutes?: true
    viewCount?: true
    inquiryCount?: true
    favoriteCount?: true
    agentId?: true
    remarks?: true
    internalMemo?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    userId?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    propertyCode?: true
    propertyName?: true
    propertyNameKana?: true
    propertyTypeId?: true
    propertyCategoryId?: true
    areaId?: true
    transactionType?: true
    propertyCondition?: true
    postalCode?: true
    prefecture?: true
    city?: true
    town?: true
    block?: true
    building?: true
    roomNumber?: true
    fullAddress?: true
    latitude?: true
    longitude?: true
    layoutNumber?: true
    layoutTypeId?: true
    layoutDisplay?: true
    buildingArea?: true
    landArea?: true
    balconyArea?: true
    buildingStructure?: true
    constructionDate?: true
    constructionYearMonth?: true
    totalFloors?: true
    floor?: true
    currentPrice?: true
    pricePerTsubo?: true
    managementFee?: true
    commonServiceFee?: true
    depositMonths?: true
    keyMoneyMonths?: true
    mainImageUrl?: true
    primaryStationName?: true
    primaryStationWalkMinutes?: true
    featureTags?: true
    viewCount?: true
    inquiryCount?: true
    favoriteCount?: true
    agentId?: true
    remarks?: true
    internalMemo?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    userId?: true
    _all?: true
  }

  export type PropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    _count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }




  export type PropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithAggregationInput | PropertyOrderByWithAggregationInput[]
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCountAggregateInputType | true
    _avg?: PropertyAvgAggregateInputType
    _sum?: PropertySumAggregateInputType
    _min?: PropertyMinAggregateInputType
    _max?: PropertyMaxAggregateInputType
  }

  export type PropertyGroupByOutputType = {
    id: string
    propertyCode: string
    propertyName: string
    propertyNameKana: string | null
    propertyTypeId: string | null
    propertyCategoryId: string | null
    areaId: string | null
    transactionType: $Enums.TransactionType | null
    propertyCondition: $Enums.PropertyCondition | null
    postalCode: string | null
    prefecture: string | null
    city: string | null
    town: string | null
    block: string | null
    building: string | null
    roomNumber: string | null
    fullAddress: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    layoutNumber: number | null
    layoutTypeId: string | null
    layoutDisplay: string | null
    buildingArea: Decimal | null
    landArea: Decimal | null
    balconyArea: Decimal | null
    buildingStructure: string | null
    constructionDate: Date | null
    constructionYearMonth: string | null
    totalFloors: number | null
    floor: number | null
    currentPrice: bigint | null
    pricePerTsubo: bigint | null
    managementFee: number | null
    commonServiceFee: number | null
    depositMonths: Decimal | null
    keyMoneyMonths: Decimal | null
    mainImageUrl: string | null
    primaryStationName: string | null
    primaryStationWalkMinutes: number | null
    featureTags: string[]
    viewCount: number
    inquiryCount: number
    favoriteCount: number
    agentId: string | null
    remarks: string | null
    internalMemo: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    userId: string
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>
        }
      >
    >


  export type PropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyCode?: boolean
    propertyName?: boolean
    propertyNameKana?: boolean
    propertyTypeId?: boolean
    propertyCategoryId?: boolean
    areaId?: boolean
    transactionType?: boolean
    propertyCondition?: boolean
    postalCode?: boolean
    prefecture?: boolean
    city?: boolean
    town?: boolean
    block?: boolean
    building?: boolean
    roomNumber?: boolean
    fullAddress?: boolean
    latitude?: boolean
    longitude?: boolean
    layoutNumber?: boolean
    layoutTypeId?: boolean
    layoutDisplay?: boolean
    buildingArea?: boolean
    landArea?: boolean
    balconyArea?: boolean
    buildingStructure?: boolean
    constructionDate?: boolean
    constructionYearMonth?: boolean
    totalFloors?: boolean
    floor?: boolean
    currentPrice?: boolean
    pricePerTsubo?: boolean
    managementFee?: boolean
    commonServiceFee?: boolean
    depositMonths?: boolean
    keyMoneyMonths?: boolean
    mainImageUrl?: boolean
    primaryStationName?: boolean
    primaryStationWalkMinutes?: boolean
    featureTags?: boolean
    viewCount?: boolean
    inquiryCount?: boolean
    favoriteCount?: boolean
    agentId?: boolean
    remarks?: boolean
    internalMemo?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
    propertyType?: boolean | Property$propertyTypeArgs<ExtArgs>
    propertyCategory?: boolean | Property$propertyCategoryArgs<ExtArgs>
    area?: boolean | Property$areaArgs<ExtArgs>
    layoutType?: boolean | Property$layoutTypeArgs<ExtArgs>
    agent?: boolean | Property$agentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    publication?: boolean | Property$publicationArgs<ExtArgs>
    priceHistories?: boolean | Property$priceHistoriesArgs<ExtArgs>
    statusHistories?: boolean | Property$statusHistoriesArgs<ExtArgs>
    images?: boolean | Property$imagesArgs<ExtArgs>
    features?: boolean | Property$featuresArgs<ExtArgs>
    stations?: boolean | Property$stationsArgs<ExtArgs>
    inquiries?: boolean | Property$inquiriesArgs<ExtArgs>
    favorites?: boolean | Property$favoritesArgs<ExtArgs>
    propertyViews?: boolean | Property$propertyViewsArgs<ExtArgs>
    propertyViewDailies?: boolean | Property$propertyViewDailiesArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyCode?: boolean
    propertyName?: boolean
    propertyNameKana?: boolean
    propertyTypeId?: boolean
    propertyCategoryId?: boolean
    areaId?: boolean
    transactionType?: boolean
    propertyCondition?: boolean
    postalCode?: boolean
    prefecture?: boolean
    city?: boolean
    town?: boolean
    block?: boolean
    building?: boolean
    roomNumber?: boolean
    fullAddress?: boolean
    latitude?: boolean
    longitude?: boolean
    layoutNumber?: boolean
    layoutTypeId?: boolean
    layoutDisplay?: boolean
    buildingArea?: boolean
    landArea?: boolean
    balconyArea?: boolean
    buildingStructure?: boolean
    constructionDate?: boolean
    constructionYearMonth?: boolean
    totalFloors?: boolean
    floor?: boolean
    currentPrice?: boolean
    pricePerTsubo?: boolean
    managementFee?: boolean
    commonServiceFee?: boolean
    depositMonths?: boolean
    keyMoneyMonths?: boolean
    mainImageUrl?: boolean
    primaryStationName?: boolean
    primaryStationWalkMinutes?: boolean
    featureTags?: boolean
    viewCount?: boolean
    inquiryCount?: boolean
    favoriteCount?: boolean
    agentId?: boolean
    remarks?: boolean
    internalMemo?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
    propertyType?: boolean | Property$propertyTypeArgs<ExtArgs>
    propertyCategory?: boolean | Property$propertyCategoryArgs<ExtArgs>
    area?: boolean | Property$areaArgs<ExtArgs>
    layoutType?: boolean | Property$layoutTypeArgs<ExtArgs>
    agent?: boolean | Property$agentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyCode?: boolean
    propertyName?: boolean
    propertyNameKana?: boolean
    propertyTypeId?: boolean
    propertyCategoryId?: boolean
    areaId?: boolean
    transactionType?: boolean
    propertyCondition?: boolean
    postalCode?: boolean
    prefecture?: boolean
    city?: boolean
    town?: boolean
    block?: boolean
    building?: boolean
    roomNumber?: boolean
    fullAddress?: boolean
    latitude?: boolean
    longitude?: boolean
    layoutNumber?: boolean
    layoutTypeId?: boolean
    layoutDisplay?: boolean
    buildingArea?: boolean
    landArea?: boolean
    balconyArea?: boolean
    buildingStructure?: boolean
    constructionDate?: boolean
    constructionYearMonth?: boolean
    totalFloors?: boolean
    floor?: boolean
    currentPrice?: boolean
    pricePerTsubo?: boolean
    managementFee?: boolean
    commonServiceFee?: boolean
    depositMonths?: boolean
    keyMoneyMonths?: boolean
    mainImageUrl?: boolean
    primaryStationName?: boolean
    primaryStationWalkMinutes?: boolean
    featureTags?: boolean
    viewCount?: boolean
    inquiryCount?: boolean
    favoriteCount?: boolean
    agentId?: boolean
    remarks?: boolean
    internalMemo?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
    propertyType?: boolean | Property$propertyTypeArgs<ExtArgs>
    propertyCategory?: boolean | Property$propertyCategoryArgs<ExtArgs>
    area?: boolean | Property$areaArgs<ExtArgs>
    layoutType?: boolean | Property$layoutTypeArgs<ExtArgs>
    agent?: boolean | Property$agentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectScalar = {
    id?: boolean
    propertyCode?: boolean
    propertyName?: boolean
    propertyNameKana?: boolean
    propertyTypeId?: boolean
    propertyCategoryId?: boolean
    areaId?: boolean
    transactionType?: boolean
    propertyCondition?: boolean
    postalCode?: boolean
    prefecture?: boolean
    city?: boolean
    town?: boolean
    block?: boolean
    building?: boolean
    roomNumber?: boolean
    fullAddress?: boolean
    latitude?: boolean
    longitude?: boolean
    layoutNumber?: boolean
    layoutTypeId?: boolean
    layoutDisplay?: boolean
    buildingArea?: boolean
    landArea?: boolean
    balconyArea?: boolean
    buildingStructure?: boolean
    constructionDate?: boolean
    constructionYearMonth?: boolean
    totalFloors?: boolean
    floor?: boolean
    currentPrice?: boolean
    pricePerTsubo?: boolean
    managementFee?: boolean
    commonServiceFee?: boolean
    depositMonths?: boolean
    keyMoneyMonths?: boolean
    mainImageUrl?: boolean
    primaryStationName?: boolean
    primaryStationWalkMinutes?: boolean
    featureTags?: boolean
    viewCount?: boolean
    inquiryCount?: boolean
    favoriteCount?: boolean
    agentId?: boolean
    remarks?: boolean
    internalMemo?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
  }

  export type PropertyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyCode" | "propertyName" | "propertyNameKana" | "propertyTypeId" | "propertyCategoryId" | "areaId" | "transactionType" | "propertyCondition" | "postalCode" | "prefecture" | "city" | "town" | "block" | "building" | "roomNumber" | "fullAddress" | "latitude" | "longitude" | "layoutNumber" | "layoutTypeId" | "layoutDisplay" | "buildingArea" | "landArea" | "balconyArea" | "buildingStructure" | "constructionDate" | "constructionYearMonth" | "totalFloors" | "floor" | "currentPrice" | "pricePerTsubo" | "managementFee" | "commonServiceFee" | "depositMonths" | "keyMoneyMonths" | "mainImageUrl" | "primaryStationName" | "primaryStationWalkMinutes" | "featureTags" | "viewCount" | "inquiryCount" | "favoriteCount" | "agentId" | "remarks" | "internalMemo" | "metadata" | "createdAt" | "updatedAt" | "deletedAt" | "userId", ExtArgs["result"]["property"]>
  export type PropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyType?: boolean | Property$propertyTypeArgs<ExtArgs>
    propertyCategory?: boolean | Property$propertyCategoryArgs<ExtArgs>
    area?: boolean | Property$areaArgs<ExtArgs>
    layoutType?: boolean | Property$layoutTypeArgs<ExtArgs>
    agent?: boolean | Property$agentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    publication?: boolean | Property$publicationArgs<ExtArgs>
    priceHistories?: boolean | Property$priceHistoriesArgs<ExtArgs>
    statusHistories?: boolean | Property$statusHistoriesArgs<ExtArgs>
    images?: boolean | Property$imagesArgs<ExtArgs>
    features?: boolean | Property$featuresArgs<ExtArgs>
    stations?: boolean | Property$stationsArgs<ExtArgs>
    inquiries?: boolean | Property$inquiriesArgs<ExtArgs>
    favorites?: boolean | Property$favoritesArgs<ExtArgs>
    propertyViews?: boolean | Property$propertyViewsArgs<ExtArgs>
    propertyViewDailies?: boolean | Property$propertyViewDailiesArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyType?: boolean | Property$propertyTypeArgs<ExtArgs>
    propertyCategory?: boolean | Property$propertyCategoryArgs<ExtArgs>
    area?: boolean | Property$areaArgs<ExtArgs>
    layoutType?: boolean | Property$layoutTypeArgs<ExtArgs>
    agent?: boolean | Property$agentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyType?: boolean | Property$propertyTypeArgs<ExtArgs>
    propertyCategory?: boolean | Property$propertyCategoryArgs<ExtArgs>
    area?: boolean | Property$areaArgs<ExtArgs>
    layoutType?: boolean | Property$layoutTypeArgs<ExtArgs>
    agent?: boolean | Property$agentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Property"
    objects: {
      propertyType: Prisma.$PropertyTypeMasterPayload<ExtArgs> | null
      propertyCategory: Prisma.$PropertyCategoryMasterPayload<ExtArgs> | null
      area: Prisma.$AreaMasterPayload<ExtArgs> | null
      layoutType: Prisma.$FloorPlanMasterPayload<ExtArgs> | null
      agent: Prisma.$AgentPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      publication: Prisma.$PropertyPublicationPayload<ExtArgs> | null
      priceHistories: Prisma.$PropertyPriceHistoryPayload<ExtArgs>[]
      statusHistories: Prisma.$PropertyStatusHistoryPayload<ExtArgs>[]
      images: Prisma.$PropertyImagePayload<ExtArgs>[]
      features: Prisma.$PropertyFeaturePayload<ExtArgs>[]
      stations: Prisma.$PropertyStationPayload<ExtArgs>[]
      inquiries: Prisma.$InquiryPayload<ExtArgs>[]
      favorites: Prisma.$FavoritePayload<ExtArgs>[]
      propertyViews: Prisma.$PropertyViewPayload<ExtArgs>[]
      propertyViewDailies: Prisma.$PropertyViewDailyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyCode: string
      propertyName: string
      propertyNameKana: string | null
      propertyTypeId: string | null
      propertyCategoryId: string | null
      areaId: string | null
      transactionType: $Enums.TransactionType | null
      propertyCondition: $Enums.PropertyCondition | null
      postalCode: string | null
      prefecture: string | null
      city: string | null
      town: string | null
      block: string | null
      building: string | null
      roomNumber: string | null
      fullAddress: string | null
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      layoutNumber: number | null
      layoutTypeId: string | null
      layoutDisplay: string | null
      buildingArea: Prisma.Decimal | null
      landArea: Prisma.Decimal | null
      balconyArea: Prisma.Decimal | null
      buildingStructure: string | null
      constructionDate: Date | null
      constructionYearMonth: string | null
      totalFloors: number | null
      floor: number | null
      currentPrice: bigint | null
      pricePerTsubo: bigint | null
      managementFee: number | null
      commonServiceFee: number | null
      depositMonths: Prisma.Decimal | null
      keyMoneyMonths: Prisma.Decimal | null
      mainImageUrl: string | null
      primaryStationName: string | null
      primaryStationWalkMinutes: number | null
      featureTags: string[]
      viewCount: number
      inquiryCount: number
      favoriteCount: number
      agentId: string | null
      remarks: string | null
      internalMemo: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      userId: string
    }, ExtArgs["result"]["property"]>
    composites: {}
  }

  type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = $Result.GetResult<Prisma.$PropertyPayload, S>

  type PropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyCountAggregateInputType | true
    }

  export interface PropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFindUniqueArgs>(args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Property that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFindFirstArgs>(args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFindManyArgs>(args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
     */
    create<T extends PropertyCreateArgs>(args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Properties.
     * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCreateManyArgs>(args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Properties and returns the data saved in the database.
     * @param {PropertyCreateManyAndReturnArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
     */
    delete<T extends PropertyDeleteArgs>(args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyUpdateArgs>(args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDeleteManyArgs>(args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyUpdateManyArgs>(args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties and returns the data updated in the database.
     * @param {PropertyUpdateManyAndReturnArgs} args - Arguments to update many Properties.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUpsertArgs>(args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Property model
   */
  readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    propertyType<T extends Property$propertyTypeArgs<ExtArgs> = {}>(args?: Subset<T, Property$propertyTypeArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    propertyCategory<T extends Property$propertyCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Property$propertyCategoryArgs<ExtArgs>>): Prisma__PropertyCategoryMasterClient<$Result.GetResult<Prisma.$PropertyCategoryMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    area<T extends Property$areaArgs<ExtArgs> = {}>(args?: Subset<T, Property$areaArgs<ExtArgs>>): Prisma__AreaMasterClient<$Result.GetResult<Prisma.$AreaMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    layoutType<T extends Property$layoutTypeArgs<ExtArgs> = {}>(args?: Subset<T, Property$layoutTypeArgs<ExtArgs>>): Prisma__FloorPlanMasterClient<$Result.GetResult<Prisma.$FloorPlanMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    agent<T extends Property$agentArgs<ExtArgs> = {}>(args?: Subset<T, Property$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    publication<T extends Property$publicationArgs<ExtArgs> = {}>(args?: Subset<T, Property$publicationArgs<ExtArgs>>): Prisma__PropertyPublicationClient<$Result.GetResult<Prisma.$PropertyPublicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    priceHistories<T extends Property$priceHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Property$priceHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPriceHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    statusHistories<T extends Property$statusHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Property$statusHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyStatusHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    images<T extends Property$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Property$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    features<T extends Property$featuresArgs<ExtArgs> = {}>(args?: Subset<T, Property$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stations<T extends Property$stationsArgs<ExtArgs> = {}>(args?: Subset<T, Property$stationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyStationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inquiries<T extends Property$inquiriesArgs<ExtArgs> = {}>(args?: Subset<T, Property$inquiriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favorites<T extends Property$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Property$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    propertyViews<T extends Property$propertyViewsArgs<ExtArgs> = {}>(args?: Subset<T, Property$propertyViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    propertyViewDailies<T extends Property$propertyViewDailiesArgs<ExtArgs> = {}>(args?: Subset<T, Property$propertyViewDailiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewDailyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Property model
   */
  interface PropertyFieldRefs {
    readonly id: FieldRef<"Property", 'String'>
    readonly propertyCode: FieldRef<"Property", 'String'>
    readonly propertyName: FieldRef<"Property", 'String'>
    readonly propertyNameKana: FieldRef<"Property", 'String'>
    readonly propertyTypeId: FieldRef<"Property", 'String'>
    readonly propertyCategoryId: FieldRef<"Property", 'String'>
    readonly areaId: FieldRef<"Property", 'String'>
    readonly transactionType: FieldRef<"Property", 'TransactionType'>
    readonly propertyCondition: FieldRef<"Property", 'PropertyCondition'>
    readonly postalCode: FieldRef<"Property", 'String'>
    readonly prefecture: FieldRef<"Property", 'String'>
    readonly city: FieldRef<"Property", 'String'>
    readonly town: FieldRef<"Property", 'String'>
    readonly block: FieldRef<"Property", 'String'>
    readonly building: FieldRef<"Property", 'String'>
    readonly roomNumber: FieldRef<"Property", 'String'>
    readonly fullAddress: FieldRef<"Property", 'String'>
    readonly latitude: FieldRef<"Property", 'Decimal'>
    readonly longitude: FieldRef<"Property", 'Decimal'>
    readonly layoutNumber: FieldRef<"Property", 'Int'>
    readonly layoutTypeId: FieldRef<"Property", 'String'>
    readonly layoutDisplay: FieldRef<"Property", 'String'>
    readonly buildingArea: FieldRef<"Property", 'Decimal'>
    readonly landArea: FieldRef<"Property", 'Decimal'>
    readonly balconyArea: FieldRef<"Property", 'Decimal'>
    readonly buildingStructure: FieldRef<"Property", 'String'>
    readonly constructionDate: FieldRef<"Property", 'DateTime'>
    readonly constructionYearMonth: FieldRef<"Property", 'String'>
    readonly totalFloors: FieldRef<"Property", 'Int'>
    readonly floor: FieldRef<"Property", 'Int'>
    readonly currentPrice: FieldRef<"Property", 'BigInt'>
    readonly pricePerTsubo: FieldRef<"Property", 'BigInt'>
    readonly managementFee: FieldRef<"Property", 'Int'>
    readonly commonServiceFee: FieldRef<"Property", 'Int'>
    readonly depositMonths: FieldRef<"Property", 'Decimal'>
    readonly keyMoneyMonths: FieldRef<"Property", 'Decimal'>
    readonly mainImageUrl: FieldRef<"Property", 'String'>
    readonly primaryStationName: FieldRef<"Property", 'String'>
    readonly primaryStationWalkMinutes: FieldRef<"Property", 'Int'>
    readonly featureTags: FieldRef<"Property", 'String[]'>
    readonly viewCount: FieldRef<"Property", 'Int'>
    readonly inquiryCount: FieldRef<"Property", 'Int'>
    readonly favoriteCount: FieldRef<"Property", 'Int'>
    readonly agentId: FieldRef<"Property", 'String'>
    readonly remarks: FieldRef<"Property", 'String'>
    readonly internalMemo: FieldRef<"Property", 'String'>
    readonly metadata: FieldRef<"Property", 'Json'>
    readonly createdAt: FieldRef<"Property", 'DateTime'>
    readonly updatedAt: FieldRef<"Property", 'DateTime'>
    readonly deletedAt: FieldRef<"Property", 'DateTime'>
    readonly userId: FieldRef<"Property", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property create
   */
  export type PropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a Property.
     */
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
  }

  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Property createManyAndReturn
   */
  export type PropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property update
   */
  export type PropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
  }

  /**
   * Property updateManyAndReturn
   */
  export type PropertyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
  }

  /**
   * Property delete
   */
  export type PropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to delete.
     */
    limit?: number
  }

  /**
   * Property.propertyType
   */
  export type Property$propertyTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTypeMaster
     */
    omit?: PropertyTypeMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    where?: PropertyTypeMasterWhereInput
  }

  /**
   * Property.propertyCategory
   */
  export type Property$propertyCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategoryMaster
     */
    select?: PropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategoryMaster
     */
    omit?: PropertyCategoryMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryMasterInclude<ExtArgs> | null
    where?: PropertyCategoryMasterWhereInput
  }

  /**
   * Property.area
   */
  export type Property$areaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaMaster
     */
    select?: AreaMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaMaster
     */
    omit?: AreaMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaMasterInclude<ExtArgs> | null
    where?: AreaMasterWhereInput
  }

  /**
   * Property.layoutType
   */
  export type Property$layoutTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlanMaster
     */
    select?: FloorPlanMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FloorPlanMaster
     */
    omit?: FloorPlanMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanMasterInclude<ExtArgs> | null
    where?: FloorPlanMasterWhereInput
  }

  /**
   * Property.agent
   */
  export type Property$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * Property.publication
   */
  export type Property$publicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPublication
     */
    select?: PropertyPublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPublication
     */
    omit?: PropertyPublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPublicationInclude<ExtArgs> | null
    where?: PropertyPublicationWhereInput
  }

  /**
   * Property.priceHistories
   */
  export type Property$priceHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPriceHistory
     */
    select?: PropertyPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPriceHistory
     */
    omit?: PropertyPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPriceHistoryInclude<ExtArgs> | null
    where?: PropertyPriceHistoryWhereInput
    orderBy?: PropertyPriceHistoryOrderByWithRelationInput | PropertyPriceHistoryOrderByWithRelationInput[]
    cursor?: PropertyPriceHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyPriceHistoryScalarFieldEnum | PropertyPriceHistoryScalarFieldEnum[]
  }

  /**
   * Property.statusHistories
   */
  export type Property$statusHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStatusHistory
     */
    select?: PropertyStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStatusHistory
     */
    omit?: PropertyStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStatusHistoryInclude<ExtArgs> | null
    where?: PropertyStatusHistoryWhereInput
    orderBy?: PropertyStatusHistoryOrderByWithRelationInput | PropertyStatusHistoryOrderByWithRelationInput[]
    cursor?: PropertyStatusHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyStatusHistoryScalarFieldEnum | PropertyStatusHistoryScalarFieldEnum[]
  }

  /**
   * Property.images
   */
  export type Property$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    where?: PropertyImageWhereInput
    orderBy?: PropertyImageOrderByWithRelationInput | PropertyImageOrderByWithRelationInput[]
    cursor?: PropertyImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyImageScalarFieldEnum | PropertyImageScalarFieldEnum[]
  }

  /**
   * Property.features
   */
  export type Property$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    where?: PropertyFeatureWhereInput
    orderBy?: PropertyFeatureOrderByWithRelationInput | PropertyFeatureOrderByWithRelationInput[]
    cursor?: PropertyFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyFeatureScalarFieldEnum | PropertyFeatureScalarFieldEnum[]
  }

  /**
   * Property.stations
   */
  export type Property$stationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStation
     */
    select?: PropertyStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStation
     */
    omit?: PropertyStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStationInclude<ExtArgs> | null
    where?: PropertyStationWhereInput
    orderBy?: PropertyStationOrderByWithRelationInput | PropertyStationOrderByWithRelationInput[]
    cursor?: PropertyStationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyStationScalarFieldEnum | PropertyStationScalarFieldEnum[]
  }

  /**
   * Property.inquiries
   */
  export type Property$inquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    where?: InquiryWhereInput
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    cursor?: InquiryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Property.favorites
   */
  export type Property$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Property.propertyViews
   */
  export type Property$propertyViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    where?: PropertyViewWhereInput
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    cursor?: PropertyViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
  }

  /**
   * Property.propertyViewDailies
   */
  export type Property$propertyViewDailiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyViewDaily
     */
    select?: PropertyViewDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyViewDaily
     */
    omit?: PropertyViewDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewDailyInclude<ExtArgs> | null
    where?: PropertyViewDailyWhereInput
    orderBy?: PropertyViewDailyOrderByWithRelationInput | PropertyViewDailyOrderByWithRelationInput[]
    cursor?: PropertyViewDailyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyViewDailyScalarFieldEnum | PropertyViewDailyScalarFieldEnum[]
  }

  /**
   * Property without action
   */
  export type PropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
  }


  /**
   * Model PropertyPublication
   */

  export type AggregatePropertyPublication = {
    _count: PropertyPublicationCountAggregateOutputType | null
    _avg: PropertyPublicationAvgAggregateOutputType | null
    _sum: PropertyPublicationSumAggregateOutputType | null
    _min: PropertyPublicationMinAggregateOutputType | null
    _max: PropertyPublicationMaxAggregateOutputType | null
  }

  export type PropertyPublicationAvgAggregateOutputType = {
    featuredOrder: number | null
  }

  export type PropertyPublicationSumAggregateOutputType = {
    featuredOrder: number | null
  }

  export type PropertyPublicationMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    status: $Enums.PublicationStatus | null
    scope: $Enums.PublicScope | null
    featured: boolean | null
    featuredOrder: number | null
    publishedAt: Date | null
    unpublishedAt: Date | null
    soldAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyPublicationMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    status: $Enums.PublicationStatus | null
    scope: $Enums.PublicScope | null
    featured: boolean | null
    featuredOrder: number | null
    publishedAt: Date | null
    unpublishedAt: Date | null
    soldAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyPublicationCountAggregateOutputType = {
    id: number
    propertyId: number
    status: number
    scope: number
    featured: number
    featuredOrder: number
    publishedAt: number
    unpublishedAt: number
    soldAt: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyPublicationAvgAggregateInputType = {
    featuredOrder?: true
  }

  export type PropertyPublicationSumAggregateInputType = {
    featuredOrder?: true
  }

  export type PropertyPublicationMinAggregateInputType = {
    id?: true
    propertyId?: true
    status?: true
    scope?: true
    featured?: true
    featuredOrder?: true
    publishedAt?: true
    unpublishedAt?: true
    soldAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyPublicationMaxAggregateInputType = {
    id?: true
    propertyId?: true
    status?: true
    scope?: true
    featured?: true
    featuredOrder?: true
    publishedAt?: true
    unpublishedAt?: true
    soldAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyPublicationCountAggregateInputType = {
    id?: true
    propertyId?: true
    status?: true
    scope?: true
    featured?: true
    featuredOrder?: true
    publishedAt?: true
    unpublishedAt?: true
    soldAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyPublicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyPublication to aggregate.
     */
    where?: PropertyPublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPublications to fetch.
     */
    orderBy?: PropertyPublicationOrderByWithRelationInput | PropertyPublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyPublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPublications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPublications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyPublications
    **/
    _count?: true | PropertyPublicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyPublicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyPublicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyPublicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyPublicationMaxAggregateInputType
  }

  export type GetPropertyPublicationAggregateType<T extends PropertyPublicationAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyPublication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyPublication[P]>
      : GetScalarType<T[P], AggregatePropertyPublication[P]>
  }




  export type PropertyPublicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyPublicationWhereInput
    orderBy?: PropertyPublicationOrderByWithAggregationInput | PropertyPublicationOrderByWithAggregationInput[]
    by: PropertyPublicationScalarFieldEnum[] | PropertyPublicationScalarFieldEnum
    having?: PropertyPublicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyPublicationCountAggregateInputType | true
    _avg?: PropertyPublicationAvgAggregateInputType
    _sum?: PropertyPublicationSumAggregateInputType
    _min?: PropertyPublicationMinAggregateInputType
    _max?: PropertyPublicationMaxAggregateInputType
  }

  export type PropertyPublicationGroupByOutputType = {
    id: string
    propertyId: string
    status: $Enums.PublicationStatus
    scope: $Enums.PublicScope
    featured: boolean
    featuredOrder: number | null
    publishedAt: Date | null
    unpublishedAt: Date | null
    soldAt: Date | null
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PropertyPublicationCountAggregateOutputType | null
    _avg: PropertyPublicationAvgAggregateOutputType | null
    _sum: PropertyPublicationSumAggregateOutputType | null
    _min: PropertyPublicationMinAggregateOutputType | null
    _max: PropertyPublicationMaxAggregateOutputType | null
  }

  type GetPropertyPublicationGroupByPayload<T extends PropertyPublicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyPublicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyPublicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyPublicationGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyPublicationGroupByOutputType[P]>
        }
      >
    >


  export type PropertyPublicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    status?: boolean
    scope?: boolean
    featured?: boolean
    featuredOrder?: boolean
    publishedAt?: boolean
    unpublishedAt?: boolean
    soldAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyPublication"]>

  export type PropertyPublicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    status?: boolean
    scope?: boolean
    featured?: boolean
    featuredOrder?: boolean
    publishedAt?: boolean
    unpublishedAt?: boolean
    soldAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyPublication"]>

  export type PropertyPublicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    status?: boolean
    scope?: boolean
    featured?: boolean
    featuredOrder?: boolean
    publishedAt?: boolean
    unpublishedAt?: boolean
    soldAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyPublication"]>

  export type PropertyPublicationSelectScalar = {
    id?: boolean
    propertyId?: boolean
    status?: boolean
    scope?: boolean
    featured?: boolean
    featuredOrder?: boolean
    publishedAt?: boolean
    unpublishedAt?: boolean
    soldAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyPublicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "status" | "scope" | "featured" | "featuredOrder" | "publishedAt" | "unpublishedAt" | "soldAt" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["propertyPublication"]>
  export type PropertyPublicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyPublicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyPublicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertyPublicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyPublication"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      status: $Enums.PublicationStatus
      scope: $Enums.PublicScope
      featured: boolean
      featuredOrder: number | null
      publishedAt: Date | null
      unpublishedAt: Date | null
      soldAt: Date | null
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertyPublication"]>
    composites: {}
  }

  type PropertyPublicationGetPayload<S extends boolean | null | undefined | PropertyPublicationDefaultArgs> = $Result.GetResult<Prisma.$PropertyPublicationPayload, S>

  type PropertyPublicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyPublicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyPublicationCountAggregateInputType | true
    }

  export interface PropertyPublicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyPublication'], meta: { name: 'PropertyPublication' } }
    /**
     * Find zero or one PropertyPublication that matches the filter.
     * @param {PropertyPublicationFindUniqueArgs} args - Arguments to find a PropertyPublication
     * @example
     * // Get one PropertyPublication
     * const propertyPublication = await prisma.propertyPublication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyPublicationFindUniqueArgs>(args: SelectSubset<T, PropertyPublicationFindUniqueArgs<ExtArgs>>): Prisma__PropertyPublicationClient<$Result.GetResult<Prisma.$PropertyPublicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyPublication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyPublicationFindUniqueOrThrowArgs} args - Arguments to find a PropertyPublication
     * @example
     * // Get one PropertyPublication
     * const propertyPublication = await prisma.propertyPublication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyPublicationFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyPublicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyPublicationClient<$Result.GetResult<Prisma.$PropertyPublicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyPublication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPublicationFindFirstArgs} args - Arguments to find a PropertyPublication
     * @example
     * // Get one PropertyPublication
     * const propertyPublication = await prisma.propertyPublication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyPublicationFindFirstArgs>(args?: SelectSubset<T, PropertyPublicationFindFirstArgs<ExtArgs>>): Prisma__PropertyPublicationClient<$Result.GetResult<Prisma.$PropertyPublicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyPublication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPublicationFindFirstOrThrowArgs} args - Arguments to find a PropertyPublication
     * @example
     * // Get one PropertyPublication
     * const propertyPublication = await prisma.propertyPublication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyPublicationFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyPublicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyPublicationClient<$Result.GetResult<Prisma.$PropertyPublicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyPublications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPublicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyPublications
     * const propertyPublications = await prisma.propertyPublication.findMany()
     * 
     * // Get first 10 PropertyPublications
     * const propertyPublications = await prisma.propertyPublication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyPublicationWithIdOnly = await prisma.propertyPublication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyPublicationFindManyArgs>(args?: SelectSubset<T, PropertyPublicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPublicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyPublication.
     * @param {PropertyPublicationCreateArgs} args - Arguments to create a PropertyPublication.
     * @example
     * // Create one PropertyPublication
     * const PropertyPublication = await prisma.propertyPublication.create({
     *   data: {
     *     // ... data to create a PropertyPublication
     *   }
     * })
     * 
     */
    create<T extends PropertyPublicationCreateArgs>(args: SelectSubset<T, PropertyPublicationCreateArgs<ExtArgs>>): Prisma__PropertyPublicationClient<$Result.GetResult<Prisma.$PropertyPublicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyPublications.
     * @param {PropertyPublicationCreateManyArgs} args - Arguments to create many PropertyPublications.
     * @example
     * // Create many PropertyPublications
     * const propertyPublication = await prisma.propertyPublication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyPublicationCreateManyArgs>(args?: SelectSubset<T, PropertyPublicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyPublications and returns the data saved in the database.
     * @param {PropertyPublicationCreateManyAndReturnArgs} args - Arguments to create many PropertyPublications.
     * @example
     * // Create many PropertyPublications
     * const propertyPublication = await prisma.propertyPublication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyPublications and only return the `id`
     * const propertyPublicationWithIdOnly = await prisma.propertyPublication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyPublicationCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyPublicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPublicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyPublication.
     * @param {PropertyPublicationDeleteArgs} args - Arguments to delete one PropertyPublication.
     * @example
     * // Delete one PropertyPublication
     * const PropertyPublication = await prisma.propertyPublication.delete({
     *   where: {
     *     // ... filter to delete one PropertyPublication
     *   }
     * })
     * 
     */
    delete<T extends PropertyPublicationDeleteArgs>(args: SelectSubset<T, PropertyPublicationDeleteArgs<ExtArgs>>): Prisma__PropertyPublicationClient<$Result.GetResult<Prisma.$PropertyPublicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyPublication.
     * @param {PropertyPublicationUpdateArgs} args - Arguments to update one PropertyPublication.
     * @example
     * // Update one PropertyPublication
     * const propertyPublication = await prisma.propertyPublication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyPublicationUpdateArgs>(args: SelectSubset<T, PropertyPublicationUpdateArgs<ExtArgs>>): Prisma__PropertyPublicationClient<$Result.GetResult<Prisma.$PropertyPublicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyPublications.
     * @param {PropertyPublicationDeleteManyArgs} args - Arguments to filter PropertyPublications to delete.
     * @example
     * // Delete a few PropertyPublications
     * const { count } = await prisma.propertyPublication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyPublicationDeleteManyArgs>(args?: SelectSubset<T, PropertyPublicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyPublications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPublicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyPublications
     * const propertyPublication = await prisma.propertyPublication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyPublicationUpdateManyArgs>(args: SelectSubset<T, PropertyPublicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyPublications and returns the data updated in the database.
     * @param {PropertyPublicationUpdateManyAndReturnArgs} args - Arguments to update many PropertyPublications.
     * @example
     * // Update many PropertyPublications
     * const propertyPublication = await prisma.propertyPublication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyPublications and only return the `id`
     * const propertyPublicationWithIdOnly = await prisma.propertyPublication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyPublicationUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyPublicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPublicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyPublication.
     * @param {PropertyPublicationUpsertArgs} args - Arguments to update or create a PropertyPublication.
     * @example
     * // Update or create a PropertyPublication
     * const propertyPublication = await prisma.propertyPublication.upsert({
     *   create: {
     *     // ... data to create a PropertyPublication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyPublication we want to update
     *   }
     * })
     */
    upsert<T extends PropertyPublicationUpsertArgs>(args: SelectSubset<T, PropertyPublicationUpsertArgs<ExtArgs>>): Prisma__PropertyPublicationClient<$Result.GetResult<Prisma.$PropertyPublicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyPublications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPublicationCountArgs} args - Arguments to filter PropertyPublications to count.
     * @example
     * // Count the number of PropertyPublications
     * const count = await prisma.propertyPublication.count({
     *   where: {
     *     // ... the filter for the PropertyPublications we want to count
     *   }
     * })
    **/
    count<T extends PropertyPublicationCountArgs>(
      args?: Subset<T, PropertyPublicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyPublicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyPublication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPublicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyPublicationAggregateArgs>(args: Subset<T, PropertyPublicationAggregateArgs>): Prisma.PrismaPromise<GetPropertyPublicationAggregateType<T>>

    /**
     * Group by PropertyPublication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPublicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyPublicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyPublicationGroupByArgs['orderBy'] }
        : { orderBy?: PropertyPublicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyPublicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyPublicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyPublication model
   */
  readonly fields: PropertyPublicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyPublication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyPublicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyPublication model
   */
  interface PropertyPublicationFieldRefs {
    readonly id: FieldRef<"PropertyPublication", 'String'>
    readonly propertyId: FieldRef<"PropertyPublication", 'String'>
    readonly status: FieldRef<"PropertyPublication", 'PublicationStatus'>
    readonly scope: FieldRef<"PropertyPublication", 'PublicScope'>
    readonly featured: FieldRef<"PropertyPublication", 'Boolean'>
    readonly featuredOrder: FieldRef<"PropertyPublication", 'Int'>
    readonly publishedAt: FieldRef<"PropertyPublication", 'DateTime'>
    readonly unpublishedAt: FieldRef<"PropertyPublication", 'DateTime'>
    readonly soldAt: FieldRef<"PropertyPublication", 'DateTime'>
    readonly expiresAt: FieldRef<"PropertyPublication", 'DateTime'>
    readonly createdAt: FieldRef<"PropertyPublication", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyPublication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyPublication findUnique
   */
  export type PropertyPublicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPublication
     */
    select?: PropertyPublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPublication
     */
    omit?: PropertyPublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPublicationInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPublication to fetch.
     */
    where: PropertyPublicationWhereUniqueInput
  }

  /**
   * PropertyPublication findUniqueOrThrow
   */
  export type PropertyPublicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPublication
     */
    select?: PropertyPublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPublication
     */
    omit?: PropertyPublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPublicationInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPublication to fetch.
     */
    where: PropertyPublicationWhereUniqueInput
  }

  /**
   * PropertyPublication findFirst
   */
  export type PropertyPublicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPublication
     */
    select?: PropertyPublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPublication
     */
    omit?: PropertyPublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPublicationInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPublication to fetch.
     */
    where?: PropertyPublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPublications to fetch.
     */
    orderBy?: PropertyPublicationOrderByWithRelationInput | PropertyPublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyPublications.
     */
    cursor?: PropertyPublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPublications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPublications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyPublications.
     */
    distinct?: PropertyPublicationScalarFieldEnum | PropertyPublicationScalarFieldEnum[]
  }

  /**
   * PropertyPublication findFirstOrThrow
   */
  export type PropertyPublicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPublication
     */
    select?: PropertyPublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPublication
     */
    omit?: PropertyPublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPublicationInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPublication to fetch.
     */
    where?: PropertyPublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPublications to fetch.
     */
    orderBy?: PropertyPublicationOrderByWithRelationInput | PropertyPublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyPublications.
     */
    cursor?: PropertyPublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPublications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPublications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyPublications.
     */
    distinct?: PropertyPublicationScalarFieldEnum | PropertyPublicationScalarFieldEnum[]
  }

  /**
   * PropertyPublication findMany
   */
  export type PropertyPublicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPublication
     */
    select?: PropertyPublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPublication
     */
    omit?: PropertyPublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPublicationInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPublications to fetch.
     */
    where?: PropertyPublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPublications to fetch.
     */
    orderBy?: PropertyPublicationOrderByWithRelationInput | PropertyPublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyPublications.
     */
    cursor?: PropertyPublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPublications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPublications.
     */
    skip?: number
    distinct?: PropertyPublicationScalarFieldEnum | PropertyPublicationScalarFieldEnum[]
  }

  /**
   * PropertyPublication create
   */
  export type PropertyPublicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPublication
     */
    select?: PropertyPublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPublication
     */
    omit?: PropertyPublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPublicationInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyPublication.
     */
    data: XOR<PropertyPublicationCreateInput, PropertyPublicationUncheckedCreateInput>
  }

  /**
   * PropertyPublication createMany
   */
  export type PropertyPublicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyPublications.
     */
    data: PropertyPublicationCreateManyInput | PropertyPublicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyPublication createManyAndReturn
   */
  export type PropertyPublicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPublication
     */
    select?: PropertyPublicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPublication
     */
    omit?: PropertyPublicationOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyPublications.
     */
    data: PropertyPublicationCreateManyInput | PropertyPublicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPublicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyPublication update
   */
  export type PropertyPublicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPublication
     */
    select?: PropertyPublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPublication
     */
    omit?: PropertyPublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPublicationInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyPublication.
     */
    data: XOR<PropertyPublicationUpdateInput, PropertyPublicationUncheckedUpdateInput>
    /**
     * Choose, which PropertyPublication to update.
     */
    where: PropertyPublicationWhereUniqueInput
  }

  /**
   * PropertyPublication updateMany
   */
  export type PropertyPublicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyPublications.
     */
    data: XOR<PropertyPublicationUpdateManyMutationInput, PropertyPublicationUncheckedUpdateManyInput>
    /**
     * Filter which PropertyPublications to update
     */
    where?: PropertyPublicationWhereInput
    /**
     * Limit how many PropertyPublications to update.
     */
    limit?: number
  }

  /**
   * PropertyPublication updateManyAndReturn
   */
  export type PropertyPublicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPublication
     */
    select?: PropertyPublicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPublication
     */
    omit?: PropertyPublicationOmit<ExtArgs> | null
    /**
     * The data used to update PropertyPublications.
     */
    data: XOR<PropertyPublicationUpdateManyMutationInput, PropertyPublicationUncheckedUpdateManyInput>
    /**
     * Filter which PropertyPublications to update
     */
    where?: PropertyPublicationWhereInput
    /**
     * Limit how many PropertyPublications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPublicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyPublication upsert
   */
  export type PropertyPublicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPublication
     */
    select?: PropertyPublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPublication
     */
    omit?: PropertyPublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPublicationInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyPublication to update in case it exists.
     */
    where: PropertyPublicationWhereUniqueInput
    /**
     * In case the PropertyPublication found by the `where` argument doesn't exist, create a new PropertyPublication with this data.
     */
    create: XOR<PropertyPublicationCreateInput, PropertyPublicationUncheckedCreateInput>
    /**
     * In case the PropertyPublication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyPublicationUpdateInput, PropertyPublicationUncheckedUpdateInput>
  }

  /**
   * PropertyPublication delete
   */
  export type PropertyPublicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPublication
     */
    select?: PropertyPublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPublication
     */
    omit?: PropertyPublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPublicationInclude<ExtArgs> | null
    /**
     * Filter which PropertyPublication to delete.
     */
    where: PropertyPublicationWhereUniqueInput
  }

  /**
   * PropertyPublication deleteMany
   */
  export type PropertyPublicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyPublications to delete
     */
    where?: PropertyPublicationWhereInput
    /**
     * Limit how many PropertyPublications to delete.
     */
    limit?: number
  }

  /**
   * PropertyPublication without action
   */
  export type PropertyPublicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPublication
     */
    select?: PropertyPublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPublication
     */
    omit?: PropertyPublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPublicationInclude<ExtArgs> | null
  }


  /**
   * Model PropertyPriceHistory
   */

  export type AggregatePropertyPriceHistory = {
    _count: PropertyPriceHistoryCountAggregateOutputType | null
    _avg: PropertyPriceHistoryAvgAggregateOutputType | null
    _sum: PropertyPriceHistorySumAggregateOutputType | null
    _min: PropertyPriceHistoryMinAggregateOutputType | null
    _max: PropertyPriceHistoryMaxAggregateOutputType | null
  }

  export type PropertyPriceHistoryAvgAggregateOutputType = {
    previousPrice: number | null
    newPrice: number | null
    changePercent: Decimal | null
  }

  export type PropertyPriceHistorySumAggregateOutputType = {
    previousPrice: bigint | null
    newPrice: bigint | null
    changePercent: Decimal | null
  }

  export type PropertyPriceHistoryMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    previousPrice: bigint | null
    newPrice: bigint | null
    changePercent: Decimal | null
    changeReason: string | null
    changedById: string | null
    createdAt: Date | null
  }

  export type PropertyPriceHistoryMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    previousPrice: bigint | null
    newPrice: bigint | null
    changePercent: Decimal | null
    changeReason: string | null
    changedById: string | null
    createdAt: Date | null
  }

  export type PropertyPriceHistoryCountAggregateOutputType = {
    id: number
    propertyId: number
    previousPrice: number
    newPrice: number
    changePercent: number
    changeReason: number
    changedById: number
    createdAt: number
    _all: number
  }


  export type PropertyPriceHistoryAvgAggregateInputType = {
    previousPrice?: true
    newPrice?: true
    changePercent?: true
  }

  export type PropertyPriceHistorySumAggregateInputType = {
    previousPrice?: true
    newPrice?: true
    changePercent?: true
  }

  export type PropertyPriceHistoryMinAggregateInputType = {
    id?: true
    propertyId?: true
    previousPrice?: true
    newPrice?: true
    changePercent?: true
    changeReason?: true
    changedById?: true
    createdAt?: true
  }

  export type PropertyPriceHistoryMaxAggregateInputType = {
    id?: true
    propertyId?: true
    previousPrice?: true
    newPrice?: true
    changePercent?: true
    changeReason?: true
    changedById?: true
    createdAt?: true
  }

  export type PropertyPriceHistoryCountAggregateInputType = {
    id?: true
    propertyId?: true
    previousPrice?: true
    newPrice?: true
    changePercent?: true
    changeReason?: true
    changedById?: true
    createdAt?: true
    _all?: true
  }

  export type PropertyPriceHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyPriceHistory to aggregate.
     */
    where?: PropertyPriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPriceHistories to fetch.
     */
    orderBy?: PropertyPriceHistoryOrderByWithRelationInput | PropertyPriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyPriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyPriceHistories
    **/
    _count?: true | PropertyPriceHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyPriceHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyPriceHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyPriceHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyPriceHistoryMaxAggregateInputType
  }

  export type GetPropertyPriceHistoryAggregateType<T extends PropertyPriceHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyPriceHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyPriceHistory[P]>
      : GetScalarType<T[P], AggregatePropertyPriceHistory[P]>
  }




  export type PropertyPriceHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyPriceHistoryWhereInput
    orderBy?: PropertyPriceHistoryOrderByWithAggregationInput | PropertyPriceHistoryOrderByWithAggregationInput[]
    by: PropertyPriceHistoryScalarFieldEnum[] | PropertyPriceHistoryScalarFieldEnum
    having?: PropertyPriceHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyPriceHistoryCountAggregateInputType | true
    _avg?: PropertyPriceHistoryAvgAggregateInputType
    _sum?: PropertyPriceHistorySumAggregateInputType
    _min?: PropertyPriceHistoryMinAggregateInputType
    _max?: PropertyPriceHistoryMaxAggregateInputType
  }

  export type PropertyPriceHistoryGroupByOutputType = {
    id: string
    propertyId: string
    previousPrice: bigint | null
    newPrice: bigint
    changePercent: Decimal | null
    changeReason: string | null
    changedById: string | null
    createdAt: Date
    _count: PropertyPriceHistoryCountAggregateOutputType | null
    _avg: PropertyPriceHistoryAvgAggregateOutputType | null
    _sum: PropertyPriceHistorySumAggregateOutputType | null
    _min: PropertyPriceHistoryMinAggregateOutputType | null
    _max: PropertyPriceHistoryMaxAggregateOutputType | null
  }

  type GetPropertyPriceHistoryGroupByPayload<T extends PropertyPriceHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyPriceHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyPriceHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyPriceHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyPriceHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PropertyPriceHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    previousPrice?: boolean
    newPrice?: boolean
    changePercent?: boolean
    changeReason?: boolean
    changedById?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    changedBy?: boolean | PropertyPriceHistory$changedByArgs<ExtArgs>
  }, ExtArgs["result"]["propertyPriceHistory"]>

  export type PropertyPriceHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    previousPrice?: boolean
    newPrice?: boolean
    changePercent?: boolean
    changeReason?: boolean
    changedById?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    changedBy?: boolean | PropertyPriceHistory$changedByArgs<ExtArgs>
  }, ExtArgs["result"]["propertyPriceHistory"]>

  export type PropertyPriceHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    previousPrice?: boolean
    newPrice?: boolean
    changePercent?: boolean
    changeReason?: boolean
    changedById?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    changedBy?: boolean | PropertyPriceHistory$changedByArgs<ExtArgs>
  }, ExtArgs["result"]["propertyPriceHistory"]>

  export type PropertyPriceHistorySelectScalar = {
    id?: boolean
    propertyId?: boolean
    previousPrice?: boolean
    newPrice?: boolean
    changePercent?: boolean
    changeReason?: boolean
    changedById?: boolean
    createdAt?: boolean
  }

  export type PropertyPriceHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "previousPrice" | "newPrice" | "changePercent" | "changeReason" | "changedById" | "createdAt", ExtArgs["result"]["propertyPriceHistory"]>
  export type PropertyPriceHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    changedBy?: boolean | PropertyPriceHistory$changedByArgs<ExtArgs>
  }
  export type PropertyPriceHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    changedBy?: boolean | PropertyPriceHistory$changedByArgs<ExtArgs>
  }
  export type PropertyPriceHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    changedBy?: boolean | PropertyPriceHistory$changedByArgs<ExtArgs>
  }

  export type $PropertyPriceHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyPriceHistory"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      changedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      previousPrice: bigint | null
      newPrice: bigint
      changePercent: Prisma.Decimal | null
      changeReason: string | null
      changedById: string | null
      createdAt: Date
    }, ExtArgs["result"]["propertyPriceHistory"]>
    composites: {}
  }

  type PropertyPriceHistoryGetPayload<S extends boolean | null | undefined | PropertyPriceHistoryDefaultArgs> = $Result.GetResult<Prisma.$PropertyPriceHistoryPayload, S>

  type PropertyPriceHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyPriceHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyPriceHistoryCountAggregateInputType | true
    }

  export interface PropertyPriceHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyPriceHistory'], meta: { name: 'PropertyPriceHistory' } }
    /**
     * Find zero or one PropertyPriceHistory that matches the filter.
     * @param {PropertyPriceHistoryFindUniqueArgs} args - Arguments to find a PropertyPriceHistory
     * @example
     * // Get one PropertyPriceHistory
     * const propertyPriceHistory = await prisma.propertyPriceHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyPriceHistoryFindUniqueArgs>(args: SelectSubset<T, PropertyPriceHistoryFindUniqueArgs<ExtArgs>>): Prisma__PropertyPriceHistoryClient<$Result.GetResult<Prisma.$PropertyPriceHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyPriceHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyPriceHistoryFindUniqueOrThrowArgs} args - Arguments to find a PropertyPriceHistory
     * @example
     * // Get one PropertyPriceHistory
     * const propertyPriceHistory = await prisma.propertyPriceHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyPriceHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyPriceHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyPriceHistoryClient<$Result.GetResult<Prisma.$PropertyPriceHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyPriceHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPriceHistoryFindFirstArgs} args - Arguments to find a PropertyPriceHistory
     * @example
     * // Get one PropertyPriceHistory
     * const propertyPriceHistory = await prisma.propertyPriceHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyPriceHistoryFindFirstArgs>(args?: SelectSubset<T, PropertyPriceHistoryFindFirstArgs<ExtArgs>>): Prisma__PropertyPriceHistoryClient<$Result.GetResult<Prisma.$PropertyPriceHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyPriceHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPriceHistoryFindFirstOrThrowArgs} args - Arguments to find a PropertyPriceHistory
     * @example
     * // Get one PropertyPriceHistory
     * const propertyPriceHistory = await prisma.propertyPriceHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyPriceHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyPriceHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyPriceHistoryClient<$Result.GetResult<Prisma.$PropertyPriceHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyPriceHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPriceHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyPriceHistories
     * const propertyPriceHistories = await prisma.propertyPriceHistory.findMany()
     * 
     * // Get first 10 PropertyPriceHistories
     * const propertyPriceHistories = await prisma.propertyPriceHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyPriceHistoryWithIdOnly = await prisma.propertyPriceHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyPriceHistoryFindManyArgs>(args?: SelectSubset<T, PropertyPriceHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPriceHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyPriceHistory.
     * @param {PropertyPriceHistoryCreateArgs} args - Arguments to create a PropertyPriceHistory.
     * @example
     * // Create one PropertyPriceHistory
     * const PropertyPriceHistory = await prisma.propertyPriceHistory.create({
     *   data: {
     *     // ... data to create a PropertyPriceHistory
     *   }
     * })
     * 
     */
    create<T extends PropertyPriceHistoryCreateArgs>(args: SelectSubset<T, PropertyPriceHistoryCreateArgs<ExtArgs>>): Prisma__PropertyPriceHistoryClient<$Result.GetResult<Prisma.$PropertyPriceHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyPriceHistories.
     * @param {PropertyPriceHistoryCreateManyArgs} args - Arguments to create many PropertyPriceHistories.
     * @example
     * // Create many PropertyPriceHistories
     * const propertyPriceHistory = await prisma.propertyPriceHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyPriceHistoryCreateManyArgs>(args?: SelectSubset<T, PropertyPriceHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyPriceHistories and returns the data saved in the database.
     * @param {PropertyPriceHistoryCreateManyAndReturnArgs} args - Arguments to create many PropertyPriceHistories.
     * @example
     * // Create many PropertyPriceHistories
     * const propertyPriceHistory = await prisma.propertyPriceHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyPriceHistories and only return the `id`
     * const propertyPriceHistoryWithIdOnly = await prisma.propertyPriceHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyPriceHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyPriceHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPriceHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyPriceHistory.
     * @param {PropertyPriceHistoryDeleteArgs} args - Arguments to delete one PropertyPriceHistory.
     * @example
     * // Delete one PropertyPriceHistory
     * const PropertyPriceHistory = await prisma.propertyPriceHistory.delete({
     *   where: {
     *     // ... filter to delete one PropertyPriceHistory
     *   }
     * })
     * 
     */
    delete<T extends PropertyPriceHistoryDeleteArgs>(args: SelectSubset<T, PropertyPriceHistoryDeleteArgs<ExtArgs>>): Prisma__PropertyPriceHistoryClient<$Result.GetResult<Prisma.$PropertyPriceHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyPriceHistory.
     * @param {PropertyPriceHistoryUpdateArgs} args - Arguments to update one PropertyPriceHistory.
     * @example
     * // Update one PropertyPriceHistory
     * const propertyPriceHistory = await prisma.propertyPriceHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyPriceHistoryUpdateArgs>(args: SelectSubset<T, PropertyPriceHistoryUpdateArgs<ExtArgs>>): Prisma__PropertyPriceHistoryClient<$Result.GetResult<Prisma.$PropertyPriceHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyPriceHistories.
     * @param {PropertyPriceHistoryDeleteManyArgs} args - Arguments to filter PropertyPriceHistories to delete.
     * @example
     * // Delete a few PropertyPriceHistories
     * const { count } = await prisma.propertyPriceHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyPriceHistoryDeleteManyArgs>(args?: SelectSubset<T, PropertyPriceHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyPriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPriceHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyPriceHistories
     * const propertyPriceHistory = await prisma.propertyPriceHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyPriceHistoryUpdateManyArgs>(args: SelectSubset<T, PropertyPriceHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyPriceHistories and returns the data updated in the database.
     * @param {PropertyPriceHistoryUpdateManyAndReturnArgs} args - Arguments to update many PropertyPriceHistories.
     * @example
     * // Update many PropertyPriceHistories
     * const propertyPriceHistory = await prisma.propertyPriceHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyPriceHistories and only return the `id`
     * const propertyPriceHistoryWithIdOnly = await prisma.propertyPriceHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyPriceHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyPriceHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPriceHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyPriceHistory.
     * @param {PropertyPriceHistoryUpsertArgs} args - Arguments to update or create a PropertyPriceHistory.
     * @example
     * // Update or create a PropertyPriceHistory
     * const propertyPriceHistory = await prisma.propertyPriceHistory.upsert({
     *   create: {
     *     // ... data to create a PropertyPriceHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyPriceHistory we want to update
     *   }
     * })
     */
    upsert<T extends PropertyPriceHistoryUpsertArgs>(args: SelectSubset<T, PropertyPriceHistoryUpsertArgs<ExtArgs>>): Prisma__PropertyPriceHistoryClient<$Result.GetResult<Prisma.$PropertyPriceHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyPriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPriceHistoryCountArgs} args - Arguments to filter PropertyPriceHistories to count.
     * @example
     * // Count the number of PropertyPriceHistories
     * const count = await prisma.propertyPriceHistory.count({
     *   where: {
     *     // ... the filter for the PropertyPriceHistories we want to count
     *   }
     * })
    **/
    count<T extends PropertyPriceHistoryCountArgs>(
      args?: Subset<T, PropertyPriceHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyPriceHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyPriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPriceHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyPriceHistoryAggregateArgs>(args: Subset<T, PropertyPriceHistoryAggregateArgs>): Prisma.PrismaPromise<GetPropertyPriceHistoryAggregateType<T>>

    /**
     * Group by PropertyPriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPriceHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyPriceHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyPriceHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PropertyPriceHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyPriceHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyPriceHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyPriceHistory model
   */
  readonly fields: PropertyPriceHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyPriceHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyPriceHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    changedBy<T extends PropertyPriceHistory$changedByArgs<ExtArgs> = {}>(args?: Subset<T, PropertyPriceHistory$changedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyPriceHistory model
   */
  interface PropertyPriceHistoryFieldRefs {
    readonly id: FieldRef<"PropertyPriceHistory", 'String'>
    readonly propertyId: FieldRef<"PropertyPriceHistory", 'String'>
    readonly previousPrice: FieldRef<"PropertyPriceHistory", 'BigInt'>
    readonly newPrice: FieldRef<"PropertyPriceHistory", 'BigInt'>
    readonly changePercent: FieldRef<"PropertyPriceHistory", 'Decimal'>
    readonly changeReason: FieldRef<"PropertyPriceHistory", 'String'>
    readonly changedById: FieldRef<"PropertyPriceHistory", 'String'>
    readonly createdAt: FieldRef<"PropertyPriceHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyPriceHistory findUnique
   */
  export type PropertyPriceHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPriceHistory
     */
    select?: PropertyPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPriceHistory
     */
    omit?: PropertyPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPriceHistory to fetch.
     */
    where: PropertyPriceHistoryWhereUniqueInput
  }

  /**
   * PropertyPriceHistory findUniqueOrThrow
   */
  export type PropertyPriceHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPriceHistory
     */
    select?: PropertyPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPriceHistory
     */
    omit?: PropertyPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPriceHistory to fetch.
     */
    where: PropertyPriceHistoryWhereUniqueInput
  }

  /**
   * PropertyPriceHistory findFirst
   */
  export type PropertyPriceHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPriceHistory
     */
    select?: PropertyPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPriceHistory
     */
    omit?: PropertyPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPriceHistory to fetch.
     */
    where?: PropertyPriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPriceHistories to fetch.
     */
    orderBy?: PropertyPriceHistoryOrderByWithRelationInput | PropertyPriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyPriceHistories.
     */
    cursor?: PropertyPriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyPriceHistories.
     */
    distinct?: PropertyPriceHistoryScalarFieldEnum | PropertyPriceHistoryScalarFieldEnum[]
  }

  /**
   * PropertyPriceHistory findFirstOrThrow
   */
  export type PropertyPriceHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPriceHistory
     */
    select?: PropertyPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPriceHistory
     */
    omit?: PropertyPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPriceHistory to fetch.
     */
    where?: PropertyPriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPriceHistories to fetch.
     */
    orderBy?: PropertyPriceHistoryOrderByWithRelationInput | PropertyPriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyPriceHistories.
     */
    cursor?: PropertyPriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyPriceHistories.
     */
    distinct?: PropertyPriceHistoryScalarFieldEnum | PropertyPriceHistoryScalarFieldEnum[]
  }

  /**
   * PropertyPriceHistory findMany
   */
  export type PropertyPriceHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPriceHistory
     */
    select?: PropertyPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPriceHistory
     */
    omit?: PropertyPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPriceHistories to fetch.
     */
    where?: PropertyPriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPriceHistories to fetch.
     */
    orderBy?: PropertyPriceHistoryOrderByWithRelationInput | PropertyPriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyPriceHistories.
     */
    cursor?: PropertyPriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPriceHistories.
     */
    skip?: number
    distinct?: PropertyPriceHistoryScalarFieldEnum | PropertyPriceHistoryScalarFieldEnum[]
  }

  /**
   * PropertyPriceHistory create
   */
  export type PropertyPriceHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPriceHistory
     */
    select?: PropertyPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPriceHistory
     */
    omit?: PropertyPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPriceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyPriceHistory.
     */
    data: XOR<PropertyPriceHistoryCreateInput, PropertyPriceHistoryUncheckedCreateInput>
  }

  /**
   * PropertyPriceHistory createMany
   */
  export type PropertyPriceHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyPriceHistories.
     */
    data: PropertyPriceHistoryCreateManyInput | PropertyPriceHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyPriceHistory createManyAndReturn
   */
  export type PropertyPriceHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPriceHistory
     */
    select?: PropertyPriceHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPriceHistory
     */
    omit?: PropertyPriceHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyPriceHistories.
     */
    data: PropertyPriceHistoryCreateManyInput | PropertyPriceHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPriceHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyPriceHistory update
   */
  export type PropertyPriceHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPriceHistory
     */
    select?: PropertyPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPriceHistory
     */
    omit?: PropertyPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPriceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyPriceHistory.
     */
    data: XOR<PropertyPriceHistoryUpdateInput, PropertyPriceHistoryUncheckedUpdateInput>
    /**
     * Choose, which PropertyPriceHistory to update.
     */
    where: PropertyPriceHistoryWhereUniqueInput
  }

  /**
   * PropertyPriceHistory updateMany
   */
  export type PropertyPriceHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyPriceHistories.
     */
    data: XOR<PropertyPriceHistoryUpdateManyMutationInput, PropertyPriceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PropertyPriceHistories to update
     */
    where?: PropertyPriceHistoryWhereInput
    /**
     * Limit how many PropertyPriceHistories to update.
     */
    limit?: number
  }

  /**
   * PropertyPriceHistory updateManyAndReturn
   */
  export type PropertyPriceHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPriceHistory
     */
    select?: PropertyPriceHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPriceHistory
     */
    omit?: PropertyPriceHistoryOmit<ExtArgs> | null
    /**
     * The data used to update PropertyPriceHistories.
     */
    data: XOR<PropertyPriceHistoryUpdateManyMutationInput, PropertyPriceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PropertyPriceHistories to update
     */
    where?: PropertyPriceHistoryWhereInput
    /**
     * Limit how many PropertyPriceHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPriceHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyPriceHistory upsert
   */
  export type PropertyPriceHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPriceHistory
     */
    select?: PropertyPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPriceHistory
     */
    omit?: PropertyPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPriceHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyPriceHistory to update in case it exists.
     */
    where: PropertyPriceHistoryWhereUniqueInput
    /**
     * In case the PropertyPriceHistory found by the `where` argument doesn't exist, create a new PropertyPriceHistory with this data.
     */
    create: XOR<PropertyPriceHistoryCreateInput, PropertyPriceHistoryUncheckedCreateInput>
    /**
     * In case the PropertyPriceHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyPriceHistoryUpdateInput, PropertyPriceHistoryUncheckedUpdateInput>
  }

  /**
   * PropertyPriceHistory delete
   */
  export type PropertyPriceHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPriceHistory
     */
    select?: PropertyPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPriceHistory
     */
    omit?: PropertyPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPriceHistoryInclude<ExtArgs> | null
    /**
     * Filter which PropertyPriceHistory to delete.
     */
    where: PropertyPriceHistoryWhereUniqueInput
  }

  /**
   * PropertyPriceHistory deleteMany
   */
  export type PropertyPriceHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyPriceHistories to delete
     */
    where?: PropertyPriceHistoryWhereInput
    /**
     * Limit how many PropertyPriceHistories to delete.
     */
    limit?: number
  }

  /**
   * PropertyPriceHistory.changedBy
   */
  export type PropertyPriceHistory$changedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PropertyPriceHistory without action
   */
  export type PropertyPriceHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPriceHistory
     */
    select?: PropertyPriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPriceHistory
     */
    omit?: PropertyPriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPriceHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PropertyStatusHistory
   */

  export type AggregatePropertyStatusHistory = {
    _count: PropertyStatusHistoryCountAggregateOutputType | null
    _min: PropertyStatusHistoryMinAggregateOutputType | null
    _max: PropertyStatusHistoryMaxAggregateOutputType | null
  }

  export type PropertyStatusHistoryMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    previousStatus: string | null
    newStatus: string | null
    changeReason: string | null
    changedById: string | null
    createdAt: Date | null
  }

  export type PropertyStatusHistoryMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    previousStatus: string | null
    newStatus: string | null
    changeReason: string | null
    changedById: string | null
    createdAt: Date | null
  }

  export type PropertyStatusHistoryCountAggregateOutputType = {
    id: number
    propertyId: number
    previousStatus: number
    newStatus: number
    changeReason: number
    changedById: number
    createdAt: number
    _all: number
  }


  export type PropertyStatusHistoryMinAggregateInputType = {
    id?: true
    propertyId?: true
    previousStatus?: true
    newStatus?: true
    changeReason?: true
    changedById?: true
    createdAt?: true
  }

  export type PropertyStatusHistoryMaxAggregateInputType = {
    id?: true
    propertyId?: true
    previousStatus?: true
    newStatus?: true
    changeReason?: true
    changedById?: true
    createdAt?: true
  }

  export type PropertyStatusHistoryCountAggregateInputType = {
    id?: true
    propertyId?: true
    previousStatus?: true
    newStatus?: true
    changeReason?: true
    changedById?: true
    createdAt?: true
    _all?: true
  }

  export type PropertyStatusHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyStatusHistory to aggregate.
     */
    where?: PropertyStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyStatusHistories to fetch.
     */
    orderBy?: PropertyStatusHistoryOrderByWithRelationInput | PropertyStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyStatusHistories
    **/
    _count?: true | PropertyStatusHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyStatusHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyStatusHistoryMaxAggregateInputType
  }

  export type GetPropertyStatusHistoryAggregateType<T extends PropertyStatusHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyStatusHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyStatusHistory[P]>
      : GetScalarType<T[P], AggregatePropertyStatusHistory[P]>
  }




  export type PropertyStatusHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyStatusHistoryWhereInput
    orderBy?: PropertyStatusHistoryOrderByWithAggregationInput | PropertyStatusHistoryOrderByWithAggregationInput[]
    by: PropertyStatusHistoryScalarFieldEnum[] | PropertyStatusHistoryScalarFieldEnum
    having?: PropertyStatusHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyStatusHistoryCountAggregateInputType | true
    _min?: PropertyStatusHistoryMinAggregateInputType
    _max?: PropertyStatusHistoryMaxAggregateInputType
  }

  export type PropertyStatusHistoryGroupByOutputType = {
    id: string
    propertyId: string
    previousStatus: string | null
    newStatus: string
    changeReason: string | null
    changedById: string | null
    createdAt: Date
    _count: PropertyStatusHistoryCountAggregateOutputType | null
    _min: PropertyStatusHistoryMinAggregateOutputType | null
    _max: PropertyStatusHistoryMaxAggregateOutputType | null
  }

  type GetPropertyStatusHistoryGroupByPayload<T extends PropertyStatusHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyStatusHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyStatusHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyStatusHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyStatusHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PropertyStatusHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    changeReason?: boolean
    changedById?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    changedBy?: boolean | PropertyStatusHistory$changedByArgs<ExtArgs>
  }, ExtArgs["result"]["propertyStatusHistory"]>

  export type PropertyStatusHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    changeReason?: boolean
    changedById?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    changedBy?: boolean | PropertyStatusHistory$changedByArgs<ExtArgs>
  }, ExtArgs["result"]["propertyStatusHistory"]>

  export type PropertyStatusHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    changeReason?: boolean
    changedById?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    changedBy?: boolean | PropertyStatusHistory$changedByArgs<ExtArgs>
  }, ExtArgs["result"]["propertyStatusHistory"]>

  export type PropertyStatusHistorySelectScalar = {
    id?: boolean
    propertyId?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    changeReason?: boolean
    changedById?: boolean
    createdAt?: boolean
  }

  export type PropertyStatusHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "previousStatus" | "newStatus" | "changeReason" | "changedById" | "createdAt", ExtArgs["result"]["propertyStatusHistory"]>
  export type PropertyStatusHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    changedBy?: boolean | PropertyStatusHistory$changedByArgs<ExtArgs>
  }
  export type PropertyStatusHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    changedBy?: boolean | PropertyStatusHistory$changedByArgs<ExtArgs>
  }
  export type PropertyStatusHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    changedBy?: boolean | PropertyStatusHistory$changedByArgs<ExtArgs>
  }

  export type $PropertyStatusHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyStatusHistory"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      changedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      previousStatus: string | null
      newStatus: string
      changeReason: string | null
      changedById: string | null
      createdAt: Date
    }, ExtArgs["result"]["propertyStatusHistory"]>
    composites: {}
  }

  type PropertyStatusHistoryGetPayload<S extends boolean | null | undefined | PropertyStatusHistoryDefaultArgs> = $Result.GetResult<Prisma.$PropertyStatusHistoryPayload, S>

  type PropertyStatusHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyStatusHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyStatusHistoryCountAggregateInputType | true
    }

  export interface PropertyStatusHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyStatusHistory'], meta: { name: 'PropertyStatusHistory' } }
    /**
     * Find zero or one PropertyStatusHistory that matches the filter.
     * @param {PropertyStatusHistoryFindUniqueArgs} args - Arguments to find a PropertyStatusHistory
     * @example
     * // Get one PropertyStatusHistory
     * const propertyStatusHistory = await prisma.propertyStatusHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyStatusHistoryFindUniqueArgs>(args: SelectSubset<T, PropertyStatusHistoryFindUniqueArgs<ExtArgs>>): Prisma__PropertyStatusHistoryClient<$Result.GetResult<Prisma.$PropertyStatusHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyStatusHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyStatusHistoryFindUniqueOrThrowArgs} args - Arguments to find a PropertyStatusHistory
     * @example
     * // Get one PropertyStatusHistory
     * const propertyStatusHistory = await prisma.propertyStatusHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyStatusHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyStatusHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyStatusHistoryClient<$Result.GetResult<Prisma.$PropertyStatusHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyStatusHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStatusHistoryFindFirstArgs} args - Arguments to find a PropertyStatusHistory
     * @example
     * // Get one PropertyStatusHistory
     * const propertyStatusHistory = await prisma.propertyStatusHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyStatusHistoryFindFirstArgs>(args?: SelectSubset<T, PropertyStatusHistoryFindFirstArgs<ExtArgs>>): Prisma__PropertyStatusHistoryClient<$Result.GetResult<Prisma.$PropertyStatusHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyStatusHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStatusHistoryFindFirstOrThrowArgs} args - Arguments to find a PropertyStatusHistory
     * @example
     * // Get one PropertyStatusHistory
     * const propertyStatusHistory = await prisma.propertyStatusHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyStatusHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyStatusHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyStatusHistoryClient<$Result.GetResult<Prisma.$PropertyStatusHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyStatusHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStatusHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyStatusHistories
     * const propertyStatusHistories = await prisma.propertyStatusHistory.findMany()
     * 
     * // Get first 10 PropertyStatusHistories
     * const propertyStatusHistories = await prisma.propertyStatusHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyStatusHistoryWithIdOnly = await prisma.propertyStatusHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyStatusHistoryFindManyArgs>(args?: SelectSubset<T, PropertyStatusHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyStatusHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyStatusHistory.
     * @param {PropertyStatusHistoryCreateArgs} args - Arguments to create a PropertyStatusHistory.
     * @example
     * // Create one PropertyStatusHistory
     * const PropertyStatusHistory = await prisma.propertyStatusHistory.create({
     *   data: {
     *     // ... data to create a PropertyStatusHistory
     *   }
     * })
     * 
     */
    create<T extends PropertyStatusHistoryCreateArgs>(args: SelectSubset<T, PropertyStatusHistoryCreateArgs<ExtArgs>>): Prisma__PropertyStatusHistoryClient<$Result.GetResult<Prisma.$PropertyStatusHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyStatusHistories.
     * @param {PropertyStatusHistoryCreateManyArgs} args - Arguments to create many PropertyStatusHistories.
     * @example
     * // Create many PropertyStatusHistories
     * const propertyStatusHistory = await prisma.propertyStatusHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyStatusHistoryCreateManyArgs>(args?: SelectSubset<T, PropertyStatusHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyStatusHistories and returns the data saved in the database.
     * @param {PropertyStatusHistoryCreateManyAndReturnArgs} args - Arguments to create many PropertyStatusHistories.
     * @example
     * // Create many PropertyStatusHistories
     * const propertyStatusHistory = await prisma.propertyStatusHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyStatusHistories and only return the `id`
     * const propertyStatusHistoryWithIdOnly = await prisma.propertyStatusHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyStatusHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyStatusHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyStatusHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyStatusHistory.
     * @param {PropertyStatusHistoryDeleteArgs} args - Arguments to delete one PropertyStatusHistory.
     * @example
     * // Delete one PropertyStatusHistory
     * const PropertyStatusHistory = await prisma.propertyStatusHistory.delete({
     *   where: {
     *     // ... filter to delete one PropertyStatusHistory
     *   }
     * })
     * 
     */
    delete<T extends PropertyStatusHistoryDeleteArgs>(args: SelectSubset<T, PropertyStatusHistoryDeleteArgs<ExtArgs>>): Prisma__PropertyStatusHistoryClient<$Result.GetResult<Prisma.$PropertyStatusHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyStatusHistory.
     * @param {PropertyStatusHistoryUpdateArgs} args - Arguments to update one PropertyStatusHistory.
     * @example
     * // Update one PropertyStatusHistory
     * const propertyStatusHistory = await prisma.propertyStatusHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyStatusHistoryUpdateArgs>(args: SelectSubset<T, PropertyStatusHistoryUpdateArgs<ExtArgs>>): Prisma__PropertyStatusHistoryClient<$Result.GetResult<Prisma.$PropertyStatusHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyStatusHistories.
     * @param {PropertyStatusHistoryDeleteManyArgs} args - Arguments to filter PropertyStatusHistories to delete.
     * @example
     * // Delete a few PropertyStatusHistories
     * const { count } = await prisma.propertyStatusHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyStatusHistoryDeleteManyArgs>(args?: SelectSubset<T, PropertyStatusHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStatusHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyStatusHistories
     * const propertyStatusHistory = await prisma.propertyStatusHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyStatusHistoryUpdateManyArgs>(args: SelectSubset<T, PropertyStatusHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyStatusHistories and returns the data updated in the database.
     * @param {PropertyStatusHistoryUpdateManyAndReturnArgs} args - Arguments to update many PropertyStatusHistories.
     * @example
     * // Update many PropertyStatusHistories
     * const propertyStatusHistory = await prisma.propertyStatusHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyStatusHistories and only return the `id`
     * const propertyStatusHistoryWithIdOnly = await prisma.propertyStatusHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyStatusHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyStatusHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyStatusHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyStatusHistory.
     * @param {PropertyStatusHistoryUpsertArgs} args - Arguments to update or create a PropertyStatusHistory.
     * @example
     * // Update or create a PropertyStatusHistory
     * const propertyStatusHistory = await prisma.propertyStatusHistory.upsert({
     *   create: {
     *     // ... data to create a PropertyStatusHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyStatusHistory we want to update
     *   }
     * })
     */
    upsert<T extends PropertyStatusHistoryUpsertArgs>(args: SelectSubset<T, PropertyStatusHistoryUpsertArgs<ExtArgs>>): Prisma__PropertyStatusHistoryClient<$Result.GetResult<Prisma.$PropertyStatusHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStatusHistoryCountArgs} args - Arguments to filter PropertyStatusHistories to count.
     * @example
     * // Count the number of PropertyStatusHistories
     * const count = await prisma.propertyStatusHistory.count({
     *   where: {
     *     // ... the filter for the PropertyStatusHistories we want to count
     *   }
     * })
    **/
    count<T extends PropertyStatusHistoryCountArgs>(
      args?: Subset<T, PropertyStatusHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyStatusHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStatusHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyStatusHistoryAggregateArgs>(args: Subset<T, PropertyStatusHistoryAggregateArgs>): Prisma.PrismaPromise<GetPropertyStatusHistoryAggregateType<T>>

    /**
     * Group by PropertyStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStatusHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyStatusHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyStatusHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PropertyStatusHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyStatusHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyStatusHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyStatusHistory model
   */
  readonly fields: PropertyStatusHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyStatusHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyStatusHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    changedBy<T extends PropertyStatusHistory$changedByArgs<ExtArgs> = {}>(args?: Subset<T, PropertyStatusHistory$changedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyStatusHistory model
   */
  interface PropertyStatusHistoryFieldRefs {
    readonly id: FieldRef<"PropertyStatusHistory", 'String'>
    readonly propertyId: FieldRef<"PropertyStatusHistory", 'String'>
    readonly previousStatus: FieldRef<"PropertyStatusHistory", 'String'>
    readonly newStatus: FieldRef<"PropertyStatusHistory", 'String'>
    readonly changeReason: FieldRef<"PropertyStatusHistory", 'String'>
    readonly changedById: FieldRef<"PropertyStatusHistory", 'String'>
    readonly createdAt: FieldRef<"PropertyStatusHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyStatusHistory findUnique
   */
  export type PropertyStatusHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStatusHistory
     */
    select?: PropertyStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStatusHistory
     */
    omit?: PropertyStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyStatusHistory to fetch.
     */
    where: PropertyStatusHistoryWhereUniqueInput
  }

  /**
   * PropertyStatusHistory findUniqueOrThrow
   */
  export type PropertyStatusHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStatusHistory
     */
    select?: PropertyStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStatusHistory
     */
    omit?: PropertyStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyStatusHistory to fetch.
     */
    where: PropertyStatusHistoryWhereUniqueInput
  }

  /**
   * PropertyStatusHistory findFirst
   */
  export type PropertyStatusHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStatusHistory
     */
    select?: PropertyStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStatusHistory
     */
    omit?: PropertyStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyStatusHistory to fetch.
     */
    where?: PropertyStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyStatusHistories to fetch.
     */
    orderBy?: PropertyStatusHistoryOrderByWithRelationInput | PropertyStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyStatusHistories.
     */
    cursor?: PropertyStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyStatusHistories.
     */
    distinct?: PropertyStatusHistoryScalarFieldEnum | PropertyStatusHistoryScalarFieldEnum[]
  }

  /**
   * PropertyStatusHistory findFirstOrThrow
   */
  export type PropertyStatusHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStatusHistory
     */
    select?: PropertyStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStatusHistory
     */
    omit?: PropertyStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyStatusHistory to fetch.
     */
    where?: PropertyStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyStatusHistories to fetch.
     */
    orderBy?: PropertyStatusHistoryOrderByWithRelationInput | PropertyStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyStatusHistories.
     */
    cursor?: PropertyStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyStatusHistories.
     */
    distinct?: PropertyStatusHistoryScalarFieldEnum | PropertyStatusHistoryScalarFieldEnum[]
  }

  /**
   * PropertyStatusHistory findMany
   */
  export type PropertyStatusHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStatusHistory
     */
    select?: PropertyStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStatusHistory
     */
    omit?: PropertyStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PropertyStatusHistories to fetch.
     */
    where?: PropertyStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyStatusHistories to fetch.
     */
    orderBy?: PropertyStatusHistoryOrderByWithRelationInput | PropertyStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyStatusHistories.
     */
    cursor?: PropertyStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyStatusHistories.
     */
    skip?: number
    distinct?: PropertyStatusHistoryScalarFieldEnum | PropertyStatusHistoryScalarFieldEnum[]
  }

  /**
   * PropertyStatusHistory create
   */
  export type PropertyStatusHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStatusHistory
     */
    select?: PropertyStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStatusHistory
     */
    omit?: PropertyStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyStatusHistory.
     */
    data: XOR<PropertyStatusHistoryCreateInput, PropertyStatusHistoryUncheckedCreateInput>
  }

  /**
   * PropertyStatusHistory createMany
   */
  export type PropertyStatusHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyStatusHistories.
     */
    data: PropertyStatusHistoryCreateManyInput | PropertyStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyStatusHistory createManyAndReturn
   */
  export type PropertyStatusHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStatusHistory
     */
    select?: PropertyStatusHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStatusHistory
     */
    omit?: PropertyStatusHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyStatusHistories.
     */
    data: PropertyStatusHistoryCreateManyInput | PropertyStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStatusHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyStatusHistory update
   */
  export type PropertyStatusHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStatusHistory
     */
    select?: PropertyStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStatusHistory
     */
    omit?: PropertyStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyStatusHistory.
     */
    data: XOR<PropertyStatusHistoryUpdateInput, PropertyStatusHistoryUncheckedUpdateInput>
    /**
     * Choose, which PropertyStatusHistory to update.
     */
    where: PropertyStatusHistoryWhereUniqueInput
  }

  /**
   * PropertyStatusHistory updateMany
   */
  export type PropertyStatusHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyStatusHistories.
     */
    data: XOR<PropertyStatusHistoryUpdateManyMutationInput, PropertyStatusHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PropertyStatusHistories to update
     */
    where?: PropertyStatusHistoryWhereInput
    /**
     * Limit how many PropertyStatusHistories to update.
     */
    limit?: number
  }

  /**
   * PropertyStatusHistory updateManyAndReturn
   */
  export type PropertyStatusHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStatusHistory
     */
    select?: PropertyStatusHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStatusHistory
     */
    omit?: PropertyStatusHistoryOmit<ExtArgs> | null
    /**
     * The data used to update PropertyStatusHistories.
     */
    data: XOR<PropertyStatusHistoryUpdateManyMutationInput, PropertyStatusHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PropertyStatusHistories to update
     */
    where?: PropertyStatusHistoryWhereInput
    /**
     * Limit how many PropertyStatusHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStatusHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyStatusHistory upsert
   */
  export type PropertyStatusHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStatusHistory
     */
    select?: PropertyStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStatusHistory
     */
    omit?: PropertyStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStatusHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyStatusHistory to update in case it exists.
     */
    where: PropertyStatusHistoryWhereUniqueInput
    /**
     * In case the PropertyStatusHistory found by the `where` argument doesn't exist, create a new PropertyStatusHistory with this data.
     */
    create: XOR<PropertyStatusHistoryCreateInput, PropertyStatusHistoryUncheckedCreateInput>
    /**
     * In case the PropertyStatusHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyStatusHistoryUpdateInput, PropertyStatusHistoryUncheckedUpdateInput>
  }

  /**
   * PropertyStatusHistory delete
   */
  export type PropertyStatusHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStatusHistory
     */
    select?: PropertyStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStatusHistory
     */
    omit?: PropertyStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter which PropertyStatusHistory to delete.
     */
    where: PropertyStatusHistoryWhereUniqueInput
  }

  /**
   * PropertyStatusHistory deleteMany
   */
  export type PropertyStatusHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyStatusHistories to delete
     */
    where?: PropertyStatusHistoryWhereInput
    /**
     * Limit how many PropertyStatusHistories to delete.
     */
    limit?: number
  }

  /**
   * PropertyStatusHistory.changedBy
   */
  export type PropertyStatusHistory$changedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PropertyStatusHistory without action
   */
  export type PropertyStatusHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStatusHistory
     */
    select?: PropertyStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStatusHistory
     */
    omit?: PropertyStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStatusHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PropertyImage
   */

  export type AggregatePropertyImage = {
    _count: PropertyImageCountAggregateOutputType | null
    _avg: PropertyImageAvgAggregateOutputType | null
    _sum: PropertyImageSumAggregateOutputType | null
    _min: PropertyImageMinAggregateOutputType | null
    _max: PropertyImageMaxAggregateOutputType | null
  }

  export type PropertyImageAvgAggregateOutputType = {
    displayOrder: number | null
    width: number | null
    height: number | null
  }

  export type PropertyImageSumAggregateOutputType = {
    displayOrder: number | null
    width: number | null
    height: number | null
  }

  export type PropertyImageMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    fileBoxId: string | null
    url: string | null
    thumbnailUrl: string | null
    caption: string | null
    imageType: $Enums.ImageType | null
    displayOrder: number | null
    isMain: boolean | null
    width: number | null
    height: number | null
    createdAt: Date | null
  }

  export type PropertyImageMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    fileBoxId: string | null
    url: string | null
    thumbnailUrl: string | null
    caption: string | null
    imageType: $Enums.ImageType | null
    displayOrder: number | null
    isMain: boolean | null
    width: number | null
    height: number | null
    createdAt: Date | null
  }

  export type PropertyImageCountAggregateOutputType = {
    id: number
    propertyId: number
    fileBoxId: number
    url: number
    thumbnailUrl: number
    caption: number
    imageType: number
    displayOrder: number
    isMain: number
    width: number
    height: number
    createdAt: number
    _all: number
  }


  export type PropertyImageAvgAggregateInputType = {
    displayOrder?: true
    width?: true
    height?: true
  }

  export type PropertyImageSumAggregateInputType = {
    displayOrder?: true
    width?: true
    height?: true
  }

  export type PropertyImageMinAggregateInputType = {
    id?: true
    propertyId?: true
    fileBoxId?: true
    url?: true
    thumbnailUrl?: true
    caption?: true
    imageType?: true
    displayOrder?: true
    isMain?: true
    width?: true
    height?: true
    createdAt?: true
  }

  export type PropertyImageMaxAggregateInputType = {
    id?: true
    propertyId?: true
    fileBoxId?: true
    url?: true
    thumbnailUrl?: true
    caption?: true
    imageType?: true
    displayOrder?: true
    isMain?: true
    width?: true
    height?: true
    createdAt?: true
  }

  export type PropertyImageCountAggregateInputType = {
    id?: true
    propertyId?: true
    fileBoxId?: true
    url?: true
    thumbnailUrl?: true
    caption?: true
    imageType?: true
    displayOrder?: true
    isMain?: true
    width?: true
    height?: true
    createdAt?: true
    _all?: true
  }

  export type PropertyImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyImage to aggregate.
     */
    where?: PropertyImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyImages to fetch.
     */
    orderBy?: PropertyImageOrderByWithRelationInput | PropertyImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyImages
    **/
    _count?: true | PropertyImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyImageMaxAggregateInputType
  }

  export type GetPropertyImageAggregateType<T extends PropertyImageAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyImage[P]>
      : GetScalarType<T[P], AggregatePropertyImage[P]>
  }




  export type PropertyImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyImageWhereInput
    orderBy?: PropertyImageOrderByWithAggregationInput | PropertyImageOrderByWithAggregationInput[]
    by: PropertyImageScalarFieldEnum[] | PropertyImageScalarFieldEnum
    having?: PropertyImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyImageCountAggregateInputType | true
    _avg?: PropertyImageAvgAggregateInputType
    _sum?: PropertyImageSumAggregateInputType
    _min?: PropertyImageMinAggregateInputType
    _max?: PropertyImageMaxAggregateInputType
  }

  export type PropertyImageGroupByOutputType = {
    id: string
    propertyId: string
    fileBoxId: string | null
    url: string
    thumbnailUrl: string | null
    caption: string | null
    imageType: $Enums.ImageType
    displayOrder: number
    isMain: boolean
    width: number | null
    height: number | null
    createdAt: Date
    _count: PropertyImageCountAggregateOutputType | null
    _avg: PropertyImageAvgAggregateOutputType | null
    _sum: PropertyImageSumAggregateOutputType | null
    _min: PropertyImageMinAggregateOutputType | null
    _max: PropertyImageMaxAggregateOutputType | null
  }

  type GetPropertyImageGroupByPayload<T extends PropertyImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyImageGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyImageGroupByOutputType[P]>
        }
      >
    >


  export type PropertyImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    fileBoxId?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    caption?: boolean
    imageType?: boolean
    displayOrder?: boolean
    isMain?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    fileBox?: boolean | PropertyImage$fileBoxArgs<ExtArgs>
  }, ExtArgs["result"]["propertyImage"]>

  export type PropertyImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    fileBoxId?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    caption?: boolean
    imageType?: boolean
    displayOrder?: boolean
    isMain?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    fileBox?: boolean | PropertyImage$fileBoxArgs<ExtArgs>
  }, ExtArgs["result"]["propertyImage"]>

  export type PropertyImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    fileBoxId?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    caption?: boolean
    imageType?: boolean
    displayOrder?: boolean
    isMain?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    fileBox?: boolean | PropertyImage$fileBoxArgs<ExtArgs>
  }, ExtArgs["result"]["propertyImage"]>

  export type PropertyImageSelectScalar = {
    id?: boolean
    propertyId?: boolean
    fileBoxId?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    caption?: boolean
    imageType?: boolean
    displayOrder?: boolean
    isMain?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
  }

  export type PropertyImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "fileBoxId" | "url" | "thumbnailUrl" | "caption" | "imageType" | "displayOrder" | "isMain" | "width" | "height" | "createdAt", ExtArgs["result"]["propertyImage"]>
  export type PropertyImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    fileBox?: boolean | PropertyImage$fileBoxArgs<ExtArgs>
  }
  export type PropertyImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    fileBox?: boolean | PropertyImage$fileBoxArgs<ExtArgs>
  }
  export type PropertyImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    fileBox?: boolean | PropertyImage$fileBoxArgs<ExtArgs>
  }

  export type $PropertyImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyImage"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      fileBox: Prisma.$FileBoxPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      fileBoxId: string | null
      url: string
      thumbnailUrl: string | null
      caption: string | null
      imageType: $Enums.ImageType
      displayOrder: number
      isMain: boolean
      width: number | null
      height: number | null
      createdAt: Date
    }, ExtArgs["result"]["propertyImage"]>
    composites: {}
  }

  type PropertyImageGetPayload<S extends boolean | null | undefined | PropertyImageDefaultArgs> = $Result.GetResult<Prisma.$PropertyImagePayload, S>

  type PropertyImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyImageCountAggregateInputType | true
    }

  export interface PropertyImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyImage'], meta: { name: 'PropertyImage' } }
    /**
     * Find zero or one PropertyImage that matches the filter.
     * @param {PropertyImageFindUniqueArgs} args - Arguments to find a PropertyImage
     * @example
     * // Get one PropertyImage
     * const propertyImage = await prisma.propertyImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyImageFindUniqueArgs>(args: SelectSubset<T, PropertyImageFindUniqueArgs<ExtArgs>>): Prisma__PropertyImageClient<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyImageFindUniqueOrThrowArgs} args - Arguments to find a PropertyImage
     * @example
     * // Get one PropertyImage
     * const propertyImage = await prisma.propertyImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyImageFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyImageClient<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyImageFindFirstArgs} args - Arguments to find a PropertyImage
     * @example
     * // Get one PropertyImage
     * const propertyImage = await prisma.propertyImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyImageFindFirstArgs>(args?: SelectSubset<T, PropertyImageFindFirstArgs<ExtArgs>>): Prisma__PropertyImageClient<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyImageFindFirstOrThrowArgs} args - Arguments to find a PropertyImage
     * @example
     * // Get one PropertyImage
     * const propertyImage = await prisma.propertyImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyImageFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyImageClient<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyImages
     * const propertyImages = await prisma.propertyImage.findMany()
     * 
     * // Get first 10 PropertyImages
     * const propertyImages = await prisma.propertyImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyImageWithIdOnly = await prisma.propertyImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyImageFindManyArgs>(args?: SelectSubset<T, PropertyImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyImage.
     * @param {PropertyImageCreateArgs} args - Arguments to create a PropertyImage.
     * @example
     * // Create one PropertyImage
     * const PropertyImage = await prisma.propertyImage.create({
     *   data: {
     *     // ... data to create a PropertyImage
     *   }
     * })
     * 
     */
    create<T extends PropertyImageCreateArgs>(args: SelectSubset<T, PropertyImageCreateArgs<ExtArgs>>): Prisma__PropertyImageClient<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyImages.
     * @param {PropertyImageCreateManyArgs} args - Arguments to create many PropertyImages.
     * @example
     * // Create many PropertyImages
     * const propertyImage = await prisma.propertyImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyImageCreateManyArgs>(args?: SelectSubset<T, PropertyImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyImages and returns the data saved in the database.
     * @param {PropertyImageCreateManyAndReturnArgs} args - Arguments to create many PropertyImages.
     * @example
     * // Create many PropertyImages
     * const propertyImage = await prisma.propertyImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyImages and only return the `id`
     * const propertyImageWithIdOnly = await prisma.propertyImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyImageCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyImage.
     * @param {PropertyImageDeleteArgs} args - Arguments to delete one PropertyImage.
     * @example
     * // Delete one PropertyImage
     * const PropertyImage = await prisma.propertyImage.delete({
     *   where: {
     *     // ... filter to delete one PropertyImage
     *   }
     * })
     * 
     */
    delete<T extends PropertyImageDeleteArgs>(args: SelectSubset<T, PropertyImageDeleteArgs<ExtArgs>>): Prisma__PropertyImageClient<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyImage.
     * @param {PropertyImageUpdateArgs} args - Arguments to update one PropertyImage.
     * @example
     * // Update one PropertyImage
     * const propertyImage = await prisma.propertyImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyImageUpdateArgs>(args: SelectSubset<T, PropertyImageUpdateArgs<ExtArgs>>): Prisma__PropertyImageClient<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyImages.
     * @param {PropertyImageDeleteManyArgs} args - Arguments to filter PropertyImages to delete.
     * @example
     * // Delete a few PropertyImages
     * const { count } = await prisma.propertyImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyImageDeleteManyArgs>(args?: SelectSubset<T, PropertyImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyImages
     * const propertyImage = await prisma.propertyImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyImageUpdateManyArgs>(args: SelectSubset<T, PropertyImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyImages and returns the data updated in the database.
     * @param {PropertyImageUpdateManyAndReturnArgs} args - Arguments to update many PropertyImages.
     * @example
     * // Update many PropertyImages
     * const propertyImage = await prisma.propertyImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyImages and only return the `id`
     * const propertyImageWithIdOnly = await prisma.propertyImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyImageUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyImage.
     * @param {PropertyImageUpsertArgs} args - Arguments to update or create a PropertyImage.
     * @example
     * // Update or create a PropertyImage
     * const propertyImage = await prisma.propertyImage.upsert({
     *   create: {
     *     // ... data to create a PropertyImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyImage we want to update
     *   }
     * })
     */
    upsert<T extends PropertyImageUpsertArgs>(args: SelectSubset<T, PropertyImageUpsertArgs<ExtArgs>>): Prisma__PropertyImageClient<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyImageCountArgs} args - Arguments to filter PropertyImages to count.
     * @example
     * // Count the number of PropertyImages
     * const count = await prisma.propertyImage.count({
     *   where: {
     *     // ... the filter for the PropertyImages we want to count
     *   }
     * })
    **/
    count<T extends PropertyImageCountArgs>(
      args?: Subset<T, PropertyImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyImageAggregateArgs>(args: Subset<T, PropertyImageAggregateArgs>): Prisma.PrismaPromise<GetPropertyImageAggregateType<T>>

    /**
     * Group by PropertyImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyImageGroupByArgs['orderBy'] }
        : { orderBy?: PropertyImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyImage model
   */
  readonly fields: PropertyImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fileBox<T extends PropertyImage$fileBoxArgs<ExtArgs> = {}>(args?: Subset<T, PropertyImage$fileBoxArgs<ExtArgs>>): Prisma__FileBoxClient<$Result.GetResult<Prisma.$FileBoxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyImage model
   */
  interface PropertyImageFieldRefs {
    readonly id: FieldRef<"PropertyImage", 'String'>
    readonly propertyId: FieldRef<"PropertyImage", 'String'>
    readonly fileBoxId: FieldRef<"PropertyImage", 'String'>
    readonly url: FieldRef<"PropertyImage", 'String'>
    readonly thumbnailUrl: FieldRef<"PropertyImage", 'String'>
    readonly caption: FieldRef<"PropertyImage", 'String'>
    readonly imageType: FieldRef<"PropertyImage", 'ImageType'>
    readonly displayOrder: FieldRef<"PropertyImage", 'Int'>
    readonly isMain: FieldRef<"PropertyImage", 'Boolean'>
    readonly width: FieldRef<"PropertyImage", 'Int'>
    readonly height: FieldRef<"PropertyImage", 'Int'>
    readonly createdAt: FieldRef<"PropertyImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyImage findUnique
   */
  export type PropertyImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    /**
     * Filter, which PropertyImage to fetch.
     */
    where: PropertyImageWhereUniqueInput
  }

  /**
   * PropertyImage findUniqueOrThrow
   */
  export type PropertyImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    /**
     * Filter, which PropertyImage to fetch.
     */
    where: PropertyImageWhereUniqueInput
  }

  /**
   * PropertyImage findFirst
   */
  export type PropertyImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    /**
     * Filter, which PropertyImage to fetch.
     */
    where?: PropertyImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyImages to fetch.
     */
    orderBy?: PropertyImageOrderByWithRelationInput | PropertyImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyImages.
     */
    cursor?: PropertyImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyImages.
     */
    distinct?: PropertyImageScalarFieldEnum | PropertyImageScalarFieldEnum[]
  }

  /**
   * PropertyImage findFirstOrThrow
   */
  export type PropertyImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    /**
     * Filter, which PropertyImage to fetch.
     */
    where?: PropertyImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyImages to fetch.
     */
    orderBy?: PropertyImageOrderByWithRelationInput | PropertyImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyImages.
     */
    cursor?: PropertyImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyImages.
     */
    distinct?: PropertyImageScalarFieldEnum | PropertyImageScalarFieldEnum[]
  }

  /**
   * PropertyImage findMany
   */
  export type PropertyImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    /**
     * Filter, which PropertyImages to fetch.
     */
    where?: PropertyImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyImages to fetch.
     */
    orderBy?: PropertyImageOrderByWithRelationInput | PropertyImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyImages.
     */
    cursor?: PropertyImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyImages.
     */
    skip?: number
    distinct?: PropertyImageScalarFieldEnum | PropertyImageScalarFieldEnum[]
  }

  /**
   * PropertyImage create
   */
  export type PropertyImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyImage.
     */
    data: XOR<PropertyImageCreateInput, PropertyImageUncheckedCreateInput>
  }

  /**
   * PropertyImage createMany
   */
  export type PropertyImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyImages.
     */
    data: PropertyImageCreateManyInput | PropertyImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyImage createManyAndReturn
   */
  export type PropertyImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyImages.
     */
    data: PropertyImageCreateManyInput | PropertyImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyImage update
   */
  export type PropertyImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyImage.
     */
    data: XOR<PropertyImageUpdateInput, PropertyImageUncheckedUpdateInput>
    /**
     * Choose, which PropertyImage to update.
     */
    where: PropertyImageWhereUniqueInput
  }

  /**
   * PropertyImage updateMany
   */
  export type PropertyImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyImages.
     */
    data: XOR<PropertyImageUpdateManyMutationInput, PropertyImageUncheckedUpdateManyInput>
    /**
     * Filter which PropertyImages to update
     */
    where?: PropertyImageWhereInput
    /**
     * Limit how many PropertyImages to update.
     */
    limit?: number
  }

  /**
   * PropertyImage updateManyAndReturn
   */
  export type PropertyImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * The data used to update PropertyImages.
     */
    data: XOR<PropertyImageUpdateManyMutationInput, PropertyImageUncheckedUpdateManyInput>
    /**
     * Filter which PropertyImages to update
     */
    where?: PropertyImageWhereInput
    /**
     * Limit how many PropertyImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyImage upsert
   */
  export type PropertyImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyImage to update in case it exists.
     */
    where: PropertyImageWhereUniqueInput
    /**
     * In case the PropertyImage found by the `where` argument doesn't exist, create a new PropertyImage with this data.
     */
    create: XOR<PropertyImageCreateInput, PropertyImageUncheckedCreateInput>
    /**
     * In case the PropertyImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyImageUpdateInput, PropertyImageUncheckedUpdateInput>
  }

  /**
   * PropertyImage delete
   */
  export type PropertyImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    /**
     * Filter which PropertyImage to delete.
     */
    where: PropertyImageWhereUniqueInput
  }

  /**
   * PropertyImage deleteMany
   */
  export type PropertyImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyImages to delete
     */
    where?: PropertyImageWhereInput
    /**
     * Limit how many PropertyImages to delete.
     */
    limit?: number
  }

  /**
   * PropertyImage.fileBox
   */
  export type PropertyImage$fileBoxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileBox
     */
    select?: FileBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileBox
     */
    omit?: FileBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileBoxInclude<ExtArgs> | null
    where?: FileBoxWhereInput
  }

  /**
   * PropertyImage without action
   */
  export type PropertyImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
  }


  /**
   * Model PropertyFeature
   */

  export type AggregatePropertyFeature = {
    _count: PropertyFeatureCountAggregateOutputType | null
    _min: PropertyFeatureMinAggregateOutputType | null
    _max: PropertyFeatureMaxAggregateOutputType | null
  }

  export type PropertyFeatureMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    featureId: string | null
  }

  export type PropertyFeatureMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    featureId: string | null
  }

  export type PropertyFeatureCountAggregateOutputType = {
    id: number
    propertyId: number
    featureId: number
    _all: number
  }


  export type PropertyFeatureMinAggregateInputType = {
    id?: true
    propertyId?: true
    featureId?: true
  }

  export type PropertyFeatureMaxAggregateInputType = {
    id?: true
    propertyId?: true
    featureId?: true
  }

  export type PropertyFeatureCountAggregateInputType = {
    id?: true
    propertyId?: true
    featureId?: true
    _all?: true
  }

  export type PropertyFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyFeature to aggregate.
     */
    where?: PropertyFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyFeatures to fetch.
     */
    orderBy?: PropertyFeatureOrderByWithRelationInput | PropertyFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyFeatures
    **/
    _count?: true | PropertyFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyFeatureMaxAggregateInputType
  }

  export type GetPropertyFeatureAggregateType<T extends PropertyFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyFeature[P]>
      : GetScalarType<T[P], AggregatePropertyFeature[P]>
  }




  export type PropertyFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyFeatureWhereInput
    orderBy?: PropertyFeatureOrderByWithAggregationInput | PropertyFeatureOrderByWithAggregationInput[]
    by: PropertyFeatureScalarFieldEnum[] | PropertyFeatureScalarFieldEnum
    having?: PropertyFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyFeatureCountAggregateInputType | true
    _min?: PropertyFeatureMinAggregateInputType
    _max?: PropertyFeatureMaxAggregateInputType
  }

  export type PropertyFeatureGroupByOutputType = {
    id: string
    propertyId: string
    featureId: string
    _count: PropertyFeatureCountAggregateOutputType | null
    _min: PropertyFeatureMinAggregateOutputType | null
    _max: PropertyFeatureMaxAggregateOutputType | null
  }

  type GetPropertyFeatureGroupByPayload<T extends PropertyFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyFeatureGroupByOutputType[P]>
        }
      >
    >


  export type PropertyFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    featureId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    feature?: boolean | FeatureMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyFeature"]>

  export type PropertyFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    featureId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    feature?: boolean | FeatureMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyFeature"]>

  export type PropertyFeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    featureId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    feature?: boolean | FeatureMasterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyFeature"]>

  export type PropertyFeatureSelectScalar = {
    id?: boolean
    propertyId?: boolean
    featureId?: boolean
  }

  export type PropertyFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "featureId", ExtArgs["result"]["propertyFeature"]>
  export type PropertyFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    feature?: boolean | FeatureMasterDefaultArgs<ExtArgs>
  }
  export type PropertyFeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    feature?: boolean | FeatureMasterDefaultArgs<ExtArgs>
  }
  export type PropertyFeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    feature?: boolean | FeatureMasterDefaultArgs<ExtArgs>
  }

  export type $PropertyFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyFeature"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      feature: Prisma.$FeatureMasterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      featureId: string
    }, ExtArgs["result"]["propertyFeature"]>
    composites: {}
  }

  type PropertyFeatureGetPayload<S extends boolean | null | undefined | PropertyFeatureDefaultArgs> = $Result.GetResult<Prisma.$PropertyFeaturePayload, S>

  type PropertyFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyFeatureCountAggregateInputType | true
    }

  export interface PropertyFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyFeature'], meta: { name: 'PropertyFeature' } }
    /**
     * Find zero or one PropertyFeature that matches the filter.
     * @param {PropertyFeatureFindUniqueArgs} args - Arguments to find a PropertyFeature
     * @example
     * // Get one PropertyFeature
     * const propertyFeature = await prisma.propertyFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFeatureFindUniqueArgs>(args: SelectSubset<T, PropertyFeatureFindUniqueArgs<ExtArgs>>): Prisma__PropertyFeatureClient<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFeatureFindUniqueOrThrowArgs} args - Arguments to find a PropertyFeature
     * @example
     * // Get one PropertyFeature
     * const propertyFeature = await prisma.propertyFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyFeatureClient<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFeatureFindFirstArgs} args - Arguments to find a PropertyFeature
     * @example
     * // Get one PropertyFeature
     * const propertyFeature = await prisma.propertyFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFeatureFindFirstArgs>(args?: SelectSubset<T, PropertyFeatureFindFirstArgs<ExtArgs>>): Prisma__PropertyFeatureClient<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFeatureFindFirstOrThrowArgs} args - Arguments to find a PropertyFeature
     * @example
     * // Get one PropertyFeature
     * const propertyFeature = await prisma.propertyFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyFeatureClient<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyFeatures
     * const propertyFeatures = await prisma.propertyFeature.findMany()
     * 
     * // Get first 10 PropertyFeatures
     * const propertyFeatures = await prisma.propertyFeature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyFeatureWithIdOnly = await prisma.propertyFeature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFeatureFindManyArgs>(args?: SelectSubset<T, PropertyFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyFeature.
     * @param {PropertyFeatureCreateArgs} args - Arguments to create a PropertyFeature.
     * @example
     * // Create one PropertyFeature
     * const PropertyFeature = await prisma.propertyFeature.create({
     *   data: {
     *     // ... data to create a PropertyFeature
     *   }
     * })
     * 
     */
    create<T extends PropertyFeatureCreateArgs>(args: SelectSubset<T, PropertyFeatureCreateArgs<ExtArgs>>): Prisma__PropertyFeatureClient<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyFeatures.
     * @param {PropertyFeatureCreateManyArgs} args - Arguments to create many PropertyFeatures.
     * @example
     * // Create many PropertyFeatures
     * const propertyFeature = await prisma.propertyFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyFeatureCreateManyArgs>(args?: SelectSubset<T, PropertyFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyFeatures and returns the data saved in the database.
     * @param {PropertyFeatureCreateManyAndReturnArgs} args - Arguments to create many PropertyFeatures.
     * @example
     * // Create many PropertyFeatures
     * const propertyFeature = await prisma.propertyFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyFeatures and only return the `id`
     * const propertyFeatureWithIdOnly = await prisma.propertyFeature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyFeature.
     * @param {PropertyFeatureDeleteArgs} args - Arguments to delete one PropertyFeature.
     * @example
     * // Delete one PropertyFeature
     * const PropertyFeature = await prisma.propertyFeature.delete({
     *   where: {
     *     // ... filter to delete one PropertyFeature
     *   }
     * })
     * 
     */
    delete<T extends PropertyFeatureDeleteArgs>(args: SelectSubset<T, PropertyFeatureDeleteArgs<ExtArgs>>): Prisma__PropertyFeatureClient<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyFeature.
     * @param {PropertyFeatureUpdateArgs} args - Arguments to update one PropertyFeature.
     * @example
     * // Update one PropertyFeature
     * const propertyFeature = await prisma.propertyFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyFeatureUpdateArgs>(args: SelectSubset<T, PropertyFeatureUpdateArgs<ExtArgs>>): Prisma__PropertyFeatureClient<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyFeatures.
     * @param {PropertyFeatureDeleteManyArgs} args - Arguments to filter PropertyFeatures to delete.
     * @example
     * // Delete a few PropertyFeatures
     * const { count } = await prisma.propertyFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyFeatureDeleteManyArgs>(args?: SelectSubset<T, PropertyFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyFeatures
     * const propertyFeature = await prisma.propertyFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyFeatureUpdateManyArgs>(args: SelectSubset<T, PropertyFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyFeatures and returns the data updated in the database.
     * @param {PropertyFeatureUpdateManyAndReturnArgs} args - Arguments to update many PropertyFeatures.
     * @example
     * // Update many PropertyFeatures
     * const propertyFeature = await prisma.propertyFeature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyFeatures and only return the `id`
     * const propertyFeatureWithIdOnly = await prisma.propertyFeature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyFeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyFeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyFeature.
     * @param {PropertyFeatureUpsertArgs} args - Arguments to update or create a PropertyFeature.
     * @example
     * // Update or create a PropertyFeature
     * const propertyFeature = await prisma.propertyFeature.upsert({
     *   create: {
     *     // ... data to create a PropertyFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyFeature we want to update
     *   }
     * })
     */
    upsert<T extends PropertyFeatureUpsertArgs>(args: SelectSubset<T, PropertyFeatureUpsertArgs<ExtArgs>>): Prisma__PropertyFeatureClient<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFeatureCountArgs} args - Arguments to filter PropertyFeatures to count.
     * @example
     * // Count the number of PropertyFeatures
     * const count = await prisma.propertyFeature.count({
     *   where: {
     *     // ... the filter for the PropertyFeatures we want to count
     *   }
     * })
    **/
    count<T extends PropertyFeatureCountArgs>(
      args?: Subset<T, PropertyFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyFeatureAggregateArgs>(args: Subset<T, PropertyFeatureAggregateArgs>): Prisma.PrismaPromise<GetPropertyFeatureAggregateType<T>>

    /**
     * Group by PropertyFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyFeatureGroupByArgs['orderBy'] }
        : { orderBy?: PropertyFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyFeature model
   */
  readonly fields: PropertyFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    feature<T extends FeatureMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatureMasterDefaultArgs<ExtArgs>>): Prisma__FeatureMasterClient<$Result.GetResult<Prisma.$FeatureMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyFeature model
   */
  interface PropertyFeatureFieldRefs {
    readonly id: FieldRef<"PropertyFeature", 'String'>
    readonly propertyId: FieldRef<"PropertyFeature", 'String'>
    readonly featureId: FieldRef<"PropertyFeature", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PropertyFeature findUnique
   */
  export type PropertyFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PropertyFeature to fetch.
     */
    where: PropertyFeatureWhereUniqueInput
  }

  /**
   * PropertyFeature findUniqueOrThrow
   */
  export type PropertyFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PropertyFeature to fetch.
     */
    where: PropertyFeatureWhereUniqueInput
  }

  /**
   * PropertyFeature findFirst
   */
  export type PropertyFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PropertyFeature to fetch.
     */
    where?: PropertyFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyFeatures to fetch.
     */
    orderBy?: PropertyFeatureOrderByWithRelationInput | PropertyFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyFeatures.
     */
    cursor?: PropertyFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyFeatures.
     */
    distinct?: PropertyFeatureScalarFieldEnum | PropertyFeatureScalarFieldEnum[]
  }

  /**
   * PropertyFeature findFirstOrThrow
   */
  export type PropertyFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PropertyFeature to fetch.
     */
    where?: PropertyFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyFeatures to fetch.
     */
    orderBy?: PropertyFeatureOrderByWithRelationInput | PropertyFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyFeatures.
     */
    cursor?: PropertyFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyFeatures.
     */
    distinct?: PropertyFeatureScalarFieldEnum | PropertyFeatureScalarFieldEnum[]
  }

  /**
   * PropertyFeature findMany
   */
  export type PropertyFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PropertyFeatures to fetch.
     */
    where?: PropertyFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyFeatures to fetch.
     */
    orderBy?: PropertyFeatureOrderByWithRelationInput | PropertyFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyFeatures.
     */
    cursor?: PropertyFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyFeatures.
     */
    skip?: number
    distinct?: PropertyFeatureScalarFieldEnum | PropertyFeatureScalarFieldEnum[]
  }

  /**
   * PropertyFeature create
   */
  export type PropertyFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyFeature.
     */
    data: XOR<PropertyFeatureCreateInput, PropertyFeatureUncheckedCreateInput>
  }

  /**
   * PropertyFeature createMany
   */
  export type PropertyFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyFeatures.
     */
    data: PropertyFeatureCreateManyInput | PropertyFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyFeature createManyAndReturn
   */
  export type PropertyFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyFeatures.
     */
    data: PropertyFeatureCreateManyInput | PropertyFeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyFeature update
   */
  export type PropertyFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyFeature.
     */
    data: XOR<PropertyFeatureUpdateInput, PropertyFeatureUncheckedUpdateInput>
    /**
     * Choose, which PropertyFeature to update.
     */
    where: PropertyFeatureWhereUniqueInput
  }

  /**
   * PropertyFeature updateMany
   */
  export type PropertyFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyFeatures.
     */
    data: XOR<PropertyFeatureUpdateManyMutationInput, PropertyFeatureUncheckedUpdateManyInput>
    /**
     * Filter which PropertyFeatures to update
     */
    where?: PropertyFeatureWhereInput
    /**
     * Limit how many PropertyFeatures to update.
     */
    limit?: number
  }

  /**
   * PropertyFeature updateManyAndReturn
   */
  export type PropertyFeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * The data used to update PropertyFeatures.
     */
    data: XOR<PropertyFeatureUpdateManyMutationInput, PropertyFeatureUncheckedUpdateManyInput>
    /**
     * Filter which PropertyFeatures to update
     */
    where?: PropertyFeatureWhereInput
    /**
     * Limit how many PropertyFeatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyFeature upsert
   */
  export type PropertyFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyFeature to update in case it exists.
     */
    where: PropertyFeatureWhereUniqueInput
    /**
     * In case the PropertyFeature found by the `where` argument doesn't exist, create a new PropertyFeature with this data.
     */
    create: XOR<PropertyFeatureCreateInput, PropertyFeatureUncheckedCreateInput>
    /**
     * In case the PropertyFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyFeatureUpdateInput, PropertyFeatureUncheckedUpdateInput>
  }

  /**
   * PropertyFeature delete
   */
  export type PropertyFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    /**
     * Filter which PropertyFeature to delete.
     */
    where: PropertyFeatureWhereUniqueInput
  }

  /**
   * PropertyFeature deleteMany
   */
  export type PropertyFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyFeatures to delete
     */
    where?: PropertyFeatureWhereInput
    /**
     * Limit how many PropertyFeatures to delete.
     */
    limit?: number
  }

  /**
   * PropertyFeature without action
   */
  export type PropertyFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
  }


  /**
   * Model PropertyStation
   */

  export type AggregatePropertyStation = {
    _count: PropertyStationCountAggregateOutputType | null
    _avg: PropertyStationAvgAggregateOutputType | null
    _sum: PropertyStationSumAggregateOutputType | null
    _min: PropertyStationMinAggregateOutputType | null
    _max: PropertyStationMaxAggregateOutputType | null
  }

  export type PropertyStationAvgAggregateOutputType = {
    walkMinutes: number | null
    busMinutes: number | null
  }

  export type PropertyStationSumAggregateOutputType = {
    walkMinutes: number | null
    busMinutes: number | null
  }

  export type PropertyStationMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    stationId: string | null
    walkMinutes: number | null
    busMinutes: number | null
    busStopName: string | null
    isPrimary: boolean | null
  }

  export type PropertyStationMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    stationId: string | null
    walkMinutes: number | null
    busMinutes: number | null
    busStopName: string | null
    isPrimary: boolean | null
  }

  export type PropertyStationCountAggregateOutputType = {
    id: number
    propertyId: number
    stationId: number
    walkMinutes: number
    busMinutes: number
    busStopName: number
    isPrimary: number
    _all: number
  }


  export type PropertyStationAvgAggregateInputType = {
    walkMinutes?: true
    busMinutes?: true
  }

  export type PropertyStationSumAggregateInputType = {
    walkMinutes?: true
    busMinutes?: true
  }

  export type PropertyStationMinAggregateInputType = {
    id?: true
    propertyId?: true
    stationId?: true
    walkMinutes?: true
    busMinutes?: true
    busStopName?: true
    isPrimary?: true
  }

  export type PropertyStationMaxAggregateInputType = {
    id?: true
    propertyId?: true
    stationId?: true
    walkMinutes?: true
    busMinutes?: true
    busStopName?: true
    isPrimary?: true
  }

  export type PropertyStationCountAggregateInputType = {
    id?: true
    propertyId?: true
    stationId?: true
    walkMinutes?: true
    busMinutes?: true
    busStopName?: true
    isPrimary?: true
    _all?: true
  }

  export type PropertyStationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyStation to aggregate.
     */
    where?: PropertyStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyStations to fetch.
     */
    orderBy?: PropertyStationOrderByWithRelationInput | PropertyStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyStations
    **/
    _count?: true | PropertyStationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyStationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyStationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyStationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyStationMaxAggregateInputType
  }

  export type GetPropertyStationAggregateType<T extends PropertyStationAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyStation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyStation[P]>
      : GetScalarType<T[P], AggregatePropertyStation[P]>
  }




  export type PropertyStationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyStationWhereInput
    orderBy?: PropertyStationOrderByWithAggregationInput | PropertyStationOrderByWithAggregationInput[]
    by: PropertyStationScalarFieldEnum[] | PropertyStationScalarFieldEnum
    having?: PropertyStationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyStationCountAggregateInputType | true
    _avg?: PropertyStationAvgAggregateInputType
    _sum?: PropertyStationSumAggregateInputType
    _min?: PropertyStationMinAggregateInputType
    _max?: PropertyStationMaxAggregateInputType
  }

  export type PropertyStationGroupByOutputType = {
    id: string
    propertyId: string
    stationId: string
    walkMinutes: number | null
    busMinutes: number | null
    busStopName: string | null
    isPrimary: boolean
    _count: PropertyStationCountAggregateOutputType | null
    _avg: PropertyStationAvgAggregateOutputType | null
    _sum: PropertyStationSumAggregateOutputType | null
    _min: PropertyStationMinAggregateOutputType | null
    _max: PropertyStationMaxAggregateOutputType | null
  }

  type GetPropertyStationGroupByPayload<T extends PropertyStationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyStationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyStationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyStationGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyStationGroupByOutputType[P]>
        }
      >
    >


  export type PropertyStationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    stationId?: boolean
    walkMinutes?: boolean
    busMinutes?: boolean
    busStopName?: boolean
    isPrimary?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    station?: boolean | StationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyStation"]>

  export type PropertyStationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    stationId?: boolean
    walkMinutes?: boolean
    busMinutes?: boolean
    busStopName?: boolean
    isPrimary?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    station?: boolean | StationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyStation"]>

  export type PropertyStationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    stationId?: boolean
    walkMinutes?: boolean
    busMinutes?: boolean
    busStopName?: boolean
    isPrimary?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    station?: boolean | StationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyStation"]>

  export type PropertyStationSelectScalar = {
    id?: boolean
    propertyId?: boolean
    stationId?: boolean
    walkMinutes?: boolean
    busMinutes?: boolean
    busStopName?: boolean
    isPrimary?: boolean
  }

  export type PropertyStationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "stationId" | "walkMinutes" | "busMinutes" | "busStopName" | "isPrimary", ExtArgs["result"]["propertyStation"]>
  export type PropertyStationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    station?: boolean | StationDefaultArgs<ExtArgs>
  }
  export type PropertyStationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    station?: boolean | StationDefaultArgs<ExtArgs>
  }
  export type PropertyStationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    station?: boolean | StationDefaultArgs<ExtArgs>
  }

  export type $PropertyStationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyStation"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      station: Prisma.$StationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      stationId: string
      walkMinutes: number | null
      busMinutes: number | null
      busStopName: string | null
      isPrimary: boolean
    }, ExtArgs["result"]["propertyStation"]>
    composites: {}
  }

  type PropertyStationGetPayload<S extends boolean | null | undefined | PropertyStationDefaultArgs> = $Result.GetResult<Prisma.$PropertyStationPayload, S>

  type PropertyStationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyStationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyStationCountAggregateInputType | true
    }

  export interface PropertyStationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyStation'], meta: { name: 'PropertyStation' } }
    /**
     * Find zero or one PropertyStation that matches the filter.
     * @param {PropertyStationFindUniqueArgs} args - Arguments to find a PropertyStation
     * @example
     * // Get one PropertyStation
     * const propertyStation = await prisma.propertyStation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyStationFindUniqueArgs>(args: SelectSubset<T, PropertyStationFindUniqueArgs<ExtArgs>>): Prisma__PropertyStationClient<$Result.GetResult<Prisma.$PropertyStationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyStation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyStationFindUniqueOrThrowArgs} args - Arguments to find a PropertyStation
     * @example
     * // Get one PropertyStation
     * const propertyStation = await prisma.propertyStation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyStationFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyStationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyStationClient<$Result.GetResult<Prisma.$PropertyStationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyStation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStationFindFirstArgs} args - Arguments to find a PropertyStation
     * @example
     * // Get one PropertyStation
     * const propertyStation = await prisma.propertyStation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyStationFindFirstArgs>(args?: SelectSubset<T, PropertyStationFindFirstArgs<ExtArgs>>): Prisma__PropertyStationClient<$Result.GetResult<Prisma.$PropertyStationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyStation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStationFindFirstOrThrowArgs} args - Arguments to find a PropertyStation
     * @example
     * // Get one PropertyStation
     * const propertyStation = await prisma.propertyStation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyStationFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyStationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyStationClient<$Result.GetResult<Prisma.$PropertyStationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyStations
     * const propertyStations = await prisma.propertyStation.findMany()
     * 
     * // Get first 10 PropertyStations
     * const propertyStations = await prisma.propertyStation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyStationWithIdOnly = await prisma.propertyStation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyStationFindManyArgs>(args?: SelectSubset<T, PropertyStationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyStationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyStation.
     * @param {PropertyStationCreateArgs} args - Arguments to create a PropertyStation.
     * @example
     * // Create one PropertyStation
     * const PropertyStation = await prisma.propertyStation.create({
     *   data: {
     *     // ... data to create a PropertyStation
     *   }
     * })
     * 
     */
    create<T extends PropertyStationCreateArgs>(args: SelectSubset<T, PropertyStationCreateArgs<ExtArgs>>): Prisma__PropertyStationClient<$Result.GetResult<Prisma.$PropertyStationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyStations.
     * @param {PropertyStationCreateManyArgs} args - Arguments to create many PropertyStations.
     * @example
     * // Create many PropertyStations
     * const propertyStation = await prisma.propertyStation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyStationCreateManyArgs>(args?: SelectSubset<T, PropertyStationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyStations and returns the data saved in the database.
     * @param {PropertyStationCreateManyAndReturnArgs} args - Arguments to create many PropertyStations.
     * @example
     * // Create many PropertyStations
     * const propertyStation = await prisma.propertyStation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyStations and only return the `id`
     * const propertyStationWithIdOnly = await prisma.propertyStation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyStationCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyStationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyStationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyStation.
     * @param {PropertyStationDeleteArgs} args - Arguments to delete one PropertyStation.
     * @example
     * // Delete one PropertyStation
     * const PropertyStation = await prisma.propertyStation.delete({
     *   where: {
     *     // ... filter to delete one PropertyStation
     *   }
     * })
     * 
     */
    delete<T extends PropertyStationDeleteArgs>(args: SelectSubset<T, PropertyStationDeleteArgs<ExtArgs>>): Prisma__PropertyStationClient<$Result.GetResult<Prisma.$PropertyStationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyStation.
     * @param {PropertyStationUpdateArgs} args - Arguments to update one PropertyStation.
     * @example
     * // Update one PropertyStation
     * const propertyStation = await prisma.propertyStation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyStationUpdateArgs>(args: SelectSubset<T, PropertyStationUpdateArgs<ExtArgs>>): Prisma__PropertyStationClient<$Result.GetResult<Prisma.$PropertyStationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyStations.
     * @param {PropertyStationDeleteManyArgs} args - Arguments to filter PropertyStations to delete.
     * @example
     * // Delete a few PropertyStations
     * const { count } = await prisma.propertyStation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyStationDeleteManyArgs>(args?: SelectSubset<T, PropertyStationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyStations
     * const propertyStation = await prisma.propertyStation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyStationUpdateManyArgs>(args: SelectSubset<T, PropertyStationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyStations and returns the data updated in the database.
     * @param {PropertyStationUpdateManyAndReturnArgs} args - Arguments to update many PropertyStations.
     * @example
     * // Update many PropertyStations
     * const propertyStation = await prisma.propertyStation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyStations and only return the `id`
     * const propertyStationWithIdOnly = await prisma.propertyStation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyStationUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyStationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyStationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyStation.
     * @param {PropertyStationUpsertArgs} args - Arguments to update or create a PropertyStation.
     * @example
     * // Update or create a PropertyStation
     * const propertyStation = await prisma.propertyStation.upsert({
     *   create: {
     *     // ... data to create a PropertyStation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyStation we want to update
     *   }
     * })
     */
    upsert<T extends PropertyStationUpsertArgs>(args: SelectSubset<T, PropertyStationUpsertArgs<ExtArgs>>): Prisma__PropertyStationClient<$Result.GetResult<Prisma.$PropertyStationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStationCountArgs} args - Arguments to filter PropertyStations to count.
     * @example
     * // Count the number of PropertyStations
     * const count = await prisma.propertyStation.count({
     *   where: {
     *     // ... the filter for the PropertyStations we want to count
     *   }
     * })
    **/
    count<T extends PropertyStationCountArgs>(
      args?: Subset<T, PropertyStationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyStationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyStationAggregateArgs>(args: Subset<T, PropertyStationAggregateArgs>): Prisma.PrismaPromise<GetPropertyStationAggregateType<T>>

    /**
     * Group by PropertyStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyStationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyStationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyStationGroupByArgs['orderBy'] }
        : { orderBy?: PropertyStationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyStationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyStationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyStation model
   */
  readonly fields: PropertyStationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyStation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyStationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    station<T extends StationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StationDefaultArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyStation model
   */
  interface PropertyStationFieldRefs {
    readonly id: FieldRef<"PropertyStation", 'String'>
    readonly propertyId: FieldRef<"PropertyStation", 'String'>
    readonly stationId: FieldRef<"PropertyStation", 'String'>
    readonly walkMinutes: FieldRef<"PropertyStation", 'Int'>
    readonly busMinutes: FieldRef<"PropertyStation", 'Int'>
    readonly busStopName: FieldRef<"PropertyStation", 'String'>
    readonly isPrimary: FieldRef<"PropertyStation", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PropertyStation findUnique
   */
  export type PropertyStationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStation
     */
    select?: PropertyStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStation
     */
    omit?: PropertyStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStationInclude<ExtArgs> | null
    /**
     * Filter, which PropertyStation to fetch.
     */
    where: PropertyStationWhereUniqueInput
  }

  /**
   * PropertyStation findUniqueOrThrow
   */
  export type PropertyStationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStation
     */
    select?: PropertyStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStation
     */
    omit?: PropertyStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStationInclude<ExtArgs> | null
    /**
     * Filter, which PropertyStation to fetch.
     */
    where: PropertyStationWhereUniqueInput
  }

  /**
   * PropertyStation findFirst
   */
  export type PropertyStationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStation
     */
    select?: PropertyStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStation
     */
    omit?: PropertyStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStationInclude<ExtArgs> | null
    /**
     * Filter, which PropertyStation to fetch.
     */
    where?: PropertyStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyStations to fetch.
     */
    orderBy?: PropertyStationOrderByWithRelationInput | PropertyStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyStations.
     */
    cursor?: PropertyStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyStations.
     */
    distinct?: PropertyStationScalarFieldEnum | PropertyStationScalarFieldEnum[]
  }

  /**
   * PropertyStation findFirstOrThrow
   */
  export type PropertyStationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStation
     */
    select?: PropertyStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStation
     */
    omit?: PropertyStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStationInclude<ExtArgs> | null
    /**
     * Filter, which PropertyStation to fetch.
     */
    where?: PropertyStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyStations to fetch.
     */
    orderBy?: PropertyStationOrderByWithRelationInput | PropertyStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyStations.
     */
    cursor?: PropertyStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyStations.
     */
    distinct?: PropertyStationScalarFieldEnum | PropertyStationScalarFieldEnum[]
  }

  /**
   * PropertyStation findMany
   */
  export type PropertyStationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStation
     */
    select?: PropertyStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStation
     */
    omit?: PropertyStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStationInclude<ExtArgs> | null
    /**
     * Filter, which PropertyStations to fetch.
     */
    where?: PropertyStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyStations to fetch.
     */
    orderBy?: PropertyStationOrderByWithRelationInput | PropertyStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyStations.
     */
    cursor?: PropertyStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyStations.
     */
    skip?: number
    distinct?: PropertyStationScalarFieldEnum | PropertyStationScalarFieldEnum[]
  }

  /**
   * PropertyStation create
   */
  export type PropertyStationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStation
     */
    select?: PropertyStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStation
     */
    omit?: PropertyStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStationInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyStation.
     */
    data: XOR<PropertyStationCreateInput, PropertyStationUncheckedCreateInput>
  }

  /**
   * PropertyStation createMany
   */
  export type PropertyStationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyStations.
     */
    data: PropertyStationCreateManyInput | PropertyStationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyStation createManyAndReturn
   */
  export type PropertyStationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStation
     */
    select?: PropertyStationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStation
     */
    omit?: PropertyStationOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyStations.
     */
    data: PropertyStationCreateManyInput | PropertyStationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyStation update
   */
  export type PropertyStationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStation
     */
    select?: PropertyStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStation
     */
    omit?: PropertyStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStationInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyStation.
     */
    data: XOR<PropertyStationUpdateInput, PropertyStationUncheckedUpdateInput>
    /**
     * Choose, which PropertyStation to update.
     */
    where: PropertyStationWhereUniqueInput
  }

  /**
   * PropertyStation updateMany
   */
  export type PropertyStationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyStations.
     */
    data: XOR<PropertyStationUpdateManyMutationInput, PropertyStationUncheckedUpdateManyInput>
    /**
     * Filter which PropertyStations to update
     */
    where?: PropertyStationWhereInput
    /**
     * Limit how many PropertyStations to update.
     */
    limit?: number
  }

  /**
   * PropertyStation updateManyAndReturn
   */
  export type PropertyStationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStation
     */
    select?: PropertyStationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStation
     */
    omit?: PropertyStationOmit<ExtArgs> | null
    /**
     * The data used to update PropertyStations.
     */
    data: XOR<PropertyStationUpdateManyMutationInput, PropertyStationUncheckedUpdateManyInput>
    /**
     * Filter which PropertyStations to update
     */
    where?: PropertyStationWhereInput
    /**
     * Limit how many PropertyStations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyStation upsert
   */
  export type PropertyStationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStation
     */
    select?: PropertyStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStation
     */
    omit?: PropertyStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStationInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyStation to update in case it exists.
     */
    where: PropertyStationWhereUniqueInput
    /**
     * In case the PropertyStation found by the `where` argument doesn't exist, create a new PropertyStation with this data.
     */
    create: XOR<PropertyStationCreateInput, PropertyStationUncheckedCreateInput>
    /**
     * In case the PropertyStation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyStationUpdateInput, PropertyStationUncheckedUpdateInput>
  }

  /**
   * PropertyStation delete
   */
  export type PropertyStationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStation
     */
    select?: PropertyStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStation
     */
    omit?: PropertyStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStationInclude<ExtArgs> | null
    /**
     * Filter which PropertyStation to delete.
     */
    where: PropertyStationWhereUniqueInput
  }

  /**
   * PropertyStation deleteMany
   */
  export type PropertyStationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyStations to delete
     */
    where?: PropertyStationWhereInput
    /**
     * Limit how many PropertyStations to delete.
     */
    limit?: number
  }

  /**
   * PropertyStation without action
   */
  export type PropertyStationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStation
     */
    select?: PropertyStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStation
     */
    omit?: PropertyStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStationInclude<ExtArgs> | null
  }


  /**
   * Model Favorite
   */

  export type AggregateFavorite = {
    _count: FavoriteCountAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  export type FavoriteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    propertyId: string | null
    createdAt: Date | null
  }

  export type FavoriteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    propertyId: string | null
    createdAt: Date | null
  }

  export type FavoriteCountAggregateOutputType = {
    id: number
    userId: number
    propertyId: number
    createdAt: number
    _all: number
  }


  export type FavoriteMinAggregateInputType = {
    id?: true
    userId?: true
    propertyId?: true
    createdAt?: true
  }

  export type FavoriteMaxAggregateInputType = {
    id?: true
    userId?: true
    propertyId?: true
    createdAt?: true
  }

  export type FavoriteCountAggregateInputType = {
    id?: true
    userId?: true
    propertyId?: true
    createdAt?: true
    _all?: true
  }

  export type FavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorite to aggregate.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Favorites
    **/
    _count?: true | FavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteMaxAggregateInputType
  }

  export type GetFavoriteAggregateType<T extends FavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavorite[P]>
      : GetScalarType<T[P], AggregateFavorite[P]>
  }




  export type FavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithAggregationInput | FavoriteOrderByWithAggregationInput[]
    by: FavoriteScalarFieldEnum[] | FavoriteScalarFieldEnum
    having?: FavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteCountAggregateInputType | true
    _min?: FavoriteMinAggregateInputType
    _max?: FavoriteMaxAggregateInputType
  }

  export type FavoriteGroupByOutputType = {
    id: string
    userId: string
    propertyId: string
    createdAt: Date
    _count: FavoriteCountAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  type GetFavoriteGroupByPayload<T extends FavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
        }
      >
    >


  export type FavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    propertyId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    propertyId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    propertyId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectScalar = {
    id?: boolean
    userId?: boolean
    propertyId?: boolean
    createdAt?: boolean
  }

  export type FavoriteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "propertyId" | "createdAt", ExtArgs["result"]["favorite"]>
  export type FavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type FavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type FavoriteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $FavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Favorite"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      propertyId: string
      createdAt: Date
    }, ExtArgs["result"]["favorite"]>
    composites: {}
  }

  type FavoriteGetPayload<S extends boolean | null | undefined | FavoriteDefaultArgs> = $Result.GetResult<Prisma.$FavoritePayload, S>

  type FavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FavoriteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FavoriteCountAggregateInputType | true
    }

  export interface FavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Favorite'], meta: { name: 'Favorite' } }
    /**
     * Find zero or one Favorite that matches the filter.
     * @param {FavoriteFindUniqueArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoriteFindUniqueArgs>(args: SelectSubset<T, FavoriteFindUniqueArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Favorite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavoriteFindUniqueOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoriteFindFirstArgs>(args?: SelectSubset<T, FavoriteFindFirstArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Favorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favorites
     * const favorites = await prisma.favorite.findMany()
     * 
     * // Get first 10 Favorites
     * const favorites = await prisma.favorite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoriteWithIdOnly = await prisma.favorite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavoriteFindManyArgs>(args?: SelectSubset<T, FavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Favorite.
     * @param {FavoriteCreateArgs} args - Arguments to create a Favorite.
     * @example
     * // Create one Favorite
     * const Favorite = await prisma.favorite.create({
     *   data: {
     *     // ... data to create a Favorite
     *   }
     * })
     * 
     */
    create<T extends FavoriteCreateArgs>(args: SelectSubset<T, FavoriteCreateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Favorites.
     * @param {FavoriteCreateManyArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoriteCreateManyArgs>(args?: SelectSubset<T, FavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Favorites and returns the data saved in the database.
     * @param {FavoriteCreateManyAndReturnArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Favorites and only return the `id`
     * const favoriteWithIdOnly = await prisma.favorite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Favorite.
     * @param {FavoriteDeleteArgs} args - Arguments to delete one Favorite.
     * @example
     * // Delete one Favorite
     * const Favorite = await prisma.favorite.delete({
     *   where: {
     *     // ... filter to delete one Favorite
     *   }
     * })
     * 
     */
    delete<T extends FavoriteDeleteArgs>(args: SelectSubset<T, FavoriteDeleteArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Favorite.
     * @param {FavoriteUpdateArgs} args - Arguments to update one Favorite.
     * @example
     * // Update one Favorite
     * const favorite = await prisma.favorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoriteUpdateArgs>(args: SelectSubset<T, FavoriteUpdateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Favorites.
     * @param {FavoriteDeleteManyArgs} args - Arguments to filter Favorites to delete.
     * @example
     * // Delete a few Favorites
     * const { count } = await prisma.favorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoriteDeleteManyArgs>(args?: SelectSubset<T, FavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoriteUpdateManyArgs>(args: SelectSubset<T, FavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites and returns the data updated in the database.
     * @param {FavoriteUpdateManyAndReturnArgs} args - Arguments to update many Favorites.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Favorites and only return the `id`
     * const favoriteWithIdOnly = await prisma.favorite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FavoriteUpdateManyAndReturnArgs>(args: SelectSubset<T, FavoriteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Favorite.
     * @param {FavoriteUpsertArgs} args - Arguments to update or create a Favorite.
     * @example
     * // Update or create a Favorite
     * const favorite = await prisma.favorite.upsert({
     *   create: {
     *     // ... data to create a Favorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favorite we want to update
     *   }
     * })
     */
    upsert<T extends FavoriteUpsertArgs>(args: SelectSubset<T, FavoriteUpsertArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteCountArgs} args - Arguments to filter Favorites to count.
     * @example
     * // Count the number of Favorites
     * const count = await prisma.favorite.count({
     *   where: {
     *     // ... the filter for the Favorites we want to count
     *   }
     * })
    **/
    count<T extends FavoriteCountArgs>(
      args?: Subset<T, FavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteAggregateArgs>(args: Subset<T, FavoriteAggregateArgs>): Prisma.PrismaPromise<GetFavoriteAggregateType<T>>

    /**
     * Group by Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Favorite model
   */
  readonly fields: FavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Favorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Favorite model
   */
  interface FavoriteFieldRefs {
    readonly id: FieldRef<"Favorite", 'String'>
    readonly userId: FieldRef<"Favorite", 'String'>
    readonly propertyId: FieldRef<"Favorite", 'String'>
    readonly createdAt: FieldRef<"Favorite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Favorite findUnique
   */
  export type FavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findUniqueOrThrow
   */
  export type FavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findFirst
   */
  export type FavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findFirstOrThrow
   */
  export type FavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findMany
   */
  export type FavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorites to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite create
   */
  export type FavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a Favorite.
     */
    data: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
  }

  /**
   * Favorite createMany
   */
  export type FavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Favorite createManyAndReturn
   */
  export type FavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite update
   */
  export type FavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a Favorite.
     */
    data: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
    /**
     * Choose, which Favorite to update.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite updateMany
   */
  export type FavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to update.
     */
    limit?: number
  }

  /**
   * Favorite updateManyAndReturn
   */
  export type FavoriteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite upsert
   */
  export type FavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the Favorite to update in case it exists.
     */
    where: FavoriteWhereUniqueInput
    /**
     * In case the Favorite found by the `where` argument doesn't exist, create a new Favorite with this data.
     */
    create: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
    /**
     * In case the Favorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
  }

  /**
   * Favorite delete
   */
  export type FavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter which Favorite to delete.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite deleteMany
   */
  export type FavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorites to delete
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to delete.
     */
    limit?: number
  }

  /**
   * Favorite without action
   */
  export type FavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
  }


  /**
   * Model PropertyView
   */

  export type AggregatePropertyView = {
    _count: PropertyViewCountAggregateOutputType | null
    _avg: PropertyViewAvgAggregateOutputType | null
    _sum: PropertyViewSumAggregateOutputType | null
    _min: PropertyViewMinAggregateOutputType | null
    _max: PropertyViewMaxAggregateOutputType | null
  }

  export type PropertyViewAvgAggregateOutputType = {
    viewDurationSeconds: number | null
  }

  export type PropertyViewSumAggregateOutputType = {
    viewDurationSeconds: number | null
  }

  export type PropertyViewMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    userId: string | null
    sessionId: string | null
    ipAddress: string | null
    userAgent: string | null
    referer: string | null
    viewedAt: Date | null
    viewDurationSeconds: number | null
  }

  export type PropertyViewMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    userId: string | null
    sessionId: string | null
    ipAddress: string | null
    userAgent: string | null
    referer: string | null
    viewedAt: Date | null
    viewDurationSeconds: number | null
  }

  export type PropertyViewCountAggregateOutputType = {
    id: number
    propertyId: number
    userId: number
    sessionId: number
    ipAddress: number
    userAgent: number
    referer: number
    viewedAt: number
    viewDurationSeconds: number
    _all: number
  }


  export type PropertyViewAvgAggregateInputType = {
    viewDurationSeconds?: true
  }

  export type PropertyViewSumAggregateInputType = {
    viewDurationSeconds?: true
  }

  export type PropertyViewMinAggregateInputType = {
    id?: true
    propertyId?: true
    userId?: true
    sessionId?: true
    ipAddress?: true
    userAgent?: true
    referer?: true
    viewedAt?: true
    viewDurationSeconds?: true
  }

  export type PropertyViewMaxAggregateInputType = {
    id?: true
    propertyId?: true
    userId?: true
    sessionId?: true
    ipAddress?: true
    userAgent?: true
    referer?: true
    viewedAt?: true
    viewDurationSeconds?: true
  }

  export type PropertyViewCountAggregateInputType = {
    id?: true
    propertyId?: true
    userId?: true
    sessionId?: true
    ipAddress?: true
    userAgent?: true
    referer?: true
    viewedAt?: true
    viewDurationSeconds?: true
    _all?: true
  }

  export type PropertyViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyView to aggregate.
     */
    where?: PropertyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViews to fetch.
     */
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyViews
    **/
    _count?: true | PropertyViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyViewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyViewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyViewMaxAggregateInputType
  }

  export type GetPropertyViewAggregateType<T extends PropertyViewAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyView[P]>
      : GetScalarType<T[P], AggregatePropertyView[P]>
  }




  export type PropertyViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyViewWhereInput
    orderBy?: PropertyViewOrderByWithAggregationInput | PropertyViewOrderByWithAggregationInput[]
    by: PropertyViewScalarFieldEnum[] | PropertyViewScalarFieldEnum
    having?: PropertyViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyViewCountAggregateInputType | true
    _avg?: PropertyViewAvgAggregateInputType
    _sum?: PropertyViewSumAggregateInputType
    _min?: PropertyViewMinAggregateInputType
    _max?: PropertyViewMaxAggregateInputType
  }

  export type PropertyViewGroupByOutputType = {
    id: string
    propertyId: string
    userId: string | null
    sessionId: string | null
    ipAddress: string | null
    userAgent: string | null
    referer: string | null
    viewedAt: Date
    viewDurationSeconds: number | null
    _count: PropertyViewCountAggregateOutputType | null
    _avg: PropertyViewAvgAggregateOutputType | null
    _sum: PropertyViewSumAggregateOutputType | null
    _min: PropertyViewMinAggregateOutputType | null
    _max: PropertyViewMaxAggregateOutputType | null
  }

  type GetPropertyViewGroupByPayload<T extends PropertyViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyViewGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyViewGroupByOutputType[P]>
        }
      >
    >


  export type PropertyViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    userId?: boolean
    sessionId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referer?: boolean
    viewedAt?: boolean
    viewDurationSeconds?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    user?: boolean | PropertyView$userArgs<ExtArgs>
  }, ExtArgs["result"]["propertyView"]>

  export type PropertyViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    userId?: boolean
    sessionId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referer?: boolean
    viewedAt?: boolean
    viewDurationSeconds?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    user?: boolean | PropertyView$userArgs<ExtArgs>
  }, ExtArgs["result"]["propertyView"]>

  export type PropertyViewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    userId?: boolean
    sessionId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referer?: boolean
    viewedAt?: boolean
    viewDurationSeconds?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    user?: boolean | PropertyView$userArgs<ExtArgs>
  }, ExtArgs["result"]["propertyView"]>

  export type PropertyViewSelectScalar = {
    id?: boolean
    propertyId?: boolean
    userId?: boolean
    sessionId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referer?: boolean
    viewedAt?: boolean
    viewDurationSeconds?: boolean
  }

  export type PropertyViewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "userId" | "sessionId" | "ipAddress" | "userAgent" | "referer" | "viewedAt" | "viewDurationSeconds", ExtArgs["result"]["propertyView"]>
  export type PropertyViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    user?: boolean | PropertyView$userArgs<ExtArgs>
  }
  export type PropertyViewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    user?: boolean | PropertyView$userArgs<ExtArgs>
  }
  export type PropertyViewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    user?: boolean | PropertyView$userArgs<ExtArgs>
  }

  export type $PropertyViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyView"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      userId: string | null
      sessionId: string | null
      ipAddress: string | null
      userAgent: string | null
      referer: string | null
      viewedAt: Date
      viewDurationSeconds: number | null
    }, ExtArgs["result"]["propertyView"]>
    composites: {}
  }

  type PropertyViewGetPayload<S extends boolean | null | undefined | PropertyViewDefaultArgs> = $Result.GetResult<Prisma.$PropertyViewPayload, S>

  type PropertyViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyViewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyViewCountAggregateInputType | true
    }

  export interface PropertyViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyView'], meta: { name: 'PropertyView' } }
    /**
     * Find zero or one PropertyView that matches the filter.
     * @param {PropertyViewFindUniqueArgs} args - Arguments to find a PropertyView
     * @example
     * // Get one PropertyView
     * const propertyView = await prisma.propertyView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyViewFindUniqueArgs>(args: SelectSubset<T, PropertyViewFindUniqueArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyView that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyViewFindUniqueOrThrowArgs} args - Arguments to find a PropertyView
     * @example
     * // Get one PropertyView
     * const propertyView = await prisma.propertyView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyViewFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewFindFirstArgs} args - Arguments to find a PropertyView
     * @example
     * // Get one PropertyView
     * const propertyView = await prisma.propertyView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyViewFindFirstArgs>(args?: SelectSubset<T, PropertyViewFindFirstArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewFindFirstOrThrowArgs} args - Arguments to find a PropertyView
     * @example
     * // Get one PropertyView
     * const propertyView = await prisma.propertyView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyViewFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyViews
     * const propertyViews = await prisma.propertyView.findMany()
     * 
     * // Get first 10 PropertyViews
     * const propertyViews = await prisma.propertyView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyViewWithIdOnly = await prisma.propertyView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyViewFindManyArgs>(args?: SelectSubset<T, PropertyViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyView.
     * @param {PropertyViewCreateArgs} args - Arguments to create a PropertyView.
     * @example
     * // Create one PropertyView
     * const PropertyView = await prisma.propertyView.create({
     *   data: {
     *     // ... data to create a PropertyView
     *   }
     * })
     * 
     */
    create<T extends PropertyViewCreateArgs>(args: SelectSubset<T, PropertyViewCreateArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyViews.
     * @param {PropertyViewCreateManyArgs} args - Arguments to create many PropertyViews.
     * @example
     * // Create many PropertyViews
     * const propertyView = await prisma.propertyView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyViewCreateManyArgs>(args?: SelectSubset<T, PropertyViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyViews and returns the data saved in the database.
     * @param {PropertyViewCreateManyAndReturnArgs} args - Arguments to create many PropertyViews.
     * @example
     * // Create many PropertyViews
     * const propertyView = await prisma.propertyView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyViews and only return the `id`
     * const propertyViewWithIdOnly = await prisma.propertyView.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyViewCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyView.
     * @param {PropertyViewDeleteArgs} args - Arguments to delete one PropertyView.
     * @example
     * // Delete one PropertyView
     * const PropertyView = await prisma.propertyView.delete({
     *   where: {
     *     // ... filter to delete one PropertyView
     *   }
     * })
     * 
     */
    delete<T extends PropertyViewDeleteArgs>(args: SelectSubset<T, PropertyViewDeleteArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyView.
     * @param {PropertyViewUpdateArgs} args - Arguments to update one PropertyView.
     * @example
     * // Update one PropertyView
     * const propertyView = await prisma.propertyView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyViewUpdateArgs>(args: SelectSubset<T, PropertyViewUpdateArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyViews.
     * @param {PropertyViewDeleteManyArgs} args - Arguments to filter PropertyViews to delete.
     * @example
     * // Delete a few PropertyViews
     * const { count } = await prisma.propertyView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyViewDeleteManyArgs>(args?: SelectSubset<T, PropertyViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyViews
     * const propertyView = await prisma.propertyView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyViewUpdateManyArgs>(args: SelectSubset<T, PropertyViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyViews and returns the data updated in the database.
     * @param {PropertyViewUpdateManyAndReturnArgs} args - Arguments to update many PropertyViews.
     * @example
     * // Update many PropertyViews
     * const propertyView = await prisma.propertyView.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyViews and only return the `id`
     * const propertyViewWithIdOnly = await prisma.propertyView.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyViewUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyViewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyView.
     * @param {PropertyViewUpsertArgs} args - Arguments to update or create a PropertyView.
     * @example
     * // Update or create a PropertyView
     * const propertyView = await prisma.propertyView.upsert({
     *   create: {
     *     // ... data to create a PropertyView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyView we want to update
     *   }
     * })
     */
    upsert<T extends PropertyViewUpsertArgs>(args: SelectSubset<T, PropertyViewUpsertArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewCountArgs} args - Arguments to filter PropertyViews to count.
     * @example
     * // Count the number of PropertyViews
     * const count = await prisma.propertyView.count({
     *   where: {
     *     // ... the filter for the PropertyViews we want to count
     *   }
     * })
    **/
    count<T extends PropertyViewCountArgs>(
      args?: Subset<T, PropertyViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyViewAggregateArgs>(args: Subset<T, PropertyViewAggregateArgs>): Prisma.PrismaPromise<GetPropertyViewAggregateType<T>>

    /**
     * Group by PropertyView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyViewGroupByArgs['orderBy'] }
        : { orderBy?: PropertyViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyView model
   */
  readonly fields: PropertyViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends PropertyView$userArgs<ExtArgs> = {}>(args?: Subset<T, PropertyView$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyView model
   */
  interface PropertyViewFieldRefs {
    readonly id: FieldRef<"PropertyView", 'String'>
    readonly propertyId: FieldRef<"PropertyView", 'String'>
    readonly userId: FieldRef<"PropertyView", 'String'>
    readonly sessionId: FieldRef<"PropertyView", 'String'>
    readonly ipAddress: FieldRef<"PropertyView", 'String'>
    readonly userAgent: FieldRef<"PropertyView", 'String'>
    readonly referer: FieldRef<"PropertyView", 'String'>
    readonly viewedAt: FieldRef<"PropertyView", 'DateTime'>
    readonly viewDurationSeconds: FieldRef<"PropertyView", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PropertyView findUnique
   */
  export type PropertyViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyView to fetch.
     */
    where: PropertyViewWhereUniqueInput
  }

  /**
   * PropertyView findUniqueOrThrow
   */
  export type PropertyViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyView to fetch.
     */
    where: PropertyViewWhereUniqueInput
  }

  /**
   * PropertyView findFirst
   */
  export type PropertyViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyView to fetch.
     */
    where?: PropertyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViews to fetch.
     */
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyViews.
     */
    cursor?: PropertyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyViews.
     */
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
  }

  /**
   * PropertyView findFirstOrThrow
   */
  export type PropertyViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyView to fetch.
     */
    where?: PropertyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViews to fetch.
     */
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyViews.
     */
    cursor?: PropertyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyViews.
     */
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
  }

  /**
   * PropertyView findMany
   */
  export type PropertyViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyViews to fetch.
     */
    where?: PropertyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViews to fetch.
     */
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyViews.
     */
    cursor?: PropertyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViews.
     */
    skip?: number
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
  }

  /**
   * PropertyView create
   */
  export type PropertyViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyView.
     */
    data: XOR<PropertyViewCreateInput, PropertyViewUncheckedCreateInput>
  }

  /**
   * PropertyView createMany
   */
  export type PropertyViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyViews.
     */
    data: PropertyViewCreateManyInput | PropertyViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyView createManyAndReturn
   */
  export type PropertyViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyViews.
     */
    data: PropertyViewCreateManyInput | PropertyViewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyView update
   */
  export type PropertyViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyView.
     */
    data: XOR<PropertyViewUpdateInput, PropertyViewUncheckedUpdateInput>
    /**
     * Choose, which PropertyView to update.
     */
    where: PropertyViewWhereUniqueInput
  }

  /**
   * PropertyView updateMany
   */
  export type PropertyViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyViews.
     */
    data: XOR<PropertyViewUpdateManyMutationInput, PropertyViewUncheckedUpdateManyInput>
    /**
     * Filter which PropertyViews to update
     */
    where?: PropertyViewWhereInput
    /**
     * Limit how many PropertyViews to update.
     */
    limit?: number
  }

  /**
   * PropertyView updateManyAndReturn
   */
  export type PropertyViewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * The data used to update PropertyViews.
     */
    data: XOR<PropertyViewUpdateManyMutationInput, PropertyViewUncheckedUpdateManyInput>
    /**
     * Filter which PropertyViews to update
     */
    where?: PropertyViewWhereInput
    /**
     * Limit how many PropertyViews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyView upsert
   */
  export type PropertyViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyView to update in case it exists.
     */
    where: PropertyViewWhereUniqueInput
    /**
     * In case the PropertyView found by the `where` argument doesn't exist, create a new PropertyView with this data.
     */
    create: XOR<PropertyViewCreateInput, PropertyViewUncheckedCreateInput>
    /**
     * In case the PropertyView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyViewUpdateInput, PropertyViewUncheckedUpdateInput>
  }

  /**
   * PropertyView delete
   */
  export type PropertyViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter which PropertyView to delete.
     */
    where: PropertyViewWhereUniqueInput
  }

  /**
   * PropertyView deleteMany
   */
  export type PropertyViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyViews to delete
     */
    where?: PropertyViewWhereInput
    /**
     * Limit how many PropertyViews to delete.
     */
    limit?: number
  }

  /**
   * PropertyView.user
   */
  export type PropertyView$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PropertyView without action
   */
  export type PropertyViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
  }


  /**
   * Model PropertyViewDaily
   */

  export type AggregatePropertyViewDaily = {
    _count: PropertyViewDailyCountAggregateOutputType | null
    _avg: PropertyViewDailyAvgAggregateOutputType | null
    _sum: PropertyViewDailySumAggregateOutputType | null
    _min: PropertyViewDailyMinAggregateOutputType | null
    _max: PropertyViewDailyMaxAggregateOutputType | null
  }

  export type PropertyViewDailyAvgAggregateOutputType = {
    totalViews: number | null
    uniqueUsers: number | null
    avgDurationSeconds: Decimal | null
  }

  export type PropertyViewDailySumAggregateOutputType = {
    totalViews: number | null
    uniqueUsers: number | null
    avgDurationSeconds: Decimal | null
  }

  export type PropertyViewDailyMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    viewDate: Date | null
    totalViews: number | null
    uniqueUsers: number | null
    avgDurationSeconds: Decimal | null
    createdAt: Date | null
  }

  export type PropertyViewDailyMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    viewDate: Date | null
    totalViews: number | null
    uniqueUsers: number | null
    avgDurationSeconds: Decimal | null
    createdAt: Date | null
  }

  export type PropertyViewDailyCountAggregateOutputType = {
    id: number
    propertyId: number
    viewDate: number
    totalViews: number
    uniqueUsers: number
    avgDurationSeconds: number
    createdAt: number
    _all: number
  }


  export type PropertyViewDailyAvgAggregateInputType = {
    totalViews?: true
    uniqueUsers?: true
    avgDurationSeconds?: true
  }

  export type PropertyViewDailySumAggregateInputType = {
    totalViews?: true
    uniqueUsers?: true
    avgDurationSeconds?: true
  }

  export type PropertyViewDailyMinAggregateInputType = {
    id?: true
    propertyId?: true
    viewDate?: true
    totalViews?: true
    uniqueUsers?: true
    avgDurationSeconds?: true
    createdAt?: true
  }

  export type PropertyViewDailyMaxAggregateInputType = {
    id?: true
    propertyId?: true
    viewDate?: true
    totalViews?: true
    uniqueUsers?: true
    avgDurationSeconds?: true
    createdAt?: true
  }

  export type PropertyViewDailyCountAggregateInputType = {
    id?: true
    propertyId?: true
    viewDate?: true
    totalViews?: true
    uniqueUsers?: true
    avgDurationSeconds?: true
    createdAt?: true
    _all?: true
  }

  export type PropertyViewDailyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyViewDaily to aggregate.
     */
    where?: PropertyViewDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViewDailies to fetch.
     */
    orderBy?: PropertyViewDailyOrderByWithRelationInput | PropertyViewDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyViewDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViewDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViewDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyViewDailies
    **/
    _count?: true | PropertyViewDailyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyViewDailyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyViewDailySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyViewDailyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyViewDailyMaxAggregateInputType
  }

  export type GetPropertyViewDailyAggregateType<T extends PropertyViewDailyAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyViewDaily]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyViewDaily[P]>
      : GetScalarType<T[P], AggregatePropertyViewDaily[P]>
  }




  export type PropertyViewDailyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyViewDailyWhereInput
    orderBy?: PropertyViewDailyOrderByWithAggregationInput | PropertyViewDailyOrderByWithAggregationInput[]
    by: PropertyViewDailyScalarFieldEnum[] | PropertyViewDailyScalarFieldEnum
    having?: PropertyViewDailyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyViewDailyCountAggregateInputType | true
    _avg?: PropertyViewDailyAvgAggregateInputType
    _sum?: PropertyViewDailySumAggregateInputType
    _min?: PropertyViewDailyMinAggregateInputType
    _max?: PropertyViewDailyMaxAggregateInputType
  }

  export type PropertyViewDailyGroupByOutputType = {
    id: string
    propertyId: string
    viewDate: Date
    totalViews: number
    uniqueUsers: number
    avgDurationSeconds: Decimal | null
    createdAt: Date
    _count: PropertyViewDailyCountAggregateOutputType | null
    _avg: PropertyViewDailyAvgAggregateOutputType | null
    _sum: PropertyViewDailySumAggregateOutputType | null
    _min: PropertyViewDailyMinAggregateOutputType | null
    _max: PropertyViewDailyMaxAggregateOutputType | null
  }

  type GetPropertyViewDailyGroupByPayload<T extends PropertyViewDailyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyViewDailyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyViewDailyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyViewDailyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyViewDailyGroupByOutputType[P]>
        }
      >
    >


  export type PropertyViewDailySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    viewDate?: boolean
    totalViews?: boolean
    uniqueUsers?: boolean
    avgDurationSeconds?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyViewDaily"]>

  export type PropertyViewDailySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    viewDate?: boolean
    totalViews?: boolean
    uniqueUsers?: boolean
    avgDurationSeconds?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyViewDaily"]>

  export type PropertyViewDailySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    viewDate?: boolean
    totalViews?: boolean
    uniqueUsers?: boolean
    avgDurationSeconds?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyViewDaily"]>

  export type PropertyViewDailySelectScalar = {
    id?: boolean
    propertyId?: boolean
    viewDate?: boolean
    totalViews?: boolean
    uniqueUsers?: boolean
    avgDurationSeconds?: boolean
    createdAt?: boolean
  }

  export type PropertyViewDailyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "viewDate" | "totalViews" | "uniqueUsers" | "avgDurationSeconds" | "createdAt", ExtArgs["result"]["propertyViewDaily"]>
  export type PropertyViewDailyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyViewDailyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyViewDailyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertyViewDailyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyViewDaily"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      viewDate: Date
      totalViews: number
      uniqueUsers: number
      avgDurationSeconds: Prisma.Decimal | null
      createdAt: Date
    }, ExtArgs["result"]["propertyViewDaily"]>
    composites: {}
  }

  type PropertyViewDailyGetPayload<S extends boolean | null | undefined | PropertyViewDailyDefaultArgs> = $Result.GetResult<Prisma.$PropertyViewDailyPayload, S>

  type PropertyViewDailyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyViewDailyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyViewDailyCountAggregateInputType | true
    }

  export interface PropertyViewDailyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyViewDaily'], meta: { name: 'PropertyViewDaily' } }
    /**
     * Find zero or one PropertyViewDaily that matches the filter.
     * @param {PropertyViewDailyFindUniqueArgs} args - Arguments to find a PropertyViewDaily
     * @example
     * // Get one PropertyViewDaily
     * const propertyViewDaily = await prisma.propertyViewDaily.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyViewDailyFindUniqueArgs>(args: SelectSubset<T, PropertyViewDailyFindUniqueArgs<ExtArgs>>): Prisma__PropertyViewDailyClient<$Result.GetResult<Prisma.$PropertyViewDailyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyViewDaily that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyViewDailyFindUniqueOrThrowArgs} args - Arguments to find a PropertyViewDaily
     * @example
     * // Get one PropertyViewDaily
     * const propertyViewDaily = await prisma.propertyViewDaily.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyViewDailyFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyViewDailyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyViewDailyClient<$Result.GetResult<Prisma.$PropertyViewDailyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyViewDaily that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewDailyFindFirstArgs} args - Arguments to find a PropertyViewDaily
     * @example
     * // Get one PropertyViewDaily
     * const propertyViewDaily = await prisma.propertyViewDaily.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyViewDailyFindFirstArgs>(args?: SelectSubset<T, PropertyViewDailyFindFirstArgs<ExtArgs>>): Prisma__PropertyViewDailyClient<$Result.GetResult<Prisma.$PropertyViewDailyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyViewDaily that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewDailyFindFirstOrThrowArgs} args - Arguments to find a PropertyViewDaily
     * @example
     * // Get one PropertyViewDaily
     * const propertyViewDaily = await prisma.propertyViewDaily.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyViewDailyFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyViewDailyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyViewDailyClient<$Result.GetResult<Prisma.$PropertyViewDailyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyViewDailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewDailyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyViewDailies
     * const propertyViewDailies = await prisma.propertyViewDaily.findMany()
     * 
     * // Get first 10 PropertyViewDailies
     * const propertyViewDailies = await prisma.propertyViewDaily.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyViewDailyWithIdOnly = await prisma.propertyViewDaily.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyViewDailyFindManyArgs>(args?: SelectSubset<T, PropertyViewDailyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewDailyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyViewDaily.
     * @param {PropertyViewDailyCreateArgs} args - Arguments to create a PropertyViewDaily.
     * @example
     * // Create one PropertyViewDaily
     * const PropertyViewDaily = await prisma.propertyViewDaily.create({
     *   data: {
     *     // ... data to create a PropertyViewDaily
     *   }
     * })
     * 
     */
    create<T extends PropertyViewDailyCreateArgs>(args: SelectSubset<T, PropertyViewDailyCreateArgs<ExtArgs>>): Prisma__PropertyViewDailyClient<$Result.GetResult<Prisma.$PropertyViewDailyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyViewDailies.
     * @param {PropertyViewDailyCreateManyArgs} args - Arguments to create many PropertyViewDailies.
     * @example
     * // Create many PropertyViewDailies
     * const propertyViewDaily = await prisma.propertyViewDaily.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyViewDailyCreateManyArgs>(args?: SelectSubset<T, PropertyViewDailyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyViewDailies and returns the data saved in the database.
     * @param {PropertyViewDailyCreateManyAndReturnArgs} args - Arguments to create many PropertyViewDailies.
     * @example
     * // Create many PropertyViewDailies
     * const propertyViewDaily = await prisma.propertyViewDaily.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyViewDailies and only return the `id`
     * const propertyViewDailyWithIdOnly = await prisma.propertyViewDaily.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyViewDailyCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyViewDailyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewDailyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyViewDaily.
     * @param {PropertyViewDailyDeleteArgs} args - Arguments to delete one PropertyViewDaily.
     * @example
     * // Delete one PropertyViewDaily
     * const PropertyViewDaily = await prisma.propertyViewDaily.delete({
     *   where: {
     *     // ... filter to delete one PropertyViewDaily
     *   }
     * })
     * 
     */
    delete<T extends PropertyViewDailyDeleteArgs>(args: SelectSubset<T, PropertyViewDailyDeleteArgs<ExtArgs>>): Prisma__PropertyViewDailyClient<$Result.GetResult<Prisma.$PropertyViewDailyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyViewDaily.
     * @param {PropertyViewDailyUpdateArgs} args - Arguments to update one PropertyViewDaily.
     * @example
     * // Update one PropertyViewDaily
     * const propertyViewDaily = await prisma.propertyViewDaily.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyViewDailyUpdateArgs>(args: SelectSubset<T, PropertyViewDailyUpdateArgs<ExtArgs>>): Prisma__PropertyViewDailyClient<$Result.GetResult<Prisma.$PropertyViewDailyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyViewDailies.
     * @param {PropertyViewDailyDeleteManyArgs} args - Arguments to filter PropertyViewDailies to delete.
     * @example
     * // Delete a few PropertyViewDailies
     * const { count } = await prisma.propertyViewDaily.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyViewDailyDeleteManyArgs>(args?: SelectSubset<T, PropertyViewDailyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyViewDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewDailyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyViewDailies
     * const propertyViewDaily = await prisma.propertyViewDaily.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyViewDailyUpdateManyArgs>(args: SelectSubset<T, PropertyViewDailyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyViewDailies and returns the data updated in the database.
     * @param {PropertyViewDailyUpdateManyAndReturnArgs} args - Arguments to update many PropertyViewDailies.
     * @example
     * // Update many PropertyViewDailies
     * const propertyViewDaily = await prisma.propertyViewDaily.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyViewDailies and only return the `id`
     * const propertyViewDailyWithIdOnly = await prisma.propertyViewDaily.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyViewDailyUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyViewDailyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewDailyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyViewDaily.
     * @param {PropertyViewDailyUpsertArgs} args - Arguments to update or create a PropertyViewDaily.
     * @example
     * // Update or create a PropertyViewDaily
     * const propertyViewDaily = await prisma.propertyViewDaily.upsert({
     *   create: {
     *     // ... data to create a PropertyViewDaily
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyViewDaily we want to update
     *   }
     * })
     */
    upsert<T extends PropertyViewDailyUpsertArgs>(args: SelectSubset<T, PropertyViewDailyUpsertArgs<ExtArgs>>): Prisma__PropertyViewDailyClient<$Result.GetResult<Prisma.$PropertyViewDailyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyViewDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewDailyCountArgs} args - Arguments to filter PropertyViewDailies to count.
     * @example
     * // Count the number of PropertyViewDailies
     * const count = await prisma.propertyViewDaily.count({
     *   where: {
     *     // ... the filter for the PropertyViewDailies we want to count
     *   }
     * })
    **/
    count<T extends PropertyViewDailyCountArgs>(
      args?: Subset<T, PropertyViewDailyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyViewDailyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyViewDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewDailyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyViewDailyAggregateArgs>(args: Subset<T, PropertyViewDailyAggregateArgs>): Prisma.PrismaPromise<GetPropertyViewDailyAggregateType<T>>

    /**
     * Group by PropertyViewDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewDailyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyViewDailyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyViewDailyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyViewDailyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyViewDailyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyViewDailyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyViewDaily model
   */
  readonly fields: PropertyViewDailyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyViewDaily.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyViewDailyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyViewDaily model
   */
  interface PropertyViewDailyFieldRefs {
    readonly id: FieldRef<"PropertyViewDaily", 'String'>
    readonly propertyId: FieldRef<"PropertyViewDaily", 'String'>
    readonly viewDate: FieldRef<"PropertyViewDaily", 'DateTime'>
    readonly totalViews: FieldRef<"PropertyViewDaily", 'Int'>
    readonly uniqueUsers: FieldRef<"PropertyViewDaily", 'Int'>
    readonly avgDurationSeconds: FieldRef<"PropertyViewDaily", 'Decimal'>
    readonly createdAt: FieldRef<"PropertyViewDaily", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyViewDaily findUnique
   */
  export type PropertyViewDailyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyViewDaily
     */
    select?: PropertyViewDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyViewDaily
     */
    omit?: PropertyViewDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewDailyInclude<ExtArgs> | null
    /**
     * Filter, which PropertyViewDaily to fetch.
     */
    where: PropertyViewDailyWhereUniqueInput
  }

  /**
   * PropertyViewDaily findUniqueOrThrow
   */
  export type PropertyViewDailyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyViewDaily
     */
    select?: PropertyViewDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyViewDaily
     */
    omit?: PropertyViewDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewDailyInclude<ExtArgs> | null
    /**
     * Filter, which PropertyViewDaily to fetch.
     */
    where: PropertyViewDailyWhereUniqueInput
  }

  /**
   * PropertyViewDaily findFirst
   */
  export type PropertyViewDailyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyViewDaily
     */
    select?: PropertyViewDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyViewDaily
     */
    omit?: PropertyViewDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewDailyInclude<ExtArgs> | null
    /**
     * Filter, which PropertyViewDaily to fetch.
     */
    where?: PropertyViewDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViewDailies to fetch.
     */
    orderBy?: PropertyViewDailyOrderByWithRelationInput | PropertyViewDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyViewDailies.
     */
    cursor?: PropertyViewDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViewDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViewDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyViewDailies.
     */
    distinct?: PropertyViewDailyScalarFieldEnum | PropertyViewDailyScalarFieldEnum[]
  }

  /**
   * PropertyViewDaily findFirstOrThrow
   */
  export type PropertyViewDailyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyViewDaily
     */
    select?: PropertyViewDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyViewDaily
     */
    omit?: PropertyViewDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewDailyInclude<ExtArgs> | null
    /**
     * Filter, which PropertyViewDaily to fetch.
     */
    where?: PropertyViewDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViewDailies to fetch.
     */
    orderBy?: PropertyViewDailyOrderByWithRelationInput | PropertyViewDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyViewDailies.
     */
    cursor?: PropertyViewDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViewDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViewDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyViewDailies.
     */
    distinct?: PropertyViewDailyScalarFieldEnum | PropertyViewDailyScalarFieldEnum[]
  }

  /**
   * PropertyViewDaily findMany
   */
  export type PropertyViewDailyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyViewDaily
     */
    select?: PropertyViewDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyViewDaily
     */
    omit?: PropertyViewDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewDailyInclude<ExtArgs> | null
    /**
     * Filter, which PropertyViewDailies to fetch.
     */
    where?: PropertyViewDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViewDailies to fetch.
     */
    orderBy?: PropertyViewDailyOrderByWithRelationInput | PropertyViewDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyViewDailies.
     */
    cursor?: PropertyViewDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViewDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViewDailies.
     */
    skip?: number
    distinct?: PropertyViewDailyScalarFieldEnum | PropertyViewDailyScalarFieldEnum[]
  }

  /**
   * PropertyViewDaily create
   */
  export type PropertyViewDailyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyViewDaily
     */
    select?: PropertyViewDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyViewDaily
     */
    omit?: PropertyViewDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewDailyInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyViewDaily.
     */
    data: XOR<PropertyViewDailyCreateInput, PropertyViewDailyUncheckedCreateInput>
  }

  /**
   * PropertyViewDaily createMany
   */
  export type PropertyViewDailyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyViewDailies.
     */
    data: PropertyViewDailyCreateManyInput | PropertyViewDailyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyViewDaily createManyAndReturn
   */
  export type PropertyViewDailyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyViewDaily
     */
    select?: PropertyViewDailySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyViewDaily
     */
    omit?: PropertyViewDailyOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyViewDailies.
     */
    data: PropertyViewDailyCreateManyInput | PropertyViewDailyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewDailyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyViewDaily update
   */
  export type PropertyViewDailyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyViewDaily
     */
    select?: PropertyViewDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyViewDaily
     */
    omit?: PropertyViewDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewDailyInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyViewDaily.
     */
    data: XOR<PropertyViewDailyUpdateInput, PropertyViewDailyUncheckedUpdateInput>
    /**
     * Choose, which PropertyViewDaily to update.
     */
    where: PropertyViewDailyWhereUniqueInput
  }

  /**
   * PropertyViewDaily updateMany
   */
  export type PropertyViewDailyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyViewDailies.
     */
    data: XOR<PropertyViewDailyUpdateManyMutationInput, PropertyViewDailyUncheckedUpdateManyInput>
    /**
     * Filter which PropertyViewDailies to update
     */
    where?: PropertyViewDailyWhereInput
    /**
     * Limit how many PropertyViewDailies to update.
     */
    limit?: number
  }

  /**
   * PropertyViewDaily updateManyAndReturn
   */
  export type PropertyViewDailyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyViewDaily
     */
    select?: PropertyViewDailySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyViewDaily
     */
    omit?: PropertyViewDailyOmit<ExtArgs> | null
    /**
     * The data used to update PropertyViewDailies.
     */
    data: XOR<PropertyViewDailyUpdateManyMutationInput, PropertyViewDailyUncheckedUpdateManyInput>
    /**
     * Filter which PropertyViewDailies to update
     */
    where?: PropertyViewDailyWhereInput
    /**
     * Limit how many PropertyViewDailies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewDailyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyViewDaily upsert
   */
  export type PropertyViewDailyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyViewDaily
     */
    select?: PropertyViewDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyViewDaily
     */
    omit?: PropertyViewDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewDailyInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyViewDaily to update in case it exists.
     */
    where: PropertyViewDailyWhereUniqueInput
    /**
     * In case the PropertyViewDaily found by the `where` argument doesn't exist, create a new PropertyViewDaily with this data.
     */
    create: XOR<PropertyViewDailyCreateInput, PropertyViewDailyUncheckedCreateInput>
    /**
     * In case the PropertyViewDaily was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyViewDailyUpdateInput, PropertyViewDailyUncheckedUpdateInput>
  }

  /**
   * PropertyViewDaily delete
   */
  export type PropertyViewDailyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyViewDaily
     */
    select?: PropertyViewDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyViewDaily
     */
    omit?: PropertyViewDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewDailyInclude<ExtArgs> | null
    /**
     * Filter which PropertyViewDaily to delete.
     */
    where: PropertyViewDailyWhereUniqueInput
  }

  /**
   * PropertyViewDaily deleteMany
   */
  export type PropertyViewDailyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyViewDailies to delete
     */
    where?: PropertyViewDailyWhereInput
    /**
     * Limit how many PropertyViewDailies to delete.
     */
    limit?: number
  }

  /**
   * PropertyViewDaily without action
   */
  export type PropertyViewDailyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyViewDaily
     */
    select?: PropertyViewDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyViewDaily
     */
    omit?: PropertyViewDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewDailyInclude<ExtArgs> | null
  }


  /**
   * Model Inquiry
   */

  export type AggregateInquiry = {
    _count: InquiryCountAggregateOutputType | null
    _avg: InquiryAvgAggregateOutputType | null
    _sum: InquirySumAggregateOutputType | null
    _min: InquiryMinAggregateOutputType | null
    _max: InquiryMaxAggregateOutputType | null
  }

  export type InquiryAvgAggregateOutputType = {
    responseCount: number | null
  }

  export type InquirySumAggregateOutputType = {
    responseCount: number | null
  }

  export type InquiryMinAggregateOutputType = {
    id: string | null
    inquiryNumber: string | null
    targetType: $Enums.TargetType | null
    targetId: string | null
    name: string | null
    furigana: string | null
    email: string | null
    phone: string | null
    companyName: string | null
    inquiryType: $Enums.InquiryType | null
    subject: string | null
    message: string | null
    status: $Enums.InquiryStatus | null
    priority: $Enums.InquiryPriority | null
    userId: string | null
    assignedAgentId: string | null
    assignedAt: Date | null
    responseCount: number | null
    lastRespondedAt: Date | null
    closedAt: Date | null
    closedReason: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InquiryMaxAggregateOutputType = {
    id: string | null
    inquiryNumber: string | null
    targetType: $Enums.TargetType | null
    targetId: string | null
    name: string | null
    furigana: string | null
    email: string | null
    phone: string | null
    companyName: string | null
    inquiryType: $Enums.InquiryType | null
    subject: string | null
    message: string | null
    status: $Enums.InquiryStatus | null
    priority: $Enums.InquiryPriority | null
    userId: string | null
    assignedAgentId: string | null
    assignedAt: Date | null
    responseCount: number | null
    lastRespondedAt: Date | null
    closedAt: Date | null
    closedReason: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InquiryCountAggregateOutputType = {
    id: number
    inquiryNumber: number
    targetType: number
    targetId: number
    name: number
    furigana: number
    email: number
    phone: number
    companyName: number
    inquiryType: number
    subject: number
    message: number
    status: number
    priority: number
    userId: number
    assignedAgentId: number
    assignedAt: number
    responseCount: number
    lastRespondedAt: number
    closedAt: number
    closedReason: number
    source: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InquiryAvgAggregateInputType = {
    responseCount?: true
  }

  export type InquirySumAggregateInputType = {
    responseCount?: true
  }

  export type InquiryMinAggregateInputType = {
    id?: true
    inquiryNumber?: true
    targetType?: true
    targetId?: true
    name?: true
    furigana?: true
    email?: true
    phone?: true
    companyName?: true
    inquiryType?: true
    subject?: true
    message?: true
    status?: true
    priority?: true
    userId?: true
    assignedAgentId?: true
    assignedAt?: true
    responseCount?: true
    lastRespondedAt?: true
    closedAt?: true
    closedReason?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InquiryMaxAggregateInputType = {
    id?: true
    inquiryNumber?: true
    targetType?: true
    targetId?: true
    name?: true
    furigana?: true
    email?: true
    phone?: true
    companyName?: true
    inquiryType?: true
    subject?: true
    message?: true
    status?: true
    priority?: true
    userId?: true
    assignedAgentId?: true
    assignedAt?: true
    responseCount?: true
    lastRespondedAt?: true
    closedAt?: true
    closedReason?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InquiryCountAggregateInputType = {
    id?: true
    inquiryNumber?: true
    targetType?: true
    targetId?: true
    name?: true
    furigana?: true
    email?: true
    phone?: true
    companyName?: true
    inquiryType?: true
    subject?: true
    message?: true
    status?: true
    priority?: true
    userId?: true
    assignedAgentId?: true
    assignedAt?: true
    responseCount?: true
    lastRespondedAt?: true
    closedAt?: true
    closedReason?: true
    source?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InquiryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inquiry to aggregate.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inquiries
    **/
    _count?: true | InquiryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InquiryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InquirySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InquiryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InquiryMaxAggregateInputType
  }

  export type GetInquiryAggregateType<T extends InquiryAggregateArgs> = {
        [P in keyof T & keyof AggregateInquiry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInquiry[P]>
      : GetScalarType<T[P], AggregateInquiry[P]>
  }




  export type InquiryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryWhereInput
    orderBy?: InquiryOrderByWithAggregationInput | InquiryOrderByWithAggregationInput[]
    by: InquiryScalarFieldEnum[] | InquiryScalarFieldEnum
    having?: InquiryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InquiryCountAggregateInputType | true
    _avg?: InquiryAvgAggregateInputType
    _sum?: InquirySumAggregateInputType
    _min?: InquiryMinAggregateInputType
    _max?: InquiryMaxAggregateInputType
  }

  export type InquiryGroupByOutputType = {
    id: string
    inquiryNumber: string
    targetType: $Enums.TargetType
    targetId: string | null
    name: string
    furigana: string | null
    email: string
    phone: string | null
    companyName: string | null
    inquiryType: $Enums.InquiryType
    subject: string | null
    message: string
    status: $Enums.InquiryStatus
    priority: $Enums.InquiryPriority
    userId: string | null
    assignedAgentId: string | null
    assignedAt: Date | null
    responseCount: number
    lastRespondedAt: Date | null
    closedAt: Date | null
    closedReason: string | null
    source: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: InquiryCountAggregateOutputType | null
    _avg: InquiryAvgAggregateOutputType | null
    _sum: InquirySumAggregateOutputType | null
    _min: InquiryMinAggregateOutputType | null
    _max: InquiryMaxAggregateOutputType | null
  }

  type GetInquiryGroupByPayload<T extends InquiryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InquiryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InquiryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InquiryGroupByOutputType[P]>
            : GetScalarType<T[P], InquiryGroupByOutputType[P]>
        }
      >
    >


  export type InquirySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inquiryNumber?: boolean
    targetType?: boolean
    targetId?: boolean
    name?: boolean
    furigana?: boolean
    email?: boolean
    phone?: boolean
    companyName?: boolean
    inquiryType?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    priority?: boolean
    userId?: boolean
    assignedAgentId?: boolean
    assignedAt?: boolean
    responseCount?: boolean
    lastRespondedAt?: boolean
    closedAt?: boolean
    closedReason?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Inquiry$userArgs<ExtArgs>
    assignedAgent?: boolean | Inquiry$assignedAgentArgs<ExtArgs>
    property?: boolean | Inquiry$propertyArgs<ExtArgs>
    messages?: boolean | Inquiry$messagesArgs<ExtArgs>
    _count?: boolean | InquiryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inquiry"]>

  export type InquirySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inquiryNumber?: boolean
    targetType?: boolean
    targetId?: boolean
    name?: boolean
    furigana?: boolean
    email?: boolean
    phone?: boolean
    companyName?: boolean
    inquiryType?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    priority?: boolean
    userId?: boolean
    assignedAgentId?: boolean
    assignedAt?: boolean
    responseCount?: boolean
    lastRespondedAt?: boolean
    closedAt?: boolean
    closedReason?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Inquiry$userArgs<ExtArgs>
    assignedAgent?: boolean | Inquiry$assignedAgentArgs<ExtArgs>
    property?: boolean | Inquiry$propertyArgs<ExtArgs>
  }, ExtArgs["result"]["inquiry"]>

  export type InquirySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inquiryNumber?: boolean
    targetType?: boolean
    targetId?: boolean
    name?: boolean
    furigana?: boolean
    email?: boolean
    phone?: boolean
    companyName?: boolean
    inquiryType?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    priority?: boolean
    userId?: boolean
    assignedAgentId?: boolean
    assignedAt?: boolean
    responseCount?: boolean
    lastRespondedAt?: boolean
    closedAt?: boolean
    closedReason?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Inquiry$userArgs<ExtArgs>
    assignedAgent?: boolean | Inquiry$assignedAgentArgs<ExtArgs>
    property?: boolean | Inquiry$propertyArgs<ExtArgs>
  }, ExtArgs["result"]["inquiry"]>

  export type InquirySelectScalar = {
    id?: boolean
    inquiryNumber?: boolean
    targetType?: boolean
    targetId?: boolean
    name?: boolean
    furigana?: boolean
    email?: boolean
    phone?: boolean
    companyName?: boolean
    inquiryType?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    priority?: boolean
    userId?: boolean
    assignedAgentId?: boolean
    assignedAt?: boolean
    responseCount?: boolean
    lastRespondedAt?: boolean
    closedAt?: boolean
    closedReason?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InquiryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inquiryNumber" | "targetType" | "targetId" | "name" | "furigana" | "email" | "phone" | "companyName" | "inquiryType" | "subject" | "message" | "status" | "priority" | "userId" | "assignedAgentId" | "assignedAt" | "responseCount" | "lastRespondedAt" | "closedAt" | "closedReason" | "source" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["inquiry"]>
  export type InquiryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Inquiry$userArgs<ExtArgs>
    assignedAgent?: boolean | Inquiry$assignedAgentArgs<ExtArgs>
    property?: boolean | Inquiry$propertyArgs<ExtArgs>
    messages?: boolean | Inquiry$messagesArgs<ExtArgs>
    _count?: boolean | InquiryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InquiryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Inquiry$userArgs<ExtArgs>
    assignedAgent?: boolean | Inquiry$assignedAgentArgs<ExtArgs>
    property?: boolean | Inquiry$propertyArgs<ExtArgs>
  }
  export type InquiryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Inquiry$userArgs<ExtArgs>
    assignedAgent?: boolean | Inquiry$assignedAgentArgs<ExtArgs>
    property?: boolean | Inquiry$propertyArgs<ExtArgs>
  }

  export type $InquiryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inquiry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      assignedAgent: Prisma.$AgentPayload<ExtArgs> | null
      property: Prisma.$PropertyPayload<ExtArgs> | null
      messages: Prisma.$InquiryMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inquiryNumber: string
      targetType: $Enums.TargetType
      targetId: string | null
      name: string
      furigana: string | null
      email: string
      phone: string | null
      companyName: string | null
      inquiryType: $Enums.InquiryType
      subject: string | null
      message: string
      status: $Enums.InquiryStatus
      priority: $Enums.InquiryPriority
      userId: string | null
      assignedAgentId: string | null
      assignedAt: Date | null
      responseCount: number
      lastRespondedAt: Date | null
      closedAt: Date | null
      closedReason: string | null
      source: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inquiry"]>
    composites: {}
  }

  type InquiryGetPayload<S extends boolean | null | undefined | InquiryDefaultArgs> = $Result.GetResult<Prisma.$InquiryPayload, S>

  type InquiryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InquiryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InquiryCountAggregateInputType | true
    }

  export interface InquiryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inquiry'], meta: { name: 'Inquiry' } }
    /**
     * Find zero or one Inquiry that matches the filter.
     * @param {InquiryFindUniqueArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InquiryFindUniqueArgs>(args: SelectSubset<T, InquiryFindUniqueArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inquiry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InquiryFindUniqueOrThrowArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InquiryFindUniqueOrThrowArgs>(args: SelectSubset<T, InquiryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inquiry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindFirstArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InquiryFindFirstArgs>(args?: SelectSubset<T, InquiryFindFirstArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inquiry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindFirstOrThrowArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InquiryFindFirstOrThrowArgs>(args?: SelectSubset<T, InquiryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inquiries
     * const inquiries = await prisma.inquiry.findMany()
     * 
     * // Get first 10 Inquiries
     * const inquiries = await prisma.inquiry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inquiryWithIdOnly = await prisma.inquiry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InquiryFindManyArgs>(args?: SelectSubset<T, InquiryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inquiry.
     * @param {InquiryCreateArgs} args - Arguments to create a Inquiry.
     * @example
     * // Create one Inquiry
     * const Inquiry = await prisma.inquiry.create({
     *   data: {
     *     // ... data to create a Inquiry
     *   }
     * })
     * 
     */
    create<T extends InquiryCreateArgs>(args: SelectSubset<T, InquiryCreateArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inquiries.
     * @param {InquiryCreateManyArgs} args - Arguments to create many Inquiries.
     * @example
     * // Create many Inquiries
     * const inquiry = await prisma.inquiry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InquiryCreateManyArgs>(args?: SelectSubset<T, InquiryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inquiries and returns the data saved in the database.
     * @param {InquiryCreateManyAndReturnArgs} args - Arguments to create many Inquiries.
     * @example
     * // Create many Inquiries
     * const inquiry = await prisma.inquiry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inquiries and only return the `id`
     * const inquiryWithIdOnly = await prisma.inquiry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InquiryCreateManyAndReturnArgs>(args?: SelectSubset<T, InquiryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inquiry.
     * @param {InquiryDeleteArgs} args - Arguments to delete one Inquiry.
     * @example
     * // Delete one Inquiry
     * const Inquiry = await prisma.inquiry.delete({
     *   where: {
     *     // ... filter to delete one Inquiry
     *   }
     * })
     * 
     */
    delete<T extends InquiryDeleteArgs>(args: SelectSubset<T, InquiryDeleteArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inquiry.
     * @param {InquiryUpdateArgs} args - Arguments to update one Inquiry.
     * @example
     * // Update one Inquiry
     * const inquiry = await prisma.inquiry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InquiryUpdateArgs>(args: SelectSubset<T, InquiryUpdateArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inquiries.
     * @param {InquiryDeleteManyArgs} args - Arguments to filter Inquiries to delete.
     * @example
     * // Delete a few Inquiries
     * const { count } = await prisma.inquiry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InquiryDeleteManyArgs>(args?: SelectSubset<T, InquiryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inquiries
     * const inquiry = await prisma.inquiry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InquiryUpdateManyArgs>(args: SelectSubset<T, InquiryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inquiries and returns the data updated in the database.
     * @param {InquiryUpdateManyAndReturnArgs} args - Arguments to update many Inquiries.
     * @example
     * // Update many Inquiries
     * const inquiry = await prisma.inquiry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inquiries and only return the `id`
     * const inquiryWithIdOnly = await prisma.inquiry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InquiryUpdateManyAndReturnArgs>(args: SelectSubset<T, InquiryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inquiry.
     * @param {InquiryUpsertArgs} args - Arguments to update or create a Inquiry.
     * @example
     * // Update or create a Inquiry
     * const inquiry = await prisma.inquiry.upsert({
     *   create: {
     *     // ... data to create a Inquiry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inquiry we want to update
     *   }
     * })
     */
    upsert<T extends InquiryUpsertArgs>(args: SelectSubset<T, InquiryUpsertArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryCountArgs} args - Arguments to filter Inquiries to count.
     * @example
     * // Count the number of Inquiries
     * const count = await prisma.inquiry.count({
     *   where: {
     *     // ... the filter for the Inquiries we want to count
     *   }
     * })
    **/
    count<T extends InquiryCountArgs>(
      args?: Subset<T, InquiryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InquiryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InquiryAggregateArgs>(args: Subset<T, InquiryAggregateArgs>): Prisma.PrismaPromise<GetInquiryAggregateType<T>>

    /**
     * Group by Inquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InquiryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InquiryGroupByArgs['orderBy'] }
        : { orderBy?: InquiryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InquiryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInquiryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inquiry model
   */
  readonly fields: InquiryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inquiry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InquiryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Inquiry$userArgs<ExtArgs> = {}>(args?: Subset<T, Inquiry$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignedAgent<T extends Inquiry$assignedAgentArgs<ExtArgs> = {}>(args?: Subset<T, Inquiry$assignedAgentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    property<T extends Inquiry$propertyArgs<ExtArgs> = {}>(args?: Subset<T, Inquiry$propertyArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    messages<T extends Inquiry$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Inquiry$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inquiry model
   */
  interface InquiryFieldRefs {
    readonly id: FieldRef<"Inquiry", 'String'>
    readonly inquiryNumber: FieldRef<"Inquiry", 'String'>
    readonly targetType: FieldRef<"Inquiry", 'TargetType'>
    readonly targetId: FieldRef<"Inquiry", 'String'>
    readonly name: FieldRef<"Inquiry", 'String'>
    readonly furigana: FieldRef<"Inquiry", 'String'>
    readonly email: FieldRef<"Inquiry", 'String'>
    readonly phone: FieldRef<"Inquiry", 'String'>
    readonly companyName: FieldRef<"Inquiry", 'String'>
    readonly inquiryType: FieldRef<"Inquiry", 'InquiryType'>
    readonly subject: FieldRef<"Inquiry", 'String'>
    readonly message: FieldRef<"Inquiry", 'String'>
    readonly status: FieldRef<"Inquiry", 'InquiryStatus'>
    readonly priority: FieldRef<"Inquiry", 'InquiryPriority'>
    readonly userId: FieldRef<"Inquiry", 'String'>
    readonly assignedAgentId: FieldRef<"Inquiry", 'String'>
    readonly assignedAt: FieldRef<"Inquiry", 'DateTime'>
    readonly responseCount: FieldRef<"Inquiry", 'Int'>
    readonly lastRespondedAt: FieldRef<"Inquiry", 'DateTime'>
    readonly closedAt: FieldRef<"Inquiry", 'DateTime'>
    readonly closedReason: FieldRef<"Inquiry", 'String'>
    readonly source: FieldRef<"Inquiry", 'String'>
    readonly metadata: FieldRef<"Inquiry", 'Json'>
    readonly createdAt: FieldRef<"Inquiry", 'DateTime'>
    readonly updatedAt: FieldRef<"Inquiry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inquiry findUnique
   */
  export type InquiryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry findUniqueOrThrow
   */
  export type InquiryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry findFirst
   */
  export type InquiryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inquiries.
     */
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry findFirstOrThrow
   */
  export type InquiryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inquiries.
     */
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry findMany
   */
  export type InquiryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiries to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry create
   */
  export type InquiryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inquiry.
     */
    data: XOR<InquiryCreateInput, InquiryUncheckedCreateInput>
  }

  /**
   * Inquiry createMany
   */
  export type InquiryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inquiries.
     */
    data: InquiryCreateManyInput | InquiryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inquiry createManyAndReturn
   */
  export type InquiryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * The data used to create many Inquiries.
     */
    data: InquiryCreateManyInput | InquiryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inquiry update
   */
  export type InquiryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inquiry.
     */
    data: XOR<InquiryUpdateInput, InquiryUncheckedUpdateInput>
    /**
     * Choose, which Inquiry to update.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry updateMany
   */
  export type InquiryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inquiries.
     */
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyInput>
    /**
     * Filter which Inquiries to update
     */
    where?: InquiryWhereInput
    /**
     * Limit how many Inquiries to update.
     */
    limit?: number
  }

  /**
   * Inquiry updateManyAndReturn
   */
  export type InquiryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * The data used to update Inquiries.
     */
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyInput>
    /**
     * Filter which Inquiries to update
     */
    where?: InquiryWhereInput
    /**
     * Limit how many Inquiries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inquiry upsert
   */
  export type InquiryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inquiry to update in case it exists.
     */
    where: InquiryWhereUniqueInput
    /**
     * In case the Inquiry found by the `where` argument doesn't exist, create a new Inquiry with this data.
     */
    create: XOR<InquiryCreateInput, InquiryUncheckedCreateInput>
    /**
     * In case the Inquiry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InquiryUpdateInput, InquiryUncheckedUpdateInput>
  }

  /**
   * Inquiry delete
   */
  export type InquiryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter which Inquiry to delete.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry deleteMany
   */
  export type InquiryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inquiries to delete
     */
    where?: InquiryWhereInput
    /**
     * Limit how many Inquiries to delete.
     */
    limit?: number
  }

  /**
   * Inquiry.user
   */
  export type Inquiry$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Inquiry.assignedAgent
   */
  export type Inquiry$assignedAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * Inquiry.property
   */
  export type Inquiry$propertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
  }

  /**
   * Inquiry.messages
   */
  export type Inquiry$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryMessage
     */
    select?: InquiryMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryMessage
     */
    omit?: InquiryMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryMessageInclude<ExtArgs> | null
    where?: InquiryMessageWhereInput
    orderBy?: InquiryMessageOrderByWithRelationInput | InquiryMessageOrderByWithRelationInput[]
    cursor?: InquiryMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InquiryMessageScalarFieldEnum | InquiryMessageScalarFieldEnum[]
  }

  /**
   * Inquiry without action
   */
  export type InquiryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
  }


  /**
   * Model InquiryMessage
   */

  export type AggregateInquiryMessage = {
    _count: InquiryMessageCountAggregateOutputType | null
    _min: InquiryMessageMinAggregateOutputType | null
    _max: InquiryMessageMaxAggregateOutputType | null
  }

  export type InquiryMessageMinAggregateOutputType = {
    id: string | null
    inquiryId: string | null
    senderId: string | null
    senderType: $Enums.SenderType | null
    message: string | null
    isInternal: boolean | null
    createdAt: Date | null
  }

  export type InquiryMessageMaxAggregateOutputType = {
    id: string | null
    inquiryId: string | null
    senderId: string | null
    senderType: $Enums.SenderType | null
    message: string | null
    isInternal: boolean | null
    createdAt: Date | null
  }

  export type InquiryMessageCountAggregateOutputType = {
    id: number
    inquiryId: number
    senderId: number
    senderType: number
    message: number
    attachments: number
    isInternal: number
    createdAt: number
    _all: number
  }


  export type InquiryMessageMinAggregateInputType = {
    id?: true
    inquiryId?: true
    senderId?: true
    senderType?: true
    message?: true
    isInternal?: true
    createdAt?: true
  }

  export type InquiryMessageMaxAggregateInputType = {
    id?: true
    inquiryId?: true
    senderId?: true
    senderType?: true
    message?: true
    isInternal?: true
    createdAt?: true
  }

  export type InquiryMessageCountAggregateInputType = {
    id?: true
    inquiryId?: true
    senderId?: true
    senderType?: true
    message?: true
    attachments?: true
    isInternal?: true
    createdAt?: true
    _all?: true
  }

  export type InquiryMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InquiryMessage to aggregate.
     */
    where?: InquiryMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InquiryMessages to fetch.
     */
    orderBy?: InquiryMessageOrderByWithRelationInput | InquiryMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InquiryMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InquiryMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InquiryMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InquiryMessages
    **/
    _count?: true | InquiryMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InquiryMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InquiryMessageMaxAggregateInputType
  }

  export type GetInquiryMessageAggregateType<T extends InquiryMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateInquiryMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInquiryMessage[P]>
      : GetScalarType<T[P], AggregateInquiryMessage[P]>
  }




  export type InquiryMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryMessageWhereInput
    orderBy?: InquiryMessageOrderByWithAggregationInput | InquiryMessageOrderByWithAggregationInput[]
    by: InquiryMessageScalarFieldEnum[] | InquiryMessageScalarFieldEnum
    having?: InquiryMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InquiryMessageCountAggregateInputType | true
    _min?: InquiryMessageMinAggregateInputType
    _max?: InquiryMessageMaxAggregateInputType
  }

  export type InquiryMessageGroupByOutputType = {
    id: string
    inquiryId: string
    senderId: string | null
    senderType: $Enums.SenderType
    message: string
    attachments: JsonValue | null
    isInternal: boolean
    createdAt: Date
    _count: InquiryMessageCountAggregateOutputType | null
    _min: InquiryMessageMinAggregateOutputType | null
    _max: InquiryMessageMaxAggregateOutputType | null
  }

  type GetInquiryMessageGroupByPayload<T extends InquiryMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InquiryMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InquiryMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InquiryMessageGroupByOutputType[P]>
            : GetScalarType<T[P], InquiryMessageGroupByOutputType[P]>
        }
      >
    >


  export type InquiryMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inquiryId?: boolean
    senderId?: boolean
    senderType?: boolean
    message?: boolean
    attachments?: boolean
    isInternal?: boolean
    createdAt?: boolean
    inquiry?: boolean | InquiryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inquiryMessage"]>

  export type InquiryMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inquiryId?: boolean
    senderId?: boolean
    senderType?: boolean
    message?: boolean
    attachments?: boolean
    isInternal?: boolean
    createdAt?: boolean
    inquiry?: boolean | InquiryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inquiryMessage"]>

  export type InquiryMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inquiryId?: boolean
    senderId?: boolean
    senderType?: boolean
    message?: boolean
    attachments?: boolean
    isInternal?: boolean
    createdAt?: boolean
    inquiry?: boolean | InquiryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inquiryMessage"]>

  export type InquiryMessageSelectScalar = {
    id?: boolean
    inquiryId?: boolean
    senderId?: boolean
    senderType?: boolean
    message?: boolean
    attachments?: boolean
    isInternal?: boolean
    createdAt?: boolean
  }

  export type InquiryMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inquiryId" | "senderId" | "senderType" | "message" | "attachments" | "isInternal" | "createdAt", ExtArgs["result"]["inquiryMessage"]>
  export type InquiryMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inquiry?: boolean | InquiryDefaultArgs<ExtArgs>
  }
  export type InquiryMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inquiry?: boolean | InquiryDefaultArgs<ExtArgs>
  }
  export type InquiryMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inquiry?: boolean | InquiryDefaultArgs<ExtArgs>
  }

  export type $InquiryMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InquiryMessage"
    objects: {
      inquiry: Prisma.$InquiryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inquiryId: string
      senderId: string | null
      senderType: $Enums.SenderType
      message: string
      attachments: Prisma.JsonValue | null
      isInternal: boolean
      createdAt: Date
    }, ExtArgs["result"]["inquiryMessage"]>
    composites: {}
  }

  type InquiryMessageGetPayload<S extends boolean | null | undefined | InquiryMessageDefaultArgs> = $Result.GetResult<Prisma.$InquiryMessagePayload, S>

  type InquiryMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InquiryMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InquiryMessageCountAggregateInputType | true
    }

  export interface InquiryMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InquiryMessage'], meta: { name: 'InquiryMessage' } }
    /**
     * Find zero or one InquiryMessage that matches the filter.
     * @param {InquiryMessageFindUniqueArgs} args - Arguments to find a InquiryMessage
     * @example
     * // Get one InquiryMessage
     * const inquiryMessage = await prisma.inquiryMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InquiryMessageFindUniqueArgs>(args: SelectSubset<T, InquiryMessageFindUniqueArgs<ExtArgs>>): Prisma__InquiryMessageClient<$Result.GetResult<Prisma.$InquiryMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InquiryMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InquiryMessageFindUniqueOrThrowArgs} args - Arguments to find a InquiryMessage
     * @example
     * // Get one InquiryMessage
     * const inquiryMessage = await prisma.inquiryMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InquiryMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, InquiryMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InquiryMessageClient<$Result.GetResult<Prisma.$InquiryMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InquiryMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryMessageFindFirstArgs} args - Arguments to find a InquiryMessage
     * @example
     * // Get one InquiryMessage
     * const inquiryMessage = await prisma.inquiryMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InquiryMessageFindFirstArgs>(args?: SelectSubset<T, InquiryMessageFindFirstArgs<ExtArgs>>): Prisma__InquiryMessageClient<$Result.GetResult<Prisma.$InquiryMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InquiryMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryMessageFindFirstOrThrowArgs} args - Arguments to find a InquiryMessage
     * @example
     * // Get one InquiryMessage
     * const inquiryMessage = await prisma.inquiryMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InquiryMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, InquiryMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__InquiryMessageClient<$Result.GetResult<Prisma.$InquiryMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InquiryMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InquiryMessages
     * const inquiryMessages = await prisma.inquiryMessage.findMany()
     * 
     * // Get first 10 InquiryMessages
     * const inquiryMessages = await prisma.inquiryMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inquiryMessageWithIdOnly = await prisma.inquiryMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InquiryMessageFindManyArgs>(args?: SelectSubset<T, InquiryMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InquiryMessage.
     * @param {InquiryMessageCreateArgs} args - Arguments to create a InquiryMessage.
     * @example
     * // Create one InquiryMessage
     * const InquiryMessage = await prisma.inquiryMessage.create({
     *   data: {
     *     // ... data to create a InquiryMessage
     *   }
     * })
     * 
     */
    create<T extends InquiryMessageCreateArgs>(args: SelectSubset<T, InquiryMessageCreateArgs<ExtArgs>>): Prisma__InquiryMessageClient<$Result.GetResult<Prisma.$InquiryMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InquiryMessages.
     * @param {InquiryMessageCreateManyArgs} args - Arguments to create many InquiryMessages.
     * @example
     * // Create many InquiryMessages
     * const inquiryMessage = await prisma.inquiryMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InquiryMessageCreateManyArgs>(args?: SelectSubset<T, InquiryMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InquiryMessages and returns the data saved in the database.
     * @param {InquiryMessageCreateManyAndReturnArgs} args - Arguments to create many InquiryMessages.
     * @example
     * // Create many InquiryMessages
     * const inquiryMessage = await prisma.inquiryMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InquiryMessages and only return the `id`
     * const inquiryMessageWithIdOnly = await prisma.inquiryMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InquiryMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, InquiryMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InquiryMessage.
     * @param {InquiryMessageDeleteArgs} args - Arguments to delete one InquiryMessage.
     * @example
     * // Delete one InquiryMessage
     * const InquiryMessage = await prisma.inquiryMessage.delete({
     *   where: {
     *     // ... filter to delete one InquiryMessage
     *   }
     * })
     * 
     */
    delete<T extends InquiryMessageDeleteArgs>(args: SelectSubset<T, InquiryMessageDeleteArgs<ExtArgs>>): Prisma__InquiryMessageClient<$Result.GetResult<Prisma.$InquiryMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InquiryMessage.
     * @param {InquiryMessageUpdateArgs} args - Arguments to update one InquiryMessage.
     * @example
     * // Update one InquiryMessage
     * const inquiryMessage = await prisma.inquiryMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InquiryMessageUpdateArgs>(args: SelectSubset<T, InquiryMessageUpdateArgs<ExtArgs>>): Prisma__InquiryMessageClient<$Result.GetResult<Prisma.$InquiryMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InquiryMessages.
     * @param {InquiryMessageDeleteManyArgs} args - Arguments to filter InquiryMessages to delete.
     * @example
     * // Delete a few InquiryMessages
     * const { count } = await prisma.inquiryMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InquiryMessageDeleteManyArgs>(args?: SelectSubset<T, InquiryMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InquiryMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InquiryMessages
     * const inquiryMessage = await prisma.inquiryMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InquiryMessageUpdateManyArgs>(args: SelectSubset<T, InquiryMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InquiryMessages and returns the data updated in the database.
     * @param {InquiryMessageUpdateManyAndReturnArgs} args - Arguments to update many InquiryMessages.
     * @example
     * // Update many InquiryMessages
     * const inquiryMessage = await prisma.inquiryMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InquiryMessages and only return the `id`
     * const inquiryMessageWithIdOnly = await prisma.inquiryMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InquiryMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, InquiryMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InquiryMessage.
     * @param {InquiryMessageUpsertArgs} args - Arguments to update or create a InquiryMessage.
     * @example
     * // Update or create a InquiryMessage
     * const inquiryMessage = await prisma.inquiryMessage.upsert({
     *   create: {
     *     // ... data to create a InquiryMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InquiryMessage we want to update
     *   }
     * })
     */
    upsert<T extends InquiryMessageUpsertArgs>(args: SelectSubset<T, InquiryMessageUpsertArgs<ExtArgs>>): Prisma__InquiryMessageClient<$Result.GetResult<Prisma.$InquiryMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InquiryMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryMessageCountArgs} args - Arguments to filter InquiryMessages to count.
     * @example
     * // Count the number of InquiryMessages
     * const count = await prisma.inquiryMessage.count({
     *   where: {
     *     // ... the filter for the InquiryMessages we want to count
     *   }
     * })
    **/
    count<T extends InquiryMessageCountArgs>(
      args?: Subset<T, InquiryMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InquiryMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InquiryMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InquiryMessageAggregateArgs>(args: Subset<T, InquiryMessageAggregateArgs>): Prisma.PrismaPromise<GetInquiryMessageAggregateType<T>>

    /**
     * Group by InquiryMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InquiryMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InquiryMessageGroupByArgs['orderBy'] }
        : { orderBy?: InquiryMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InquiryMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInquiryMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InquiryMessage model
   */
  readonly fields: InquiryMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InquiryMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InquiryMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inquiry<T extends InquiryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InquiryDefaultArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InquiryMessage model
   */
  interface InquiryMessageFieldRefs {
    readonly id: FieldRef<"InquiryMessage", 'String'>
    readonly inquiryId: FieldRef<"InquiryMessage", 'String'>
    readonly senderId: FieldRef<"InquiryMessage", 'String'>
    readonly senderType: FieldRef<"InquiryMessage", 'SenderType'>
    readonly message: FieldRef<"InquiryMessage", 'String'>
    readonly attachments: FieldRef<"InquiryMessage", 'Json'>
    readonly isInternal: FieldRef<"InquiryMessage", 'Boolean'>
    readonly createdAt: FieldRef<"InquiryMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InquiryMessage findUnique
   */
  export type InquiryMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryMessage
     */
    select?: InquiryMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryMessage
     */
    omit?: InquiryMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryMessageInclude<ExtArgs> | null
    /**
     * Filter, which InquiryMessage to fetch.
     */
    where: InquiryMessageWhereUniqueInput
  }

  /**
   * InquiryMessage findUniqueOrThrow
   */
  export type InquiryMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryMessage
     */
    select?: InquiryMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryMessage
     */
    omit?: InquiryMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryMessageInclude<ExtArgs> | null
    /**
     * Filter, which InquiryMessage to fetch.
     */
    where: InquiryMessageWhereUniqueInput
  }

  /**
   * InquiryMessage findFirst
   */
  export type InquiryMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryMessage
     */
    select?: InquiryMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryMessage
     */
    omit?: InquiryMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryMessageInclude<ExtArgs> | null
    /**
     * Filter, which InquiryMessage to fetch.
     */
    where?: InquiryMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InquiryMessages to fetch.
     */
    orderBy?: InquiryMessageOrderByWithRelationInput | InquiryMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InquiryMessages.
     */
    cursor?: InquiryMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InquiryMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InquiryMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InquiryMessages.
     */
    distinct?: InquiryMessageScalarFieldEnum | InquiryMessageScalarFieldEnum[]
  }

  /**
   * InquiryMessage findFirstOrThrow
   */
  export type InquiryMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryMessage
     */
    select?: InquiryMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryMessage
     */
    omit?: InquiryMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryMessageInclude<ExtArgs> | null
    /**
     * Filter, which InquiryMessage to fetch.
     */
    where?: InquiryMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InquiryMessages to fetch.
     */
    orderBy?: InquiryMessageOrderByWithRelationInput | InquiryMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InquiryMessages.
     */
    cursor?: InquiryMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InquiryMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InquiryMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InquiryMessages.
     */
    distinct?: InquiryMessageScalarFieldEnum | InquiryMessageScalarFieldEnum[]
  }

  /**
   * InquiryMessage findMany
   */
  export type InquiryMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryMessage
     */
    select?: InquiryMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryMessage
     */
    omit?: InquiryMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryMessageInclude<ExtArgs> | null
    /**
     * Filter, which InquiryMessages to fetch.
     */
    where?: InquiryMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InquiryMessages to fetch.
     */
    orderBy?: InquiryMessageOrderByWithRelationInput | InquiryMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InquiryMessages.
     */
    cursor?: InquiryMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InquiryMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InquiryMessages.
     */
    skip?: number
    distinct?: InquiryMessageScalarFieldEnum | InquiryMessageScalarFieldEnum[]
  }

  /**
   * InquiryMessage create
   */
  export type InquiryMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryMessage
     */
    select?: InquiryMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryMessage
     */
    omit?: InquiryMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a InquiryMessage.
     */
    data: XOR<InquiryMessageCreateInput, InquiryMessageUncheckedCreateInput>
  }

  /**
   * InquiryMessage createMany
   */
  export type InquiryMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InquiryMessages.
     */
    data: InquiryMessageCreateManyInput | InquiryMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InquiryMessage createManyAndReturn
   */
  export type InquiryMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryMessage
     */
    select?: InquiryMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryMessage
     */
    omit?: InquiryMessageOmit<ExtArgs> | null
    /**
     * The data used to create many InquiryMessages.
     */
    data: InquiryMessageCreateManyInput | InquiryMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InquiryMessage update
   */
  export type InquiryMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryMessage
     */
    select?: InquiryMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryMessage
     */
    omit?: InquiryMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a InquiryMessage.
     */
    data: XOR<InquiryMessageUpdateInput, InquiryMessageUncheckedUpdateInput>
    /**
     * Choose, which InquiryMessage to update.
     */
    where: InquiryMessageWhereUniqueInput
  }

  /**
   * InquiryMessage updateMany
   */
  export type InquiryMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InquiryMessages.
     */
    data: XOR<InquiryMessageUpdateManyMutationInput, InquiryMessageUncheckedUpdateManyInput>
    /**
     * Filter which InquiryMessages to update
     */
    where?: InquiryMessageWhereInput
    /**
     * Limit how many InquiryMessages to update.
     */
    limit?: number
  }

  /**
   * InquiryMessage updateManyAndReturn
   */
  export type InquiryMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryMessage
     */
    select?: InquiryMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryMessage
     */
    omit?: InquiryMessageOmit<ExtArgs> | null
    /**
     * The data used to update InquiryMessages.
     */
    data: XOR<InquiryMessageUpdateManyMutationInput, InquiryMessageUncheckedUpdateManyInput>
    /**
     * Filter which InquiryMessages to update
     */
    where?: InquiryMessageWhereInput
    /**
     * Limit how many InquiryMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InquiryMessage upsert
   */
  export type InquiryMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryMessage
     */
    select?: InquiryMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryMessage
     */
    omit?: InquiryMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the InquiryMessage to update in case it exists.
     */
    where: InquiryMessageWhereUniqueInput
    /**
     * In case the InquiryMessage found by the `where` argument doesn't exist, create a new InquiryMessage with this data.
     */
    create: XOR<InquiryMessageCreateInput, InquiryMessageUncheckedCreateInput>
    /**
     * In case the InquiryMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InquiryMessageUpdateInput, InquiryMessageUncheckedUpdateInput>
  }

  /**
   * InquiryMessage delete
   */
  export type InquiryMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryMessage
     */
    select?: InquiryMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryMessage
     */
    omit?: InquiryMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryMessageInclude<ExtArgs> | null
    /**
     * Filter which InquiryMessage to delete.
     */
    where: InquiryMessageWhereUniqueInput
  }

  /**
   * InquiryMessage deleteMany
   */
  export type InquiryMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InquiryMessages to delete
     */
    where?: InquiryMessageWhereInput
    /**
     * Limit how many InquiryMessages to delete.
     */
    limit?: number
  }

  /**
   * InquiryMessage without action
   */
  export type InquiryMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryMessage
     */
    select?: InquiryMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryMessage
     */
    omit?: InquiryMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryMessageInclude<ExtArgs> | null
  }


  /**
   * Model BulkAssessment
   */

  export type AggregateBulkAssessment = {
    _count: BulkAssessmentCountAggregateOutputType | null
    _avg: BulkAssessmentAvgAggregateOutputType | null
    _sum: BulkAssessmentSumAggregateOutputType | null
    _min: BulkAssessmentMinAggregateOutputType | null
    _max: BulkAssessmentMaxAggregateOutputType | null
  }

  export type BulkAssessmentAvgAggregateOutputType = {
    buildingArea: Decimal | null
    landArea: Decimal | null
    constructionYear: number | null
    agentCount: number | null
    responseCount: number | null
  }

  export type BulkAssessmentSumAggregateOutputType = {
    buildingArea: Decimal | null
    landArea: Decimal | null
    constructionYear: number | null
    agentCount: number | null
    responseCount: number | null
  }

  export type BulkAssessmentMinAggregateOutputType = {
    id: string | null
    assessmentNumber: string | null
    propertyAddress: string | null
    propertyTypeId: string | null
    buildingArea: Decimal | null
    landArea: Decimal | null
    constructionYear: number | null
    ownerName: string | null
    email: string | null
    phone: string | null
    preferredContactMethod: string | null
    preferredContactTime: string | null
    status: $Enums.AssessmentStatus | null
    agentCount: number | null
    responseCount: number | null
    userId: string | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type BulkAssessmentMaxAggregateOutputType = {
    id: string | null
    assessmentNumber: string | null
    propertyAddress: string | null
    propertyTypeId: string | null
    buildingArea: Decimal | null
    landArea: Decimal | null
    constructionYear: number | null
    ownerName: string | null
    email: string | null
    phone: string | null
    preferredContactMethod: string | null
    preferredContactTime: string | null
    status: $Enums.AssessmentStatus | null
    agentCount: number | null
    responseCount: number | null
    userId: string | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type BulkAssessmentCountAggregateOutputType = {
    id: number
    assessmentNumber: number
    propertyAddress: number
    propertyTypeId: number
    buildingArea: number
    landArea: number
    constructionYear: number
    ownerName: number
    email: number
    phone: number
    preferredContactMethod: number
    preferredContactTime: number
    status: number
    agentCount: number
    responseCount: number
    userId: number
    metadata: number
    createdAt: number
    completedAt: number
    _all: number
  }


  export type BulkAssessmentAvgAggregateInputType = {
    buildingArea?: true
    landArea?: true
    constructionYear?: true
    agentCount?: true
    responseCount?: true
  }

  export type BulkAssessmentSumAggregateInputType = {
    buildingArea?: true
    landArea?: true
    constructionYear?: true
    agentCount?: true
    responseCount?: true
  }

  export type BulkAssessmentMinAggregateInputType = {
    id?: true
    assessmentNumber?: true
    propertyAddress?: true
    propertyTypeId?: true
    buildingArea?: true
    landArea?: true
    constructionYear?: true
    ownerName?: true
    email?: true
    phone?: true
    preferredContactMethod?: true
    preferredContactTime?: true
    status?: true
    agentCount?: true
    responseCount?: true
    userId?: true
    createdAt?: true
    completedAt?: true
  }

  export type BulkAssessmentMaxAggregateInputType = {
    id?: true
    assessmentNumber?: true
    propertyAddress?: true
    propertyTypeId?: true
    buildingArea?: true
    landArea?: true
    constructionYear?: true
    ownerName?: true
    email?: true
    phone?: true
    preferredContactMethod?: true
    preferredContactTime?: true
    status?: true
    agentCount?: true
    responseCount?: true
    userId?: true
    createdAt?: true
    completedAt?: true
  }

  export type BulkAssessmentCountAggregateInputType = {
    id?: true
    assessmentNumber?: true
    propertyAddress?: true
    propertyTypeId?: true
    buildingArea?: true
    landArea?: true
    constructionYear?: true
    ownerName?: true
    email?: true
    phone?: true
    preferredContactMethod?: true
    preferredContactTime?: true
    status?: true
    agentCount?: true
    responseCount?: true
    userId?: true
    metadata?: true
    createdAt?: true
    completedAt?: true
    _all?: true
  }

  export type BulkAssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BulkAssessment to aggregate.
     */
    where?: BulkAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkAssessments to fetch.
     */
    orderBy?: BulkAssessmentOrderByWithRelationInput | BulkAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BulkAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BulkAssessments
    **/
    _count?: true | BulkAssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BulkAssessmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BulkAssessmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BulkAssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BulkAssessmentMaxAggregateInputType
  }

  export type GetBulkAssessmentAggregateType<T extends BulkAssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateBulkAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBulkAssessment[P]>
      : GetScalarType<T[P], AggregateBulkAssessment[P]>
  }




  export type BulkAssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BulkAssessmentWhereInput
    orderBy?: BulkAssessmentOrderByWithAggregationInput | BulkAssessmentOrderByWithAggregationInput[]
    by: BulkAssessmentScalarFieldEnum[] | BulkAssessmentScalarFieldEnum
    having?: BulkAssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BulkAssessmentCountAggregateInputType | true
    _avg?: BulkAssessmentAvgAggregateInputType
    _sum?: BulkAssessmentSumAggregateInputType
    _min?: BulkAssessmentMinAggregateInputType
    _max?: BulkAssessmentMaxAggregateInputType
  }

  export type BulkAssessmentGroupByOutputType = {
    id: string
    assessmentNumber: string
    propertyAddress: string
    propertyTypeId: string | null
    buildingArea: Decimal | null
    landArea: Decimal | null
    constructionYear: number | null
    ownerName: string
    email: string
    phone: string | null
    preferredContactMethod: string | null
    preferredContactTime: string | null
    status: $Enums.AssessmentStatus
    agentCount: number
    responseCount: number
    userId: string | null
    metadata: JsonValue | null
    createdAt: Date
    completedAt: Date | null
    _count: BulkAssessmentCountAggregateOutputType | null
    _avg: BulkAssessmentAvgAggregateOutputType | null
    _sum: BulkAssessmentSumAggregateOutputType | null
    _min: BulkAssessmentMinAggregateOutputType | null
    _max: BulkAssessmentMaxAggregateOutputType | null
  }

  type GetBulkAssessmentGroupByPayload<T extends BulkAssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BulkAssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BulkAssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BulkAssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], BulkAssessmentGroupByOutputType[P]>
        }
      >
    >


  export type BulkAssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assessmentNumber?: boolean
    propertyAddress?: boolean
    propertyTypeId?: boolean
    buildingArea?: boolean
    landArea?: boolean
    constructionYear?: boolean
    ownerName?: boolean
    email?: boolean
    phone?: boolean
    preferredContactMethod?: boolean
    preferredContactTime?: boolean
    status?: boolean
    agentCount?: boolean
    responseCount?: boolean
    userId?: boolean
    metadata?: boolean
    createdAt?: boolean
    completedAt?: boolean
    user?: boolean | BulkAssessment$userArgs<ExtArgs>
    propertyType?: boolean | BulkAssessment$propertyTypeArgs<ExtArgs>
    responses?: boolean | BulkAssessment$responsesArgs<ExtArgs>
    _count?: boolean | BulkAssessmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bulkAssessment"]>

  export type BulkAssessmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assessmentNumber?: boolean
    propertyAddress?: boolean
    propertyTypeId?: boolean
    buildingArea?: boolean
    landArea?: boolean
    constructionYear?: boolean
    ownerName?: boolean
    email?: boolean
    phone?: boolean
    preferredContactMethod?: boolean
    preferredContactTime?: boolean
    status?: boolean
    agentCount?: boolean
    responseCount?: boolean
    userId?: boolean
    metadata?: boolean
    createdAt?: boolean
    completedAt?: boolean
    user?: boolean | BulkAssessment$userArgs<ExtArgs>
    propertyType?: boolean | BulkAssessment$propertyTypeArgs<ExtArgs>
  }, ExtArgs["result"]["bulkAssessment"]>

  export type BulkAssessmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assessmentNumber?: boolean
    propertyAddress?: boolean
    propertyTypeId?: boolean
    buildingArea?: boolean
    landArea?: boolean
    constructionYear?: boolean
    ownerName?: boolean
    email?: boolean
    phone?: boolean
    preferredContactMethod?: boolean
    preferredContactTime?: boolean
    status?: boolean
    agentCount?: boolean
    responseCount?: boolean
    userId?: boolean
    metadata?: boolean
    createdAt?: boolean
    completedAt?: boolean
    user?: boolean | BulkAssessment$userArgs<ExtArgs>
    propertyType?: boolean | BulkAssessment$propertyTypeArgs<ExtArgs>
  }, ExtArgs["result"]["bulkAssessment"]>

  export type BulkAssessmentSelectScalar = {
    id?: boolean
    assessmentNumber?: boolean
    propertyAddress?: boolean
    propertyTypeId?: boolean
    buildingArea?: boolean
    landArea?: boolean
    constructionYear?: boolean
    ownerName?: boolean
    email?: boolean
    phone?: boolean
    preferredContactMethod?: boolean
    preferredContactTime?: boolean
    status?: boolean
    agentCount?: boolean
    responseCount?: boolean
    userId?: boolean
    metadata?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }

  export type BulkAssessmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assessmentNumber" | "propertyAddress" | "propertyTypeId" | "buildingArea" | "landArea" | "constructionYear" | "ownerName" | "email" | "phone" | "preferredContactMethod" | "preferredContactTime" | "status" | "agentCount" | "responseCount" | "userId" | "metadata" | "createdAt" | "completedAt", ExtArgs["result"]["bulkAssessment"]>
  export type BulkAssessmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BulkAssessment$userArgs<ExtArgs>
    propertyType?: boolean | BulkAssessment$propertyTypeArgs<ExtArgs>
    responses?: boolean | BulkAssessment$responsesArgs<ExtArgs>
    _count?: boolean | BulkAssessmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BulkAssessmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BulkAssessment$userArgs<ExtArgs>
    propertyType?: boolean | BulkAssessment$propertyTypeArgs<ExtArgs>
  }
  export type BulkAssessmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BulkAssessment$userArgs<ExtArgs>
    propertyType?: boolean | BulkAssessment$propertyTypeArgs<ExtArgs>
  }

  export type $BulkAssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BulkAssessment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      propertyType: Prisma.$PropertyTypeMasterPayload<ExtArgs> | null
      responses: Prisma.$BulkAssessmentResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assessmentNumber: string
      propertyAddress: string
      propertyTypeId: string | null
      buildingArea: Prisma.Decimal | null
      landArea: Prisma.Decimal | null
      constructionYear: number | null
      ownerName: string
      email: string
      phone: string | null
      preferredContactMethod: string | null
      preferredContactTime: string | null
      status: $Enums.AssessmentStatus
      agentCount: number
      responseCount: number
      userId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["bulkAssessment"]>
    composites: {}
  }

  type BulkAssessmentGetPayload<S extends boolean | null | undefined | BulkAssessmentDefaultArgs> = $Result.GetResult<Prisma.$BulkAssessmentPayload, S>

  type BulkAssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BulkAssessmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BulkAssessmentCountAggregateInputType | true
    }

  export interface BulkAssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BulkAssessment'], meta: { name: 'BulkAssessment' } }
    /**
     * Find zero or one BulkAssessment that matches the filter.
     * @param {BulkAssessmentFindUniqueArgs} args - Arguments to find a BulkAssessment
     * @example
     * // Get one BulkAssessment
     * const bulkAssessment = await prisma.bulkAssessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BulkAssessmentFindUniqueArgs>(args: SelectSubset<T, BulkAssessmentFindUniqueArgs<ExtArgs>>): Prisma__BulkAssessmentClient<$Result.GetResult<Prisma.$BulkAssessmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BulkAssessment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BulkAssessmentFindUniqueOrThrowArgs} args - Arguments to find a BulkAssessment
     * @example
     * // Get one BulkAssessment
     * const bulkAssessment = await prisma.bulkAssessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BulkAssessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, BulkAssessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BulkAssessmentClient<$Result.GetResult<Prisma.$BulkAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BulkAssessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkAssessmentFindFirstArgs} args - Arguments to find a BulkAssessment
     * @example
     * // Get one BulkAssessment
     * const bulkAssessment = await prisma.bulkAssessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BulkAssessmentFindFirstArgs>(args?: SelectSubset<T, BulkAssessmentFindFirstArgs<ExtArgs>>): Prisma__BulkAssessmentClient<$Result.GetResult<Prisma.$BulkAssessmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BulkAssessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkAssessmentFindFirstOrThrowArgs} args - Arguments to find a BulkAssessment
     * @example
     * // Get one BulkAssessment
     * const bulkAssessment = await prisma.bulkAssessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BulkAssessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, BulkAssessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__BulkAssessmentClient<$Result.GetResult<Prisma.$BulkAssessmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BulkAssessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkAssessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BulkAssessments
     * const bulkAssessments = await prisma.bulkAssessment.findMany()
     * 
     * // Get first 10 BulkAssessments
     * const bulkAssessments = await prisma.bulkAssessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bulkAssessmentWithIdOnly = await prisma.bulkAssessment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BulkAssessmentFindManyArgs>(args?: SelectSubset<T, BulkAssessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkAssessmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BulkAssessment.
     * @param {BulkAssessmentCreateArgs} args - Arguments to create a BulkAssessment.
     * @example
     * // Create one BulkAssessment
     * const BulkAssessment = await prisma.bulkAssessment.create({
     *   data: {
     *     // ... data to create a BulkAssessment
     *   }
     * })
     * 
     */
    create<T extends BulkAssessmentCreateArgs>(args: SelectSubset<T, BulkAssessmentCreateArgs<ExtArgs>>): Prisma__BulkAssessmentClient<$Result.GetResult<Prisma.$BulkAssessmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BulkAssessments.
     * @param {BulkAssessmentCreateManyArgs} args - Arguments to create many BulkAssessments.
     * @example
     * // Create many BulkAssessments
     * const bulkAssessment = await prisma.bulkAssessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BulkAssessmentCreateManyArgs>(args?: SelectSubset<T, BulkAssessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BulkAssessments and returns the data saved in the database.
     * @param {BulkAssessmentCreateManyAndReturnArgs} args - Arguments to create many BulkAssessments.
     * @example
     * // Create many BulkAssessments
     * const bulkAssessment = await prisma.bulkAssessment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BulkAssessments and only return the `id`
     * const bulkAssessmentWithIdOnly = await prisma.bulkAssessment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BulkAssessmentCreateManyAndReturnArgs>(args?: SelectSubset<T, BulkAssessmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkAssessmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BulkAssessment.
     * @param {BulkAssessmentDeleteArgs} args - Arguments to delete one BulkAssessment.
     * @example
     * // Delete one BulkAssessment
     * const BulkAssessment = await prisma.bulkAssessment.delete({
     *   where: {
     *     // ... filter to delete one BulkAssessment
     *   }
     * })
     * 
     */
    delete<T extends BulkAssessmentDeleteArgs>(args: SelectSubset<T, BulkAssessmentDeleteArgs<ExtArgs>>): Prisma__BulkAssessmentClient<$Result.GetResult<Prisma.$BulkAssessmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BulkAssessment.
     * @param {BulkAssessmentUpdateArgs} args - Arguments to update one BulkAssessment.
     * @example
     * // Update one BulkAssessment
     * const bulkAssessment = await prisma.bulkAssessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BulkAssessmentUpdateArgs>(args: SelectSubset<T, BulkAssessmentUpdateArgs<ExtArgs>>): Prisma__BulkAssessmentClient<$Result.GetResult<Prisma.$BulkAssessmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BulkAssessments.
     * @param {BulkAssessmentDeleteManyArgs} args - Arguments to filter BulkAssessments to delete.
     * @example
     * // Delete a few BulkAssessments
     * const { count } = await prisma.bulkAssessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BulkAssessmentDeleteManyArgs>(args?: SelectSubset<T, BulkAssessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BulkAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkAssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BulkAssessments
     * const bulkAssessment = await prisma.bulkAssessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BulkAssessmentUpdateManyArgs>(args: SelectSubset<T, BulkAssessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BulkAssessments and returns the data updated in the database.
     * @param {BulkAssessmentUpdateManyAndReturnArgs} args - Arguments to update many BulkAssessments.
     * @example
     * // Update many BulkAssessments
     * const bulkAssessment = await prisma.bulkAssessment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BulkAssessments and only return the `id`
     * const bulkAssessmentWithIdOnly = await prisma.bulkAssessment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BulkAssessmentUpdateManyAndReturnArgs>(args: SelectSubset<T, BulkAssessmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkAssessmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BulkAssessment.
     * @param {BulkAssessmentUpsertArgs} args - Arguments to update or create a BulkAssessment.
     * @example
     * // Update or create a BulkAssessment
     * const bulkAssessment = await prisma.bulkAssessment.upsert({
     *   create: {
     *     // ... data to create a BulkAssessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BulkAssessment we want to update
     *   }
     * })
     */
    upsert<T extends BulkAssessmentUpsertArgs>(args: SelectSubset<T, BulkAssessmentUpsertArgs<ExtArgs>>): Prisma__BulkAssessmentClient<$Result.GetResult<Prisma.$BulkAssessmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BulkAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkAssessmentCountArgs} args - Arguments to filter BulkAssessments to count.
     * @example
     * // Count the number of BulkAssessments
     * const count = await prisma.bulkAssessment.count({
     *   where: {
     *     // ... the filter for the BulkAssessments we want to count
     *   }
     * })
    **/
    count<T extends BulkAssessmentCountArgs>(
      args?: Subset<T, BulkAssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BulkAssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BulkAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkAssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BulkAssessmentAggregateArgs>(args: Subset<T, BulkAssessmentAggregateArgs>): Prisma.PrismaPromise<GetBulkAssessmentAggregateType<T>>

    /**
     * Group by BulkAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkAssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BulkAssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BulkAssessmentGroupByArgs['orderBy'] }
        : { orderBy?: BulkAssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BulkAssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBulkAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BulkAssessment model
   */
  readonly fields: BulkAssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BulkAssessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BulkAssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends BulkAssessment$userArgs<ExtArgs> = {}>(args?: Subset<T, BulkAssessment$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    propertyType<T extends BulkAssessment$propertyTypeArgs<ExtArgs> = {}>(args?: Subset<T, BulkAssessment$propertyTypeArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    responses<T extends BulkAssessment$responsesArgs<ExtArgs> = {}>(args?: Subset<T, BulkAssessment$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkAssessmentResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BulkAssessment model
   */
  interface BulkAssessmentFieldRefs {
    readonly id: FieldRef<"BulkAssessment", 'String'>
    readonly assessmentNumber: FieldRef<"BulkAssessment", 'String'>
    readonly propertyAddress: FieldRef<"BulkAssessment", 'String'>
    readonly propertyTypeId: FieldRef<"BulkAssessment", 'String'>
    readonly buildingArea: FieldRef<"BulkAssessment", 'Decimal'>
    readonly landArea: FieldRef<"BulkAssessment", 'Decimal'>
    readonly constructionYear: FieldRef<"BulkAssessment", 'Int'>
    readonly ownerName: FieldRef<"BulkAssessment", 'String'>
    readonly email: FieldRef<"BulkAssessment", 'String'>
    readonly phone: FieldRef<"BulkAssessment", 'String'>
    readonly preferredContactMethod: FieldRef<"BulkAssessment", 'String'>
    readonly preferredContactTime: FieldRef<"BulkAssessment", 'String'>
    readonly status: FieldRef<"BulkAssessment", 'AssessmentStatus'>
    readonly agentCount: FieldRef<"BulkAssessment", 'Int'>
    readonly responseCount: FieldRef<"BulkAssessment", 'Int'>
    readonly userId: FieldRef<"BulkAssessment", 'String'>
    readonly metadata: FieldRef<"BulkAssessment", 'Json'>
    readonly createdAt: FieldRef<"BulkAssessment", 'DateTime'>
    readonly completedAt: FieldRef<"BulkAssessment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BulkAssessment findUnique
   */
  export type BulkAssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessment
     */
    select?: BulkAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessment
     */
    omit?: BulkAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which BulkAssessment to fetch.
     */
    where: BulkAssessmentWhereUniqueInput
  }

  /**
   * BulkAssessment findUniqueOrThrow
   */
  export type BulkAssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessment
     */
    select?: BulkAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessment
     */
    omit?: BulkAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which BulkAssessment to fetch.
     */
    where: BulkAssessmentWhereUniqueInput
  }

  /**
   * BulkAssessment findFirst
   */
  export type BulkAssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessment
     */
    select?: BulkAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessment
     */
    omit?: BulkAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which BulkAssessment to fetch.
     */
    where?: BulkAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkAssessments to fetch.
     */
    orderBy?: BulkAssessmentOrderByWithRelationInput | BulkAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BulkAssessments.
     */
    cursor?: BulkAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BulkAssessments.
     */
    distinct?: BulkAssessmentScalarFieldEnum | BulkAssessmentScalarFieldEnum[]
  }

  /**
   * BulkAssessment findFirstOrThrow
   */
  export type BulkAssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessment
     */
    select?: BulkAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessment
     */
    omit?: BulkAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which BulkAssessment to fetch.
     */
    where?: BulkAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkAssessments to fetch.
     */
    orderBy?: BulkAssessmentOrderByWithRelationInput | BulkAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BulkAssessments.
     */
    cursor?: BulkAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BulkAssessments.
     */
    distinct?: BulkAssessmentScalarFieldEnum | BulkAssessmentScalarFieldEnum[]
  }

  /**
   * BulkAssessment findMany
   */
  export type BulkAssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessment
     */
    select?: BulkAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessment
     */
    omit?: BulkAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which BulkAssessments to fetch.
     */
    where?: BulkAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkAssessments to fetch.
     */
    orderBy?: BulkAssessmentOrderByWithRelationInput | BulkAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BulkAssessments.
     */
    cursor?: BulkAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkAssessments.
     */
    skip?: number
    distinct?: BulkAssessmentScalarFieldEnum | BulkAssessmentScalarFieldEnum[]
  }

  /**
   * BulkAssessment create
   */
  export type BulkAssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessment
     */
    select?: BulkAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessment
     */
    omit?: BulkAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to create a BulkAssessment.
     */
    data: XOR<BulkAssessmentCreateInput, BulkAssessmentUncheckedCreateInput>
  }

  /**
   * BulkAssessment createMany
   */
  export type BulkAssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BulkAssessments.
     */
    data: BulkAssessmentCreateManyInput | BulkAssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BulkAssessment createManyAndReturn
   */
  export type BulkAssessmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessment
     */
    select?: BulkAssessmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessment
     */
    omit?: BulkAssessmentOmit<ExtArgs> | null
    /**
     * The data used to create many BulkAssessments.
     */
    data: BulkAssessmentCreateManyInput | BulkAssessmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BulkAssessment update
   */
  export type BulkAssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessment
     */
    select?: BulkAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessment
     */
    omit?: BulkAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to update a BulkAssessment.
     */
    data: XOR<BulkAssessmentUpdateInput, BulkAssessmentUncheckedUpdateInput>
    /**
     * Choose, which BulkAssessment to update.
     */
    where: BulkAssessmentWhereUniqueInput
  }

  /**
   * BulkAssessment updateMany
   */
  export type BulkAssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BulkAssessments.
     */
    data: XOR<BulkAssessmentUpdateManyMutationInput, BulkAssessmentUncheckedUpdateManyInput>
    /**
     * Filter which BulkAssessments to update
     */
    where?: BulkAssessmentWhereInput
    /**
     * Limit how many BulkAssessments to update.
     */
    limit?: number
  }

  /**
   * BulkAssessment updateManyAndReturn
   */
  export type BulkAssessmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessment
     */
    select?: BulkAssessmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessment
     */
    omit?: BulkAssessmentOmit<ExtArgs> | null
    /**
     * The data used to update BulkAssessments.
     */
    data: XOR<BulkAssessmentUpdateManyMutationInput, BulkAssessmentUncheckedUpdateManyInput>
    /**
     * Filter which BulkAssessments to update
     */
    where?: BulkAssessmentWhereInput
    /**
     * Limit how many BulkAssessments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BulkAssessment upsert
   */
  export type BulkAssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessment
     */
    select?: BulkAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessment
     */
    omit?: BulkAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentInclude<ExtArgs> | null
    /**
     * The filter to search for the BulkAssessment to update in case it exists.
     */
    where: BulkAssessmentWhereUniqueInput
    /**
     * In case the BulkAssessment found by the `where` argument doesn't exist, create a new BulkAssessment with this data.
     */
    create: XOR<BulkAssessmentCreateInput, BulkAssessmentUncheckedCreateInput>
    /**
     * In case the BulkAssessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BulkAssessmentUpdateInput, BulkAssessmentUncheckedUpdateInput>
  }

  /**
   * BulkAssessment delete
   */
  export type BulkAssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessment
     */
    select?: BulkAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessment
     */
    omit?: BulkAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentInclude<ExtArgs> | null
    /**
     * Filter which BulkAssessment to delete.
     */
    where: BulkAssessmentWhereUniqueInput
  }

  /**
   * BulkAssessment deleteMany
   */
  export type BulkAssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BulkAssessments to delete
     */
    where?: BulkAssessmentWhereInput
    /**
     * Limit how many BulkAssessments to delete.
     */
    limit?: number
  }

  /**
   * BulkAssessment.user
   */
  export type BulkAssessment$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * BulkAssessment.propertyType
   */
  export type BulkAssessment$propertyTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTypeMaster
     */
    omit?: PropertyTypeMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    where?: PropertyTypeMasterWhereInput
  }

  /**
   * BulkAssessment.responses
   */
  export type BulkAssessment$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessmentResponse
     */
    select?: BulkAssessmentResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessmentResponse
     */
    omit?: BulkAssessmentResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentResponseInclude<ExtArgs> | null
    where?: BulkAssessmentResponseWhereInput
    orderBy?: BulkAssessmentResponseOrderByWithRelationInput | BulkAssessmentResponseOrderByWithRelationInput[]
    cursor?: BulkAssessmentResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BulkAssessmentResponseScalarFieldEnum | BulkAssessmentResponseScalarFieldEnum[]
  }

  /**
   * BulkAssessment without action
   */
  export type BulkAssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessment
     */
    select?: BulkAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessment
     */
    omit?: BulkAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentInclude<ExtArgs> | null
  }


  /**
   * Model BulkAssessmentResponse
   */

  export type AggregateBulkAssessmentResponse = {
    _count: BulkAssessmentResponseCountAggregateOutputType | null
    _avg: BulkAssessmentResponseAvgAggregateOutputType | null
    _sum: BulkAssessmentResponseSumAggregateOutputType | null
    _min: BulkAssessmentResponseMinAggregateOutputType | null
    _max: BulkAssessmentResponseMaxAggregateOutputType | null
  }

  export type BulkAssessmentResponseAvgAggregateOutputType = {
    assessedPrice: number | null
    priceRangeMin: number | null
    priceRangeMax: number | null
  }

  export type BulkAssessmentResponseSumAggregateOutputType = {
    assessedPrice: bigint | null
    priceRangeMin: bigint | null
    priceRangeMax: bigint | null
  }

  export type BulkAssessmentResponseMinAggregateOutputType = {
    id: string | null
    assessmentId: string | null
    agentId: string | null
    assessedPrice: bigint | null
    priceRangeMin: bigint | null
    priceRangeMax: bigint | null
    comments: string | null
    proposalDocument: string | null
    status: $Enums.ResponseStatus | null
    submittedAt: Date | null
    viewedAt: Date | null
    createdAt: Date | null
  }

  export type BulkAssessmentResponseMaxAggregateOutputType = {
    id: string | null
    assessmentId: string | null
    agentId: string | null
    assessedPrice: bigint | null
    priceRangeMin: bigint | null
    priceRangeMax: bigint | null
    comments: string | null
    proposalDocument: string | null
    status: $Enums.ResponseStatus | null
    submittedAt: Date | null
    viewedAt: Date | null
    createdAt: Date | null
  }

  export type BulkAssessmentResponseCountAggregateOutputType = {
    id: number
    assessmentId: number
    agentId: number
    assessedPrice: number
    priceRangeMin: number
    priceRangeMax: number
    comments: number
    proposalDocument: number
    status: number
    submittedAt: number
    viewedAt: number
    createdAt: number
    _all: number
  }


  export type BulkAssessmentResponseAvgAggregateInputType = {
    assessedPrice?: true
    priceRangeMin?: true
    priceRangeMax?: true
  }

  export type BulkAssessmentResponseSumAggregateInputType = {
    assessedPrice?: true
    priceRangeMin?: true
    priceRangeMax?: true
  }

  export type BulkAssessmentResponseMinAggregateInputType = {
    id?: true
    assessmentId?: true
    agentId?: true
    assessedPrice?: true
    priceRangeMin?: true
    priceRangeMax?: true
    comments?: true
    proposalDocument?: true
    status?: true
    submittedAt?: true
    viewedAt?: true
    createdAt?: true
  }

  export type BulkAssessmentResponseMaxAggregateInputType = {
    id?: true
    assessmentId?: true
    agentId?: true
    assessedPrice?: true
    priceRangeMin?: true
    priceRangeMax?: true
    comments?: true
    proposalDocument?: true
    status?: true
    submittedAt?: true
    viewedAt?: true
    createdAt?: true
  }

  export type BulkAssessmentResponseCountAggregateInputType = {
    id?: true
    assessmentId?: true
    agentId?: true
    assessedPrice?: true
    priceRangeMin?: true
    priceRangeMax?: true
    comments?: true
    proposalDocument?: true
    status?: true
    submittedAt?: true
    viewedAt?: true
    createdAt?: true
    _all?: true
  }

  export type BulkAssessmentResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BulkAssessmentResponse to aggregate.
     */
    where?: BulkAssessmentResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkAssessmentResponses to fetch.
     */
    orderBy?: BulkAssessmentResponseOrderByWithRelationInput | BulkAssessmentResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BulkAssessmentResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkAssessmentResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkAssessmentResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BulkAssessmentResponses
    **/
    _count?: true | BulkAssessmentResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BulkAssessmentResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BulkAssessmentResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BulkAssessmentResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BulkAssessmentResponseMaxAggregateInputType
  }

  export type GetBulkAssessmentResponseAggregateType<T extends BulkAssessmentResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateBulkAssessmentResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBulkAssessmentResponse[P]>
      : GetScalarType<T[P], AggregateBulkAssessmentResponse[P]>
  }




  export type BulkAssessmentResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BulkAssessmentResponseWhereInput
    orderBy?: BulkAssessmentResponseOrderByWithAggregationInput | BulkAssessmentResponseOrderByWithAggregationInput[]
    by: BulkAssessmentResponseScalarFieldEnum[] | BulkAssessmentResponseScalarFieldEnum
    having?: BulkAssessmentResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BulkAssessmentResponseCountAggregateInputType | true
    _avg?: BulkAssessmentResponseAvgAggregateInputType
    _sum?: BulkAssessmentResponseSumAggregateInputType
    _min?: BulkAssessmentResponseMinAggregateInputType
    _max?: BulkAssessmentResponseMaxAggregateInputType
  }

  export type BulkAssessmentResponseGroupByOutputType = {
    id: string
    assessmentId: string
    agentId: string
    assessedPrice: bigint | null
    priceRangeMin: bigint | null
    priceRangeMax: bigint | null
    comments: string | null
    proposalDocument: string | null
    status: $Enums.ResponseStatus
    submittedAt: Date | null
    viewedAt: Date | null
    createdAt: Date
    _count: BulkAssessmentResponseCountAggregateOutputType | null
    _avg: BulkAssessmentResponseAvgAggregateOutputType | null
    _sum: BulkAssessmentResponseSumAggregateOutputType | null
    _min: BulkAssessmentResponseMinAggregateOutputType | null
    _max: BulkAssessmentResponseMaxAggregateOutputType | null
  }

  type GetBulkAssessmentResponseGroupByPayload<T extends BulkAssessmentResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BulkAssessmentResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BulkAssessmentResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BulkAssessmentResponseGroupByOutputType[P]>
            : GetScalarType<T[P], BulkAssessmentResponseGroupByOutputType[P]>
        }
      >
    >


  export type BulkAssessmentResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assessmentId?: boolean
    agentId?: boolean
    assessedPrice?: boolean
    priceRangeMin?: boolean
    priceRangeMax?: boolean
    comments?: boolean
    proposalDocument?: boolean
    status?: boolean
    submittedAt?: boolean
    viewedAt?: boolean
    createdAt?: boolean
    assessment?: boolean | BulkAssessmentDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bulkAssessmentResponse"]>

  export type BulkAssessmentResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assessmentId?: boolean
    agentId?: boolean
    assessedPrice?: boolean
    priceRangeMin?: boolean
    priceRangeMax?: boolean
    comments?: boolean
    proposalDocument?: boolean
    status?: boolean
    submittedAt?: boolean
    viewedAt?: boolean
    createdAt?: boolean
    assessment?: boolean | BulkAssessmentDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bulkAssessmentResponse"]>

  export type BulkAssessmentResponseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assessmentId?: boolean
    agentId?: boolean
    assessedPrice?: boolean
    priceRangeMin?: boolean
    priceRangeMax?: boolean
    comments?: boolean
    proposalDocument?: boolean
    status?: boolean
    submittedAt?: boolean
    viewedAt?: boolean
    createdAt?: boolean
    assessment?: boolean | BulkAssessmentDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bulkAssessmentResponse"]>

  export type BulkAssessmentResponseSelectScalar = {
    id?: boolean
    assessmentId?: boolean
    agentId?: boolean
    assessedPrice?: boolean
    priceRangeMin?: boolean
    priceRangeMax?: boolean
    comments?: boolean
    proposalDocument?: boolean
    status?: boolean
    submittedAt?: boolean
    viewedAt?: boolean
    createdAt?: boolean
  }

  export type BulkAssessmentResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assessmentId" | "agentId" | "assessedPrice" | "priceRangeMin" | "priceRangeMax" | "comments" | "proposalDocument" | "status" | "submittedAt" | "viewedAt" | "createdAt", ExtArgs["result"]["bulkAssessmentResponse"]>
  export type BulkAssessmentResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assessment?: boolean | BulkAssessmentDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type BulkAssessmentResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assessment?: boolean | BulkAssessmentDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type BulkAssessmentResponseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assessment?: boolean | BulkAssessmentDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $BulkAssessmentResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BulkAssessmentResponse"
    objects: {
      assessment: Prisma.$BulkAssessmentPayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assessmentId: string
      agentId: string
      assessedPrice: bigint | null
      priceRangeMin: bigint | null
      priceRangeMax: bigint | null
      comments: string | null
      proposalDocument: string | null
      status: $Enums.ResponseStatus
      submittedAt: Date | null
      viewedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["bulkAssessmentResponse"]>
    composites: {}
  }

  type BulkAssessmentResponseGetPayload<S extends boolean | null | undefined | BulkAssessmentResponseDefaultArgs> = $Result.GetResult<Prisma.$BulkAssessmentResponsePayload, S>

  type BulkAssessmentResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BulkAssessmentResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BulkAssessmentResponseCountAggregateInputType | true
    }

  export interface BulkAssessmentResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BulkAssessmentResponse'], meta: { name: 'BulkAssessmentResponse' } }
    /**
     * Find zero or one BulkAssessmentResponse that matches the filter.
     * @param {BulkAssessmentResponseFindUniqueArgs} args - Arguments to find a BulkAssessmentResponse
     * @example
     * // Get one BulkAssessmentResponse
     * const bulkAssessmentResponse = await prisma.bulkAssessmentResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BulkAssessmentResponseFindUniqueArgs>(args: SelectSubset<T, BulkAssessmentResponseFindUniqueArgs<ExtArgs>>): Prisma__BulkAssessmentResponseClient<$Result.GetResult<Prisma.$BulkAssessmentResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BulkAssessmentResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BulkAssessmentResponseFindUniqueOrThrowArgs} args - Arguments to find a BulkAssessmentResponse
     * @example
     * // Get one BulkAssessmentResponse
     * const bulkAssessmentResponse = await prisma.bulkAssessmentResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BulkAssessmentResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, BulkAssessmentResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BulkAssessmentResponseClient<$Result.GetResult<Prisma.$BulkAssessmentResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BulkAssessmentResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkAssessmentResponseFindFirstArgs} args - Arguments to find a BulkAssessmentResponse
     * @example
     * // Get one BulkAssessmentResponse
     * const bulkAssessmentResponse = await prisma.bulkAssessmentResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BulkAssessmentResponseFindFirstArgs>(args?: SelectSubset<T, BulkAssessmentResponseFindFirstArgs<ExtArgs>>): Prisma__BulkAssessmentResponseClient<$Result.GetResult<Prisma.$BulkAssessmentResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BulkAssessmentResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkAssessmentResponseFindFirstOrThrowArgs} args - Arguments to find a BulkAssessmentResponse
     * @example
     * // Get one BulkAssessmentResponse
     * const bulkAssessmentResponse = await prisma.bulkAssessmentResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BulkAssessmentResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, BulkAssessmentResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__BulkAssessmentResponseClient<$Result.GetResult<Prisma.$BulkAssessmentResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BulkAssessmentResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkAssessmentResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BulkAssessmentResponses
     * const bulkAssessmentResponses = await prisma.bulkAssessmentResponse.findMany()
     * 
     * // Get first 10 BulkAssessmentResponses
     * const bulkAssessmentResponses = await prisma.bulkAssessmentResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bulkAssessmentResponseWithIdOnly = await prisma.bulkAssessmentResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BulkAssessmentResponseFindManyArgs>(args?: SelectSubset<T, BulkAssessmentResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkAssessmentResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BulkAssessmentResponse.
     * @param {BulkAssessmentResponseCreateArgs} args - Arguments to create a BulkAssessmentResponse.
     * @example
     * // Create one BulkAssessmentResponse
     * const BulkAssessmentResponse = await prisma.bulkAssessmentResponse.create({
     *   data: {
     *     // ... data to create a BulkAssessmentResponse
     *   }
     * })
     * 
     */
    create<T extends BulkAssessmentResponseCreateArgs>(args: SelectSubset<T, BulkAssessmentResponseCreateArgs<ExtArgs>>): Prisma__BulkAssessmentResponseClient<$Result.GetResult<Prisma.$BulkAssessmentResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BulkAssessmentResponses.
     * @param {BulkAssessmentResponseCreateManyArgs} args - Arguments to create many BulkAssessmentResponses.
     * @example
     * // Create many BulkAssessmentResponses
     * const bulkAssessmentResponse = await prisma.bulkAssessmentResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BulkAssessmentResponseCreateManyArgs>(args?: SelectSubset<T, BulkAssessmentResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BulkAssessmentResponses and returns the data saved in the database.
     * @param {BulkAssessmentResponseCreateManyAndReturnArgs} args - Arguments to create many BulkAssessmentResponses.
     * @example
     * // Create many BulkAssessmentResponses
     * const bulkAssessmentResponse = await prisma.bulkAssessmentResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BulkAssessmentResponses and only return the `id`
     * const bulkAssessmentResponseWithIdOnly = await prisma.bulkAssessmentResponse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BulkAssessmentResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, BulkAssessmentResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkAssessmentResponsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BulkAssessmentResponse.
     * @param {BulkAssessmentResponseDeleteArgs} args - Arguments to delete one BulkAssessmentResponse.
     * @example
     * // Delete one BulkAssessmentResponse
     * const BulkAssessmentResponse = await prisma.bulkAssessmentResponse.delete({
     *   where: {
     *     // ... filter to delete one BulkAssessmentResponse
     *   }
     * })
     * 
     */
    delete<T extends BulkAssessmentResponseDeleteArgs>(args: SelectSubset<T, BulkAssessmentResponseDeleteArgs<ExtArgs>>): Prisma__BulkAssessmentResponseClient<$Result.GetResult<Prisma.$BulkAssessmentResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BulkAssessmentResponse.
     * @param {BulkAssessmentResponseUpdateArgs} args - Arguments to update one BulkAssessmentResponse.
     * @example
     * // Update one BulkAssessmentResponse
     * const bulkAssessmentResponse = await prisma.bulkAssessmentResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BulkAssessmentResponseUpdateArgs>(args: SelectSubset<T, BulkAssessmentResponseUpdateArgs<ExtArgs>>): Prisma__BulkAssessmentResponseClient<$Result.GetResult<Prisma.$BulkAssessmentResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BulkAssessmentResponses.
     * @param {BulkAssessmentResponseDeleteManyArgs} args - Arguments to filter BulkAssessmentResponses to delete.
     * @example
     * // Delete a few BulkAssessmentResponses
     * const { count } = await prisma.bulkAssessmentResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BulkAssessmentResponseDeleteManyArgs>(args?: SelectSubset<T, BulkAssessmentResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BulkAssessmentResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkAssessmentResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BulkAssessmentResponses
     * const bulkAssessmentResponse = await prisma.bulkAssessmentResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BulkAssessmentResponseUpdateManyArgs>(args: SelectSubset<T, BulkAssessmentResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BulkAssessmentResponses and returns the data updated in the database.
     * @param {BulkAssessmentResponseUpdateManyAndReturnArgs} args - Arguments to update many BulkAssessmentResponses.
     * @example
     * // Update many BulkAssessmentResponses
     * const bulkAssessmentResponse = await prisma.bulkAssessmentResponse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BulkAssessmentResponses and only return the `id`
     * const bulkAssessmentResponseWithIdOnly = await prisma.bulkAssessmentResponse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BulkAssessmentResponseUpdateManyAndReturnArgs>(args: SelectSubset<T, BulkAssessmentResponseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkAssessmentResponsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BulkAssessmentResponse.
     * @param {BulkAssessmentResponseUpsertArgs} args - Arguments to update or create a BulkAssessmentResponse.
     * @example
     * // Update or create a BulkAssessmentResponse
     * const bulkAssessmentResponse = await prisma.bulkAssessmentResponse.upsert({
     *   create: {
     *     // ... data to create a BulkAssessmentResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BulkAssessmentResponse we want to update
     *   }
     * })
     */
    upsert<T extends BulkAssessmentResponseUpsertArgs>(args: SelectSubset<T, BulkAssessmentResponseUpsertArgs<ExtArgs>>): Prisma__BulkAssessmentResponseClient<$Result.GetResult<Prisma.$BulkAssessmentResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BulkAssessmentResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkAssessmentResponseCountArgs} args - Arguments to filter BulkAssessmentResponses to count.
     * @example
     * // Count the number of BulkAssessmentResponses
     * const count = await prisma.bulkAssessmentResponse.count({
     *   where: {
     *     // ... the filter for the BulkAssessmentResponses we want to count
     *   }
     * })
    **/
    count<T extends BulkAssessmentResponseCountArgs>(
      args?: Subset<T, BulkAssessmentResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BulkAssessmentResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BulkAssessmentResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkAssessmentResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BulkAssessmentResponseAggregateArgs>(args: Subset<T, BulkAssessmentResponseAggregateArgs>): Prisma.PrismaPromise<GetBulkAssessmentResponseAggregateType<T>>

    /**
     * Group by BulkAssessmentResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkAssessmentResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BulkAssessmentResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BulkAssessmentResponseGroupByArgs['orderBy'] }
        : { orderBy?: BulkAssessmentResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BulkAssessmentResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBulkAssessmentResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BulkAssessmentResponse model
   */
  readonly fields: BulkAssessmentResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BulkAssessmentResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BulkAssessmentResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assessment<T extends BulkAssessmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BulkAssessmentDefaultArgs<ExtArgs>>): Prisma__BulkAssessmentClient<$Result.GetResult<Prisma.$BulkAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BulkAssessmentResponse model
   */
  interface BulkAssessmentResponseFieldRefs {
    readonly id: FieldRef<"BulkAssessmentResponse", 'String'>
    readonly assessmentId: FieldRef<"BulkAssessmentResponse", 'String'>
    readonly agentId: FieldRef<"BulkAssessmentResponse", 'String'>
    readonly assessedPrice: FieldRef<"BulkAssessmentResponse", 'BigInt'>
    readonly priceRangeMin: FieldRef<"BulkAssessmentResponse", 'BigInt'>
    readonly priceRangeMax: FieldRef<"BulkAssessmentResponse", 'BigInt'>
    readonly comments: FieldRef<"BulkAssessmentResponse", 'String'>
    readonly proposalDocument: FieldRef<"BulkAssessmentResponse", 'String'>
    readonly status: FieldRef<"BulkAssessmentResponse", 'ResponseStatus'>
    readonly submittedAt: FieldRef<"BulkAssessmentResponse", 'DateTime'>
    readonly viewedAt: FieldRef<"BulkAssessmentResponse", 'DateTime'>
    readonly createdAt: FieldRef<"BulkAssessmentResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BulkAssessmentResponse findUnique
   */
  export type BulkAssessmentResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessmentResponse
     */
    select?: BulkAssessmentResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessmentResponse
     */
    omit?: BulkAssessmentResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentResponseInclude<ExtArgs> | null
    /**
     * Filter, which BulkAssessmentResponse to fetch.
     */
    where: BulkAssessmentResponseWhereUniqueInput
  }

  /**
   * BulkAssessmentResponse findUniqueOrThrow
   */
  export type BulkAssessmentResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessmentResponse
     */
    select?: BulkAssessmentResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessmentResponse
     */
    omit?: BulkAssessmentResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentResponseInclude<ExtArgs> | null
    /**
     * Filter, which BulkAssessmentResponse to fetch.
     */
    where: BulkAssessmentResponseWhereUniqueInput
  }

  /**
   * BulkAssessmentResponse findFirst
   */
  export type BulkAssessmentResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessmentResponse
     */
    select?: BulkAssessmentResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessmentResponse
     */
    omit?: BulkAssessmentResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentResponseInclude<ExtArgs> | null
    /**
     * Filter, which BulkAssessmentResponse to fetch.
     */
    where?: BulkAssessmentResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkAssessmentResponses to fetch.
     */
    orderBy?: BulkAssessmentResponseOrderByWithRelationInput | BulkAssessmentResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BulkAssessmentResponses.
     */
    cursor?: BulkAssessmentResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkAssessmentResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkAssessmentResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BulkAssessmentResponses.
     */
    distinct?: BulkAssessmentResponseScalarFieldEnum | BulkAssessmentResponseScalarFieldEnum[]
  }

  /**
   * BulkAssessmentResponse findFirstOrThrow
   */
  export type BulkAssessmentResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessmentResponse
     */
    select?: BulkAssessmentResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessmentResponse
     */
    omit?: BulkAssessmentResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentResponseInclude<ExtArgs> | null
    /**
     * Filter, which BulkAssessmentResponse to fetch.
     */
    where?: BulkAssessmentResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkAssessmentResponses to fetch.
     */
    orderBy?: BulkAssessmentResponseOrderByWithRelationInput | BulkAssessmentResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BulkAssessmentResponses.
     */
    cursor?: BulkAssessmentResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkAssessmentResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkAssessmentResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BulkAssessmentResponses.
     */
    distinct?: BulkAssessmentResponseScalarFieldEnum | BulkAssessmentResponseScalarFieldEnum[]
  }

  /**
   * BulkAssessmentResponse findMany
   */
  export type BulkAssessmentResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessmentResponse
     */
    select?: BulkAssessmentResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessmentResponse
     */
    omit?: BulkAssessmentResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentResponseInclude<ExtArgs> | null
    /**
     * Filter, which BulkAssessmentResponses to fetch.
     */
    where?: BulkAssessmentResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkAssessmentResponses to fetch.
     */
    orderBy?: BulkAssessmentResponseOrderByWithRelationInput | BulkAssessmentResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BulkAssessmentResponses.
     */
    cursor?: BulkAssessmentResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkAssessmentResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkAssessmentResponses.
     */
    skip?: number
    distinct?: BulkAssessmentResponseScalarFieldEnum | BulkAssessmentResponseScalarFieldEnum[]
  }

  /**
   * BulkAssessmentResponse create
   */
  export type BulkAssessmentResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessmentResponse
     */
    select?: BulkAssessmentResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessmentResponse
     */
    omit?: BulkAssessmentResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a BulkAssessmentResponse.
     */
    data: XOR<BulkAssessmentResponseCreateInput, BulkAssessmentResponseUncheckedCreateInput>
  }

  /**
   * BulkAssessmentResponse createMany
   */
  export type BulkAssessmentResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BulkAssessmentResponses.
     */
    data: BulkAssessmentResponseCreateManyInput | BulkAssessmentResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BulkAssessmentResponse createManyAndReturn
   */
  export type BulkAssessmentResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessmentResponse
     */
    select?: BulkAssessmentResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessmentResponse
     */
    omit?: BulkAssessmentResponseOmit<ExtArgs> | null
    /**
     * The data used to create many BulkAssessmentResponses.
     */
    data: BulkAssessmentResponseCreateManyInput | BulkAssessmentResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BulkAssessmentResponse update
   */
  export type BulkAssessmentResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessmentResponse
     */
    select?: BulkAssessmentResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessmentResponse
     */
    omit?: BulkAssessmentResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a BulkAssessmentResponse.
     */
    data: XOR<BulkAssessmentResponseUpdateInput, BulkAssessmentResponseUncheckedUpdateInput>
    /**
     * Choose, which BulkAssessmentResponse to update.
     */
    where: BulkAssessmentResponseWhereUniqueInput
  }

  /**
   * BulkAssessmentResponse updateMany
   */
  export type BulkAssessmentResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BulkAssessmentResponses.
     */
    data: XOR<BulkAssessmentResponseUpdateManyMutationInput, BulkAssessmentResponseUncheckedUpdateManyInput>
    /**
     * Filter which BulkAssessmentResponses to update
     */
    where?: BulkAssessmentResponseWhereInput
    /**
     * Limit how many BulkAssessmentResponses to update.
     */
    limit?: number
  }

  /**
   * BulkAssessmentResponse updateManyAndReturn
   */
  export type BulkAssessmentResponseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessmentResponse
     */
    select?: BulkAssessmentResponseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessmentResponse
     */
    omit?: BulkAssessmentResponseOmit<ExtArgs> | null
    /**
     * The data used to update BulkAssessmentResponses.
     */
    data: XOR<BulkAssessmentResponseUpdateManyMutationInput, BulkAssessmentResponseUncheckedUpdateManyInput>
    /**
     * Filter which BulkAssessmentResponses to update
     */
    where?: BulkAssessmentResponseWhereInput
    /**
     * Limit how many BulkAssessmentResponses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentResponseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BulkAssessmentResponse upsert
   */
  export type BulkAssessmentResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessmentResponse
     */
    select?: BulkAssessmentResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessmentResponse
     */
    omit?: BulkAssessmentResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the BulkAssessmentResponse to update in case it exists.
     */
    where: BulkAssessmentResponseWhereUniqueInput
    /**
     * In case the BulkAssessmentResponse found by the `where` argument doesn't exist, create a new BulkAssessmentResponse with this data.
     */
    create: XOR<BulkAssessmentResponseCreateInput, BulkAssessmentResponseUncheckedCreateInput>
    /**
     * In case the BulkAssessmentResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BulkAssessmentResponseUpdateInput, BulkAssessmentResponseUncheckedUpdateInput>
  }

  /**
   * BulkAssessmentResponse delete
   */
  export type BulkAssessmentResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessmentResponse
     */
    select?: BulkAssessmentResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessmentResponse
     */
    omit?: BulkAssessmentResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentResponseInclude<ExtArgs> | null
    /**
     * Filter which BulkAssessmentResponse to delete.
     */
    where: BulkAssessmentResponseWhereUniqueInput
  }

  /**
   * BulkAssessmentResponse deleteMany
   */
  export type BulkAssessmentResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BulkAssessmentResponses to delete
     */
    where?: BulkAssessmentResponseWhereInput
    /**
     * Limit how many BulkAssessmentResponses to delete.
     */
    limit?: number
  }

  /**
   * BulkAssessmentResponse without action
   */
  export type BulkAssessmentResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessmentResponse
     */
    select?: BulkAssessmentResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessmentResponse
     */
    omit?: BulkAssessmentResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentResponseInclude<ExtArgs> | null
  }


  /**
   * Model Question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionAvgAggregateOutputType = {
    viewCount: number | null
    answerCount: number | null
  }

  export type QuestionSumAggregateOutputType = {
    viewCount: number | null
    answerCount: number | null
  }

  export type QuestionMinAggregateOutputType = {
    id: string | null
    questionNumber: string | null
    title: string | null
    content: string | null
    categoryId: string | null
    viewCount: number | null
    answerCount: number | null
    status: $Enums.QuestionStatus | null
    authorId: string | null
    bestAnswerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: string | null
    questionNumber: string | null
    title: string | null
    content: string | null
    categoryId: string | null
    viewCount: number | null
    answerCount: number | null
    status: $Enums.QuestionStatus | null
    authorId: string | null
    bestAnswerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    questionNumber: number
    title: number
    content: number
    categoryId: number
    tags: number
    viewCount: number
    answerCount: number
    status: number
    authorId: number
    bestAnswerId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type QuestionAvgAggregateInputType = {
    viewCount?: true
    answerCount?: true
  }

  export type QuestionSumAggregateInputType = {
    viewCount?: true
    answerCount?: true
  }

  export type QuestionMinAggregateInputType = {
    id?: true
    questionNumber?: true
    title?: true
    content?: true
    categoryId?: true
    viewCount?: true
    answerCount?: true
    status?: true
    authorId?: true
    bestAnswerId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    questionNumber?: true
    title?: true
    content?: true
    categoryId?: true
    viewCount?: true
    answerCount?: true
    status?: true
    authorId?: true
    bestAnswerId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    questionNumber?: true
    title?: true
    content?: true
    categoryId?: true
    tags?: true
    viewCount?: true
    answerCount?: true
    status?: true
    authorId?: true
    bestAnswerId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Question to aggregate.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithAggregationInput | QuestionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _avg?: QuestionAvgAggregateInputType
    _sum?: QuestionSumAggregateInputType
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    id: string
    questionNumber: string
    title: string
    content: string
    categoryId: string | null
    tags: string[]
    viewCount: number
    answerCount: number
    status: $Enums.QuestionStatus
    authorId: string
    bestAnswerId: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionNumber?: boolean
    title?: boolean
    content?: boolean
    categoryId?: boolean
    tags?: boolean
    viewCount?: boolean
    answerCount?: boolean
    status?: boolean
    authorId?: boolean
    bestAnswerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | Question$categoryArgs<ExtArgs>
    answers?: boolean | Question$answersArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionNumber?: boolean
    title?: boolean
    content?: boolean
    categoryId?: boolean
    tags?: boolean
    viewCount?: boolean
    answerCount?: boolean
    status?: boolean
    authorId?: boolean
    bestAnswerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | Question$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionNumber?: boolean
    title?: boolean
    content?: boolean
    categoryId?: boolean
    tags?: boolean
    viewCount?: boolean
    answerCount?: boolean
    status?: boolean
    authorId?: boolean
    bestAnswerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | Question$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectScalar = {
    id?: boolean
    questionNumber?: boolean
    title?: boolean
    content?: boolean
    categoryId?: boolean
    tags?: boolean
    viewCount?: boolean
    answerCount?: boolean
    status?: boolean
    authorId?: boolean
    bestAnswerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type QuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionNumber" | "title" | "content" | "categoryId" | "tags" | "viewCount" | "answerCount" | "status" | "authorId" | "bestAnswerId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["question"]>
  export type QuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | Question$categoryArgs<ExtArgs>
    answers?: boolean | Question$answersArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | Question$categoryArgs<ExtArgs>
  }
  export type QuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | Question$categoryArgs<ExtArgs>
  }

  export type $QuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Question"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      category: Prisma.$QuestionCategoryPayload<ExtArgs> | null
      answers: Prisma.$AnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionNumber: string
      title: string
      content: string
      categoryId: string | null
      tags: string[]
      viewCount: number
      answerCount: number
      status: $Enums.QuestionStatus
      authorId: string
      bestAnswerId: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type QuestionGetPayload<S extends boolean | null | undefined | QuestionDefaultArgs> = $Result.GetResult<Prisma.$QuestionPayload, S>

  type QuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface QuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Question'], meta: { name: 'Question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionFindUniqueArgs>(args: SelectSubset<T, QuestionFindUniqueArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionFindFirstArgs>(args?: SelectSubset<T, QuestionFindFirstArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionFindManyArgs>(args?: SelectSubset<T, QuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends QuestionCreateArgs>(args: SelectSubset<T, QuestionCreateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Questions.
     * @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionCreateManyArgs>(args?: SelectSubset<T, QuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {QuestionCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends QuestionDeleteArgs>(args: SelectSubset<T, QuestionDeleteArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionUpdateArgs>(args: SelectSubset<T, QuestionUpdateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionDeleteManyArgs>(args?: SelectSubset<T, QuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionUpdateManyArgs>(args: SelectSubset<T, QuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions and returns the data updated in the database.
     * @param {QuestionUpdateManyAndReturnArgs} args - Arguments to update many Questions.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends QuestionUpsertArgs>(args: SelectSubset<T, QuestionUpsertArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Question model
   */
  readonly fields: QuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends Question$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Question$categoryArgs<ExtArgs>>): Prisma__QuestionCategoryClient<$Result.GetResult<Prisma.$QuestionCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    answers<T extends Question$answersArgs<ExtArgs> = {}>(args?: Subset<T, Question$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Question model
   */
  interface QuestionFieldRefs {
    readonly id: FieldRef<"Question", 'String'>
    readonly questionNumber: FieldRef<"Question", 'String'>
    readonly title: FieldRef<"Question", 'String'>
    readonly content: FieldRef<"Question", 'String'>
    readonly categoryId: FieldRef<"Question", 'String'>
    readonly tags: FieldRef<"Question", 'String[]'>
    readonly viewCount: FieldRef<"Question", 'Int'>
    readonly answerCount: FieldRef<"Question", 'Int'>
    readonly status: FieldRef<"Question", 'QuestionStatus'>
    readonly authorId: FieldRef<"Question", 'String'>
    readonly bestAnswerId: FieldRef<"Question", 'String'>
    readonly createdAt: FieldRef<"Question", 'DateTime'>
    readonly updatedAt: FieldRef<"Question", 'DateTime'>
    readonly deletedAt: FieldRef<"Question", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Question findUnique
   */
  export type QuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findFirst
   */
  export type QuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findMany
   */
  export type QuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question create
   */
  export type QuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a Question.
     */
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }

  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Question createManyAndReturn
   */
  export type QuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question update
   */
  export type QuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a Question.
     */
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
  }

  /**
   * Question updateManyAndReturn
   */
  export type QuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question upsert
   */
  export type QuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the Question to update in case it exists.
     */
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     */
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }

  /**
   * Question delete
   */
  export type QuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter which Question to delete.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to delete.
     */
    limit?: number
  }

  /**
   * Question.category
   */
  export type Question$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     */
    select?: QuestionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionCategory
     */
    omit?: QuestionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCategoryInclude<ExtArgs> | null
    where?: QuestionCategoryWhereInput
  }

  /**
   * Question.answers
   */
  export type Question$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    where?: AnswerWhereInput
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    cursor?: AnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Question without action
   */
  export type QuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
  }


  /**
   * Model Answer
   */

  export type AggregateAnswer = {
    _count: AnswerCountAggregateOutputType | null
    _avg: AnswerAvgAggregateOutputType | null
    _sum: AnswerSumAggregateOutputType | null
    _min: AnswerMinAggregateOutputType | null
    _max: AnswerMaxAggregateOutputType | null
  }

  export type AnswerAvgAggregateOutputType = {
    goodCount: number | null
  }

  export type AnswerSumAggregateOutputType = {
    goodCount: number | null
  }

  export type AnswerMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    content: string | null
    goodCount: number | null
    isBestAnswer: boolean | null
    authorId: string | null
    agentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AnswerMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    content: string | null
    goodCount: number | null
    isBestAnswer: boolean | null
    authorId: string | null
    agentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AnswerCountAggregateOutputType = {
    id: number
    questionId: number
    content: number
    goodCount: number
    isBestAnswer: number
    authorId: number
    agentId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type AnswerAvgAggregateInputType = {
    goodCount?: true
  }

  export type AnswerSumAggregateInputType = {
    goodCount?: true
  }

  export type AnswerMinAggregateInputType = {
    id?: true
    questionId?: true
    content?: true
    goodCount?: true
    isBestAnswer?: true
    authorId?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AnswerMaxAggregateInputType = {
    id?: true
    questionId?: true
    content?: true
    goodCount?: true
    isBestAnswer?: true
    authorId?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AnswerCountAggregateInputType = {
    id?: true
    questionId?: true
    content?: true
    goodCount?: true
    isBestAnswer?: true
    authorId?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type AnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answer to aggregate.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Answers
    **/
    _count?: true | AnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnswerMaxAggregateInputType
  }

  export type GetAnswerAggregateType<T extends AnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswer[P]>
      : GetScalarType<T[P], AggregateAnswer[P]>
  }




  export type AnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswerWhereInput
    orderBy?: AnswerOrderByWithAggregationInput | AnswerOrderByWithAggregationInput[]
    by: AnswerScalarFieldEnum[] | AnswerScalarFieldEnum
    having?: AnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnswerCountAggregateInputType | true
    _avg?: AnswerAvgAggregateInputType
    _sum?: AnswerSumAggregateInputType
    _min?: AnswerMinAggregateInputType
    _max?: AnswerMaxAggregateInputType
  }

  export type AnswerGroupByOutputType = {
    id: string
    questionId: string
    content: string
    goodCount: number
    isBestAnswer: boolean
    authorId: string | null
    agentId: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: AnswerCountAggregateOutputType | null
    _avg: AnswerAvgAggregateOutputType | null
    _sum: AnswerSumAggregateOutputType | null
    _min: AnswerMinAggregateOutputType | null
    _max: AnswerMaxAggregateOutputType | null
  }

  type GetAnswerGroupByPayload<T extends AnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnswerGroupByOutputType[P]>
            : GetScalarType<T[P], AnswerGroupByOutputType[P]>
        }
      >
    >


  export type AnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    content?: boolean
    goodCount?: boolean
    isBestAnswer?: boolean
    authorId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    author?: boolean | Answer$authorArgs<ExtArgs>
    agent?: boolean | Answer$agentArgs<ExtArgs>
  }, ExtArgs["result"]["answer"]>

  export type AnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    content?: boolean
    goodCount?: boolean
    isBestAnswer?: boolean
    authorId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    author?: boolean | Answer$authorArgs<ExtArgs>
    agent?: boolean | Answer$agentArgs<ExtArgs>
  }, ExtArgs["result"]["answer"]>

  export type AnswerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    content?: boolean
    goodCount?: boolean
    isBestAnswer?: boolean
    authorId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    author?: boolean | Answer$authorArgs<ExtArgs>
    agent?: boolean | Answer$agentArgs<ExtArgs>
  }, ExtArgs["result"]["answer"]>

  export type AnswerSelectScalar = {
    id?: boolean
    questionId?: boolean
    content?: boolean
    goodCount?: boolean
    isBestAnswer?: boolean
    authorId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type AnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionId" | "content" | "goodCount" | "isBestAnswer" | "authorId" | "agentId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["answer"]>
  export type AnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    author?: boolean | Answer$authorArgs<ExtArgs>
    agent?: boolean | Answer$agentArgs<ExtArgs>
  }
  export type AnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    author?: boolean | Answer$authorArgs<ExtArgs>
    agent?: boolean | Answer$agentArgs<ExtArgs>
  }
  export type AnswerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    author?: boolean | Answer$authorArgs<ExtArgs>
    agent?: boolean | Answer$agentArgs<ExtArgs>
  }

  export type $AnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Answer"
    objects: {
      question: Prisma.$QuestionPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs> | null
      agent: Prisma.$AgentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionId: string
      content: string
      goodCount: number
      isBestAnswer: boolean
      authorId: string | null
      agentId: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["answer"]>
    composites: {}
  }

  type AnswerGetPayload<S extends boolean | null | undefined | AnswerDefaultArgs> = $Result.GetResult<Prisma.$AnswerPayload, S>

  type AnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnswerCountAggregateInputType | true
    }

  export interface AnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Answer'], meta: { name: 'Answer' } }
    /**
     * Find zero or one Answer that matches the filter.
     * @param {AnswerFindUniqueArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnswerFindUniqueArgs>(args: SelectSubset<T, AnswerFindUniqueArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Answer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnswerFindUniqueOrThrowArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, AnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Answer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindFirstArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnswerFindFirstArgs>(args?: SelectSubset<T, AnswerFindFirstArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Answer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindFirstOrThrowArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, AnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answers
     * const answers = await prisma.answer.findMany()
     * 
     * // Get first 10 Answers
     * const answers = await prisma.answer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const answerWithIdOnly = await prisma.answer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnswerFindManyArgs>(args?: SelectSubset<T, AnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Answer.
     * @param {AnswerCreateArgs} args - Arguments to create a Answer.
     * @example
     * // Create one Answer
     * const Answer = await prisma.answer.create({
     *   data: {
     *     // ... data to create a Answer
     *   }
     * })
     * 
     */
    create<T extends AnswerCreateArgs>(args: SelectSubset<T, AnswerCreateArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Answers.
     * @param {AnswerCreateManyArgs} args - Arguments to create many Answers.
     * @example
     * // Create many Answers
     * const answer = await prisma.answer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnswerCreateManyArgs>(args?: SelectSubset<T, AnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Answers and returns the data saved in the database.
     * @param {AnswerCreateManyAndReturnArgs} args - Arguments to create many Answers.
     * @example
     * // Create many Answers
     * const answer = await prisma.answer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Answers and only return the `id`
     * const answerWithIdOnly = await prisma.answer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, AnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Answer.
     * @param {AnswerDeleteArgs} args - Arguments to delete one Answer.
     * @example
     * // Delete one Answer
     * const Answer = await prisma.answer.delete({
     *   where: {
     *     // ... filter to delete one Answer
     *   }
     * })
     * 
     */
    delete<T extends AnswerDeleteArgs>(args: SelectSubset<T, AnswerDeleteArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Answer.
     * @param {AnswerUpdateArgs} args - Arguments to update one Answer.
     * @example
     * // Update one Answer
     * const answer = await prisma.answer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnswerUpdateArgs>(args: SelectSubset<T, AnswerUpdateArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Answers.
     * @param {AnswerDeleteManyArgs} args - Arguments to filter Answers to delete.
     * @example
     * // Delete a few Answers
     * const { count } = await prisma.answer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnswerDeleteManyArgs>(args?: SelectSubset<T, AnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answers
     * const answer = await prisma.answer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnswerUpdateManyArgs>(args: SelectSubset<T, AnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers and returns the data updated in the database.
     * @param {AnswerUpdateManyAndReturnArgs} args - Arguments to update many Answers.
     * @example
     * // Update many Answers
     * const answer = await prisma.answer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Answers and only return the `id`
     * const answerWithIdOnly = await prisma.answer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnswerUpdateManyAndReturnArgs>(args: SelectSubset<T, AnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Answer.
     * @param {AnswerUpsertArgs} args - Arguments to update or create a Answer.
     * @example
     * // Update or create a Answer
     * const answer = await prisma.answer.upsert({
     *   create: {
     *     // ... data to create a Answer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answer we want to update
     *   }
     * })
     */
    upsert<T extends AnswerUpsertArgs>(args: SelectSubset<T, AnswerUpsertArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerCountArgs} args - Arguments to filter Answers to count.
     * @example
     * // Count the number of Answers
     * const count = await prisma.answer.count({
     *   where: {
     *     // ... the filter for the Answers we want to count
     *   }
     * })
    **/
    count<T extends AnswerCountArgs>(
      args?: Subset<T, AnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnswerAggregateArgs>(args: Subset<T, AnswerAggregateArgs>): Prisma.PrismaPromise<GetAnswerAggregateType<T>>

    /**
     * Group by Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnswerGroupByArgs['orderBy'] }
        : { orderBy?: AnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Answer model
   */
  readonly fields: AnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Answer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends Answer$authorArgs<ExtArgs> = {}>(args?: Subset<T, Answer$authorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    agent<T extends Answer$agentArgs<ExtArgs> = {}>(args?: Subset<T, Answer$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Answer model
   */
  interface AnswerFieldRefs {
    readonly id: FieldRef<"Answer", 'String'>
    readonly questionId: FieldRef<"Answer", 'String'>
    readonly content: FieldRef<"Answer", 'String'>
    readonly goodCount: FieldRef<"Answer", 'Int'>
    readonly isBestAnswer: FieldRef<"Answer", 'Boolean'>
    readonly authorId: FieldRef<"Answer", 'String'>
    readonly agentId: FieldRef<"Answer", 'String'>
    readonly createdAt: FieldRef<"Answer", 'DateTime'>
    readonly updatedAt: FieldRef<"Answer", 'DateTime'>
    readonly deletedAt: FieldRef<"Answer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Answer findUnique
   */
  export type AnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer findUniqueOrThrow
   */
  export type AnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer findFirst
   */
  export type AnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Answer findFirstOrThrow
   */
  export type AnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Answer findMany
   */
  export type AnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Answers.
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Answer create
   */
  export type AnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a Answer.
     */
    data: XOR<AnswerCreateInput, AnswerUncheckedCreateInput>
  }

  /**
   * Answer createMany
   */
  export type AnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Answers.
     */
    data: AnswerCreateManyInput | AnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Answer createManyAndReturn
   */
  export type AnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * The data used to create many Answers.
     */
    data: AnswerCreateManyInput | AnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Answer update
   */
  export type AnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a Answer.
     */
    data: XOR<AnswerUpdateInput, AnswerUncheckedUpdateInput>
    /**
     * Choose, which Answer to update.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer updateMany
   */
  export type AnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Answers.
     */
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyInput>
    /**
     * Filter which Answers to update
     */
    where?: AnswerWhereInput
    /**
     * Limit how many Answers to update.
     */
    limit?: number
  }

  /**
   * Answer updateManyAndReturn
   */
  export type AnswerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * The data used to update Answers.
     */
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyInput>
    /**
     * Filter which Answers to update
     */
    where?: AnswerWhereInput
    /**
     * Limit how many Answers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Answer upsert
   */
  export type AnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the Answer to update in case it exists.
     */
    where: AnswerWhereUniqueInput
    /**
     * In case the Answer found by the `where` argument doesn't exist, create a new Answer with this data.
     */
    create: XOR<AnswerCreateInput, AnswerUncheckedCreateInput>
    /**
     * In case the Answer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnswerUpdateInput, AnswerUncheckedUpdateInput>
  }

  /**
   * Answer delete
   */
  export type AnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter which Answer to delete.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer deleteMany
   */
  export type AnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answers to delete
     */
    where?: AnswerWhereInput
    /**
     * Limit how many Answers to delete.
     */
    limit?: number
  }

  /**
   * Answer.author
   */
  export type Answer$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Answer.agent
   */
  export type Answer$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * Answer without action
   */
  export type AnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
  }


  /**
   * Model FeatureMaster
   */

  export type AggregateFeatureMaster = {
    _count: FeatureMasterCountAggregateOutputType | null
    _avg: FeatureMasterAvgAggregateOutputType | null
    _sum: FeatureMasterSumAggregateOutputType | null
    _min: FeatureMasterMinAggregateOutputType | null
    _max: FeatureMasterMaxAggregateOutputType | null
  }

  export type FeatureMasterAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type FeatureMasterSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type FeatureMasterMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    category: $Enums.FeatureCategory | null
    icon: string | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type FeatureMasterMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    category: $Enums.FeatureCategory | null
    icon: string | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type FeatureMasterCountAggregateOutputType = {
    id: number
    code: number
    name: number
    category: number
    icon: number
    displayOrder: number
    isActive: number
    _all: number
  }


  export type FeatureMasterAvgAggregateInputType = {
    displayOrder?: true
  }

  export type FeatureMasterSumAggregateInputType = {
    displayOrder?: true
  }

  export type FeatureMasterMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    icon?: true
    displayOrder?: true
    isActive?: true
  }

  export type FeatureMasterMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    icon?: true
    displayOrder?: true
    isActive?: true
  }

  export type FeatureMasterCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    icon?: true
    displayOrder?: true
    isActive?: true
    _all?: true
  }

  export type FeatureMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureMaster to aggregate.
     */
    where?: FeatureMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureMasters to fetch.
     */
    orderBy?: FeatureMasterOrderByWithRelationInput | FeatureMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeatureMasters
    **/
    _count?: true | FeatureMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatureMasterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatureMasterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureMasterMaxAggregateInputType
  }

  export type GetFeatureMasterAggregateType<T extends FeatureMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatureMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatureMaster[P]>
      : GetScalarType<T[P], AggregateFeatureMaster[P]>
  }




  export type FeatureMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureMasterWhereInput
    orderBy?: FeatureMasterOrderByWithAggregationInput | FeatureMasterOrderByWithAggregationInput[]
    by: FeatureMasterScalarFieldEnum[] | FeatureMasterScalarFieldEnum
    having?: FeatureMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureMasterCountAggregateInputType | true
    _avg?: FeatureMasterAvgAggregateInputType
    _sum?: FeatureMasterSumAggregateInputType
    _min?: FeatureMasterMinAggregateInputType
    _max?: FeatureMasterMaxAggregateInputType
  }

  export type FeatureMasterGroupByOutputType = {
    id: string
    code: string
    name: string
    category: $Enums.FeatureCategory
    icon: string | null
    displayOrder: number
    isActive: boolean
    _count: FeatureMasterCountAggregateOutputType | null
    _avg: FeatureMasterAvgAggregateOutputType | null
    _sum: FeatureMasterSumAggregateOutputType | null
    _min: FeatureMasterMinAggregateOutputType | null
    _max: FeatureMasterMaxAggregateOutputType | null
  }

  type GetFeatureMasterGroupByPayload<T extends FeatureMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureMasterGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureMasterGroupByOutputType[P]>
        }
      >
    >


  export type FeatureMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    icon?: boolean
    displayOrder?: boolean
    isActive?: boolean
    properties?: boolean | FeatureMaster$propertiesArgs<ExtArgs>
    _count?: boolean | FeatureMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featureMaster"]>

  export type FeatureMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    icon?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["featureMaster"]>

  export type FeatureMasterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    icon?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["featureMaster"]>

  export type FeatureMasterSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    icon?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }

  export type FeatureMasterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "category" | "icon" | "displayOrder" | "isActive", ExtArgs["result"]["featureMaster"]>
  export type FeatureMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | FeatureMaster$propertiesArgs<ExtArgs>
    _count?: boolean | FeatureMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeatureMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FeatureMasterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FeatureMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeatureMaster"
    objects: {
      properties: Prisma.$PropertyFeaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      category: $Enums.FeatureCategory
      icon: string | null
      displayOrder: number
      isActive: boolean
    }, ExtArgs["result"]["featureMaster"]>
    composites: {}
  }

  type FeatureMasterGetPayload<S extends boolean | null | undefined | FeatureMasterDefaultArgs> = $Result.GetResult<Prisma.$FeatureMasterPayload, S>

  type FeatureMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatureMasterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatureMasterCountAggregateInputType | true
    }

  export interface FeatureMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeatureMaster'], meta: { name: 'FeatureMaster' } }
    /**
     * Find zero or one FeatureMaster that matches the filter.
     * @param {FeatureMasterFindUniqueArgs} args - Arguments to find a FeatureMaster
     * @example
     * // Get one FeatureMaster
     * const featureMaster = await prisma.featureMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatureMasterFindUniqueArgs>(args: SelectSubset<T, FeatureMasterFindUniqueArgs<ExtArgs>>): Prisma__FeatureMasterClient<$Result.GetResult<Prisma.$FeatureMasterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeatureMaster that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatureMasterFindUniqueOrThrowArgs} args - Arguments to find a FeatureMaster
     * @example
     * // Get one FeatureMaster
     * const featureMaster = await prisma.featureMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatureMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatureMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatureMasterClient<$Result.GetResult<Prisma.$FeatureMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatureMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureMasterFindFirstArgs} args - Arguments to find a FeatureMaster
     * @example
     * // Get one FeatureMaster
     * const featureMaster = await prisma.featureMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatureMasterFindFirstArgs>(args?: SelectSubset<T, FeatureMasterFindFirstArgs<ExtArgs>>): Prisma__FeatureMasterClient<$Result.GetResult<Prisma.$FeatureMasterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatureMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureMasterFindFirstOrThrowArgs} args - Arguments to find a FeatureMaster
     * @example
     * // Get one FeatureMaster
     * const featureMaster = await prisma.featureMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatureMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatureMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatureMasterClient<$Result.GetResult<Prisma.$FeatureMasterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeatureMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeatureMasters
     * const featureMasters = await prisma.featureMaster.findMany()
     * 
     * // Get first 10 FeatureMasters
     * const featureMasters = await prisma.featureMaster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featureMasterWithIdOnly = await prisma.featureMaster.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeatureMasterFindManyArgs>(args?: SelectSubset<T, FeatureMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeatureMaster.
     * @param {FeatureMasterCreateArgs} args - Arguments to create a FeatureMaster.
     * @example
     * // Create one FeatureMaster
     * const FeatureMaster = await prisma.featureMaster.create({
     *   data: {
     *     // ... data to create a FeatureMaster
     *   }
     * })
     * 
     */
    create<T extends FeatureMasterCreateArgs>(args: SelectSubset<T, FeatureMasterCreateArgs<ExtArgs>>): Prisma__FeatureMasterClient<$Result.GetResult<Prisma.$FeatureMasterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeatureMasters.
     * @param {FeatureMasterCreateManyArgs} args - Arguments to create many FeatureMasters.
     * @example
     * // Create many FeatureMasters
     * const featureMaster = await prisma.featureMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatureMasterCreateManyArgs>(args?: SelectSubset<T, FeatureMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeatureMasters and returns the data saved in the database.
     * @param {FeatureMasterCreateManyAndReturnArgs} args - Arguments to create many FeatureMasters.
     * @example
     * // Create many FeatureMasters
     * const featureMaster = await prisma.featureMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeatureMasters and only return the `id`
     * const featureMasterWithIdOnly = await prisma.featureMaster.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatureMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatureMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureMasterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeatureMaster.
     * @param {FeatureMasterDeleteArgs} args - Arguments to delete one FeatureMaster.
     * @example
     * // Delete one FeatureMaster
     * const FeatureMaster = await prisma.featureMaster.delete({
     *   where: {
     *     // ... filter to delete one FeatureMaster
     *   }
     * })
     * 
     */
    delete<T extends FeatureMasterDeleteArgs>(args: SelectSubset<T, FeatureMasterDeleteArgs<ExtArgs>>): Prisma__FeatureMasterClient<$Result.GetResult<Prisma.$FeatureMasterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeatureMaster.
     * @param {FeatureMasterUpdateArgs} args - Arguments to update one FeatureMaster.
     * @example
     * // Update one FeatureMaster
     * const featureMaster = await prisma.featureMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatureMasterUpdateArgs>(args: SelectSubset<T, FeatureMasterUpdateArgs<ExtArgs>>): Prisma__FeatureMasterClient<$Result.GetResult<Prisma.$FeatureMasterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeatureMasters.
     * @param {FeatureMasterDeleteManyArgs} args - Arguments to filter FeatureMasters to delete.
     * @example
     * // Delete a few FeatureMasters
     * const { count } = await prisma.featureMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatureMasterDeleteManyArgs>(args?: SelectSubset<T, FeatureMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeatureMasters
     * const featureMaster = await prisma.featureMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatureMasterUpdateManyArgs>(args: SelectSubset<T, FeatureMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureMasters and returns the data updated in the database.
     * @param {FeatureMasterUpdateManyAndReturnArgs} args - Arguments to update many FeatureMasters.
     * @example
     * // Update many FeatureMasters
     * const featureMaster = await prisma.featureMaster.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeatureMasters and only return the `id`
     * const featureMasterWithIdOnly = await prisma.featureMaster.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeatureMasterUpdateManyAndReturnArgs>(args: SelectSubset<T, FeatureMasterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureMasterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeatureMaster.
     * @param {FeatureMasterUpsertArgs} args - Arguments to update or create a FeatureMaster.
     * @example
     * // Update or create a FeatureMaster
     * const featureMaster = await prisma.featureMaster.upsert({
     *   create: {
     *     // ... data to create a FeatureMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeatureMaster we want to update
     *   }
     * })
     */
    upsert<T extends FeatureMasterUpsertArgs>(args: SelectSubset<T, FeatureMasterUpsertArgs<ExtArgs>>): Prisma__FeatureMasterClient<$Result.GetResult<Prisma.$FeatureMasterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeatureMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureMasterCountArgs} args - Arguments to filter FeatureMasters to count.
     * @example
     * // Count the number of FeatureMasters
     * const count = await prisma.featureMaster.count({
     *   where: {
     *     // ... the filter for the FeatureMasters we want to count
     *   }
     * })
    **/
    count<T extends FeatureMasterCountArgs>(
      args?: Subset<T, FeatureMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeatureMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureMasterAggregateArgs>(args: Subset<T, FeatureMasterAggregateArgs>): Prisma.PrismaPromise<GetFeatureMasterAggregateType<T>>

    /**
     * Group by FeatureMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureMasterGroupByArgs['orderBy'] }
        : { orderBy?: FeatureMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeatureMaster model
   */
  readonly fields: FeatureMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeatureMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    properties<T extends FeatureMaster$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, FeatureMaster$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeatureMaster model
   */
  interface FeatureMasterFieldRefs {
    readonly id: FieldRef<"FeatureMaster", 'String'>
    readonly code: FieldRef<"FeatureMaster", 'String'>
    readonly name: FieldRef<"FeatureMaster", 'String'>
    readonly category: FieldRef<"FeatureMaster", 'FeatureCategory'>
    readonly icon: FieldRef<"FeatureMaster", 'String'>
    readonly displayOrder: FieldRef<"FeatureMaster", 'Int'>
    readonly isActive: FieldRef<"FeatureMaster", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * FeatureMaster findUnique
   */
  export type FeatureMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureMaster
     */
    select?: FeatureMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureMaster
     */
    omit?: FeatureMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureMasterInclude<ExtArgs> | null
    /**
     * Filter, which FeatureMaster to fetch.
     */
    where: FeatureMasterWhereUniqueInput
  }

  /**
   * FeatureMaster findUniqueOrThrow
   */
  export type FeatureMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureMaster
     */
    select?: FeatureMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureMaster
     */
    omit?: FeatureMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureMasterInclude<ExtArgs> | null
    /**
     * Filter, which FeatureMaster to fetch.
     */
    where: FeatureMasterWhereUniqueInput
  }

  /**
   * FeatureMaster findFirst
   */
  export type FeatureMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureMaster
     */
    select?: FeatureMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureMaster
     */
    omit?: FeatureMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureMasterInclude<ExtArgs> | null
    /**
     * Filter, which FeatureMaster to fetch.
     */
    where?: FeatureMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureMasters to fetch.
     */
    orderBy?: FeatureMasterOrderByWithRelationInput | FeatureMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureMasters.
     */
    cursor?: FeatureMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureMasters.
     */
    distinct?: FeatureMasterScalarFieldEnum | FeatureMasterScalarFieldEnum[]
  }

  /**
   * FeatureMaster findFirstOrThrow
   */
  export type FeatureMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureMaster
     */
    select?: FeatureMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureMaster
     */
    omit?: FeatureMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureMasterInclude<ExtArgs> | null
    /**
     * Filter, which FeatureMaster to fetch.
     */
    where?: FeatureMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureMasters to fetch.
     */
    orderBy?: FeatureMasterOrderByWithRelationInput | FeatureMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureMasters.
     */
    cursor?: FeatureMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureMasters.
     */
    distinct?: FeatureMasterScalarFieldEnum | FeatureMasterScalarFieldEnum[]
  }

  /**
   * FeatureMaster findMany
   */
  export type FeatureMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureMaster
     */
    select?: FeatureMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureMaster
     */
    omit?: FeatureMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureMasterInclude<ExtArgs> | null
    /**
     * Filter, which FeatureMasters to fetch.
     */
    where?: FeatureMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureMasters to fetch.
     */
    orderBy?: FeatureMasterOrderByWithRelationInput | FeatureMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeatureMasters.
     */
    cursor?: FeatureMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureMasters.
     */
    skip?: number
    distinct?: FeatureMasterScalarFieldEnum | FeatureMasterScalarFieldEnum[]
  }

  /**
   * FeatureMaster create
   */
  export type FeatureMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureMaster
     */
    select?: FeatureMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureMaster
     */
    omit?: FeatureMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a FeatureMaster.
     */
    data: XOR<FeatureMasterCreateInput, FeatureMasterUncheckedCreateInput>
  }

  /**
   * FeatureMaster createMany
   */
  export type FeatureMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeatureMasters.
     */
    data: FeatureMasterCreateManyInput | FeatureMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatureMaster createManyAndReturn
   */
  export type FeatureMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureMaster
     */
    select?: FeatureMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureMaster
     */
    omit?: FeatureMasterOmit<ExtArgs> | null
    /**
     * The data used to create many FeatureMasters.
     */
    data: FeatureMasterCreateManyInput | FeatureMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatureMaster update
   */
  export type FeatureMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureMaster
     */
    select?: FeatureMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureMaster
     */
    omit?: FeatureMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a FeatureMaster.
     */
    data: XOR<FeatureMasterUpdateInput, FeatureMasterUncheckedUpdateInput>
    /**
     * Choose, which FeatureMaster to update.
     */
    where: FeatureMasterWhereUniqueInput
  }

  /**
   * FeatureMaster updateMany
   */
  export type FeatureMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeatureMasters.
     */
    data: XOR<FeatureMasterUpdateManyMutationInput, FeatureMasterUncheckedUpdateManyInput>
    /**
     * Filter which FeatureMasters to update
     */
    where?: FeatureMasterWhereInput
    /**
     * Limit how many FeatureMasters to update.
     */
    limit?: number
  }

  /**
   * FeatureMaster updateManyAndReturn
   */
  export type FeatureMasterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureMaster
     */
    select?: FeatureMasterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureMaster
     */
    omit?: FeatureMasterOmit<ExtArgs> | null
    /**
     * The data used to update FeatureMasters.
     */
    data: XOR<FeatureMasterUpdateManyMutationInput, FeatureMasterUncheckedUpdateManyInput>
    /**
     * Filter which FeatureMasters to update
     */
    where?: FeatureMasterWhereInput
    /**
     * Limit how many FeatureMasters to update.
     */
    limit?: number
  }

  /**
   * FeatureMaster upsert
   */
  export type FeatureMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureMaster
     */
    select?: FeatureMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureMaster
     */
    omit?: FeatureMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the FeatureMaster to update in case it exists.
     */
    where: FeatureMasterWhereUniqueInput
    /**
     * In case the FeatureMaster found by the `where` argument doesn't exist, create a new FeatureMaster with this data.
     */
    create: XOR<FeatureMasterCreateInput, FeatureMasterUncheckedCreateInput>
    /**
     * In case the FeatureMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureMasterUpdateInput, FeatureMasterUncheckedUpdateInput>
  }

  /**
   * FeatureMaster delete
   */
  export type FeatureMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureMaster
     */
    select?: FeatureMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureMaster
     */
    omit?: FeatureMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureMasterInclude<ExtArgs> | null
    /**
     * Filter which FeatureMaster to delete.
     */
    where: FeatureMasterWhereUniqueInput
  }

  /**
   * FeatureMaster deleteMany
   */
  export type FeatureMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureMasters to delete
     */
    where?: FeatureMasterWhereInput
    /**
     * Limit how many FeatureMasters to delete.
     */
    limit?: number
  }

  /**
   * FeatureMaster.properties
   */
  export type FeatureMaster$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    where?: PropertyFeatureWhereInput
    orderBy?: PropertyFeatureOrderByWithRelationInput | PropertyFeatureOrderByWithRelationInput[]
    cursor?: PropertyFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyFeatureScalarFieldEnum | PropertyFeatureScalarFieldEnum[]
  }

  /**
   * FeatureMaster without action
   */
  export type FeatureMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureMaster
     */
    select?: FeatureMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureMaster
     */
    omit?: FeatureMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureMasterInclude<ExtArgs> | null
  }


  /**
   * Model RegionMaster
   */

  export type AggregateRegionMaster = {
    _count: RegionMasterCountAggregateOutputType | null
    _avg: RegionMasterAvgAggregateOutputType | null
    _sum: RegionMasterSumAggregateOutputType | null
    _min: RegionMasterMinAggregateOutputType | null
    _max: RegionMasterMaxAggregateOutputType | null
  }

  export type RegionMasterAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type RegionMasterSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type RegionMasterMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type RegionMasterMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type RegionMasterCountAggregateOutputType = {
    id: number
    code: number
    name: number
    displayOrder: number
    isActive: number
    _all: number
  }


  export type RegionMasterAvgAggregateInputType = {
    displayOrder?: true
  }

  export type RegionMasterSumAggregateInputType = {
    displayOrder?: true
  }

  export type RegionMasterMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    displayOrder?: true
    isActive?: true
  }

  export type RegionMasterMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    displayOrder?: true
    isActive?: true
  }

  export type RegionMasterCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    displayOrder?: true
    isActive?: true
    _all?: true
  }

  export type RegionMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegionMaster to aggregate.
     */
    where?: RegionMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionMasters to fetch.
     */
    orderBy?: RegionMasterOrderByWithRelationInput | RegionMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegionMasters
    **/
    _count?: true | RegionMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionMasterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionMasterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMasterMaxAggregateInputType
  }

  export type GetRegionMasterAggregateType<T extends RegionMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateRegionMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegionMaster[P]>
      : GetScalarType<T[P], AggregateRegionMaster[P]>
  }




  export type RegionMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionMasterWhereInput
    orderBy?: RegionMasterOrderByWithAggregationInput | RegionMasterOrderByWithAggregationInput[]
    by: RegionMasterScalarFieldEnum[] | RegionMasterScalarFieldEnum
    having?: RegionMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionMasterCountAggregateInputType | true
    _avg?: RegionMasterAvgAggregateInputType
    _sum?: RegionMasterSumAggregateInputType
    _min?: RegionMasterMinAggregateInputType
    _max?: RegionMasterMaxAggregateInputType
  }

  export type RegionMasterGroupByOutputType = {
    id: string
    code: string
    name: string
    displayOrder: number
    isActive: boolean
    _count: RegionMasterCountAggregateOutputType | null
    _avg: RegionMasterAvgAggregateOutputType | null
    _sum: RegionMasterSumAggregateOutputType | null
    _min: RegionMasterMinAggregateOutputType | null
    _max: RegionMasterMaxAggregateOutputType | null
  }

  type GetRegionMasterGroupByPayload<T extends RegionMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionMasterGroupByOutputType[P]>
            : GetScalarType<T[P], RegionMasterGroupByOutputType[P]>
        }
      >
    >


  export type RegionMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    displayOrder?: boolean
    isActive?: boolean
    areas?: boolean | RegionMaster$areasArgs<ExtArgs>
    _count?: boolean | RegionMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["regionMaster"]>

  export type RegionMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["regionMaster"]>

  export type RegionMasterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["regionMaster"]>

  export type RegionMasterSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }

  export type RegionMasterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "displayOrder" | "isActive", ExtArgs["result"]["regionMaster"]>
  export type RegionMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    areas?: boolean | RegionMaster$areasArgs<ExtArgs>
    _count?: boolean | RegionMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RegionMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RegionMasterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RegionMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RegionMaster"
    objects: {
      areas: Prisma.$AreaMasterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      displayOrder: number
      isActive: boolean
    }, ExtArgs["result"]["regionMaster"]>
    composites: {}
  }

  type RegionMasterGetPayload<S extends boolean | null | undefined | RegionMasterDefaultArgs> = $Result.GetResult<Prisma.$RegionMasterPayload, S>

  type RegionMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegionMasterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegionMasterCountAggregateInputType | true
    }

  export interface RegionMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RegionMaster'], meta: { name: 'RegionMaster' } }
    /**
     * Find zero or one RegionMaster that matches the filter.
     * @param {RegionMasterFindUniqueArgs} args - Arguments to find a RegionMaster
     * @example
     * // Get one RegionMaster
     * const regionMaster = await prisma.regionMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegionMasterFindUniqueArgs>(args: SelectSubset<T, RegionMasterFindUniqueArgs<ExtArgs>>): Prisma__RegionMasterClient<$Result.GetResult<Prisma.$RegionMasterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RegionMaster that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegionMasterFindUniqueOrThrowArgs} args - Arguments to find a RegionMaster
     * @example
     * // Get one RegionMaster
     * const regionMaster = await prisma.regionMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegionMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, RegionMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegionMasterClient<$Result.GetResult<Prisma.$RegionMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegionMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionMasterFindFirstArgs} args - Arguments to find a RegionMaster
     * @example
     * // Get one RegionMaster
     * const regionMaster = await prisma.regionMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegionMasterFindFirstArgs>(args?: SelectSubset<T, RegionMasterFindFirstArgs<ExtArgs>>): Prisma__RegionMasterClient<$Result.GetResult<Prisma.$RegionMasterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegionMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionMasterFindFirstOrThrowArgs} args - Arguments to find a RegionMaster
     * @example
     * // Get one RegionMaster
     * const regionMaster = await prisma.regionMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegionMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, RegionMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegionMasterClient<$Result.GetResult<Prisma.$RegionMasterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RegionMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegionMasters
     * const regionMasters = await prisma.regionMaster.findMany()
     * 
     * // Get first 10 RegionMasters
     * const regionMasters = await prisma.regionMaster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionMasterWithIdOnly = await prisma.regionMaster.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegionMasterFindManyArgs>(args?: SelectSubset<T, RegionMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RegionMaster.
     * @param {RegionMasterCreateArgs} args - Arguments to create a RegionMaster.
     * @example
     * // Create one RegionMaster
     * const RegionMaster = await prisma.regionMaster.create({
     *   data: {
     *     // ... data to create a RegionMaster
     *   }
     * })
     * 
     */
    create<T extends RegionMasterCreateArgs>(args: SelectSubset<T, RegionMasterCreateArgs<ExtArgs>>): Prisma__RegionMasterClient<$Result.GetResult<Prisma.$RegionMasterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RegionMasters.
     * @param {RegionMasterCreateManyArgs} args - Arguments to create many RegionMasters.
     * @example
     * // Create many RegionMasters
     * const regionMaster = await prisma.regionMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegionMasterCreateManyArgs>(args?: SelectSubset<T, RegionMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RegionMasters and returns the data saved in the database.
     * @param {RegionMasterCreateManyAndReturnArgs} args - Arguments to create many RegionMasters.
     * @example
     * // Create many RegionMasters
     * const regionMaster = await prisma.regionMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RegionMasters and only return the `id`
     * const regionMasterWithIdOnly = await prisma.regionMaster.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegionMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, RegionMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionMasterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RegionMaster.
     * @param {RegionMasterDeleteArgs} args - Arguments to delete one RegionMaster.
     * @example
     * // Delete one RegionMaster
     * const RegionMaster = await prisma.regionMaster.delete({
     *   where: {
     *     // ... filter to delete one RegionMaster
     *   }
     * })
     * 
     */
    delete<T extends RegionMasterDeleteArgs>(args: SelectSubset<T, RegionMasterDeleteArgs<ExtArgs>>): Prisma__RegionMasterClient<$Result.GetResult<Prisma.$RegionMasterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RegionMaster.
     * @param {RegionMasterUpdateArgs} args - Arguments to update one RegionMaster.
     * @example
     * // Update one RegionMaster
     * const regionMaster = await prisma.regionMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegionMasterUpdateArgs>(args: SelectSubset<T, RegionMasterUpdateArgs<ExtArgs>>): Prisma__RegionMasterClient<$Result.GetResult<Prisma.$RegionMasterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RegionMasters.
     * @param {RegionMasterDeleteManyArgs} args - Arguments to filter RegionMasters to delete.
     * @example
     * // Delete a few RegionMasters
     * const { count } = await prisma.regionMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegionMasterDeleteManyArgs>(args?: SelectSubset<T, RegionMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegionMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegionMasters
     * const regionMaster = await prisma.regionMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegionMasterUpdateManyArgs>(args: SelectSubset<T, RegionMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegionMasters and returns the data updated in the database.
     * @param {RegionMasterUpdateManyAndReturnArgs} args - Arguments to update many RegionMasters.
     * @example
     * // Update many RegionMasters
     * const regionMaster = await prisma.regionMaster.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RegionMasters and only return the `id`
     * const regionMasterWithIdOnly = await prisma.regionMaster.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RegionMasterUpdateManyAndReturnArgs>(args: SelectSubset<T, RegionMasterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionMasterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RegionMaster.
     * @param {RegionMasterUpsertArgs} args - Arguments to update or create a RegionMaster.
     * @example
     * // Update or create a RegionMaster
     * const regionMaster = await prisma.regionMaster.upsert({
     *   create: {
     *     // ... data to create a RegionMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegionMaster we want to update
     *   }
     * })
     */
    upsert<T extends RegionMasterUpsertArgs>(args: SelectSubset<T, RegionMasterUpsertArgs<ExtArgs>>): Prisma__RegionMasterClient<$Result.GetResult<Prisma.$RegionMasterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RegionMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionMasterCountArgs} args - Arguments to filter RegionMasters to count.
     * @example
     * // Count the number of RegionMasters
     * const count = await prisma.regionMaster.count({
     *   where: {
     *     // ... the filter for the RegionMasters we want to count
     *   }
     * })
    **/
    count<T extends RegionMasterCountArgs>(
      args?: Subset<T, RegionMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegionMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionMasterAggregateArgs>(args: Subset<T, RegionMasterAggregateArgs>): Prisma.PrismaPromise<GetRegionMasterAggregateType<T>>

    /**
     * Group by RegionMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionMasterGroupByArgs['orderBy'] }
        : { orderBy?: RegionMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RegionMaster model
   */
  readonly fields: RegionMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegionMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    areas<T extends RegionMaster$areasArgs<ExtArgs> = {}>(args?: Subset<T, RegionMaster$areasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RegionMaster model
   */
  interface RegionMasterFieldRefs {
    readonly id: FieldRef<"RegionMaster", 'String'>
    readonly code: FieldRef<"RegionMaster", 'String'>
    readonly name: FieldRef<"RegionMaster", 'String'>
    readonly displayOrder: FieldRef<"RegionMaster", 'Int'>
    readonly isActive: FieldRef<"RegionMaster", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RegionMaster findUnique
   */
  export type RegionMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMaster
     */
    select?: RegionMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMaster
     */
    omit?: RegionMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMasterInclude<ExtArgs> | null
    /**
     * Filter, which RegionMaster to fetch.
     */
    where: RegionMasterWhereUniqueInput
  }

  /**
   * RegionMaster findUniqueOrThrow
   */
  export type RegionMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMaster
     */
    select?: RegionMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMaster
     */
    omit?: RegionMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMasterInclude<ExtArgs> | null
    /**
     * Filter, which RegionMaster to fetch.
     */
    where: RegionMasterWhereUniqueInput
  }

  /**
   * RegionMaster findFirst
   */
  export type RegionMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMaster
     */
    select?: RegionMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMaster
     */
    omit?: RegionMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMasterInclude<ExtArgs> | null
    /**
     * Filter, which RegionMaster to fetch.
     */
    where?: RegionMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionMasters to fetch.
     */
    orderBy?: RegionMasterOrderByWithRelationInput | RegionMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegionMasters.
     */
    cursor?: RegionMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegionMasters.
     */
    distinct?: RegionMasterScalarFieldEnum | RegionMasterScalarFieldEnum[]
  }

  /**
   * RegionMaster findFirstOrThrow
   */
  export type RegionMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMaster
     */
    select?: RegionMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMaster
     */
    omit?: RegionMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMasterInclude<ExtArgs> | null
    /**
     * Filter, which RegionMaster to fetch.
     */
    where?: RegionMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionMasters to fetch.
     */
    orderBy?: RegionMasterOrderByWithRelationInput | RegionMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegionMasters.
     */
    cursor?: RegionMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegionMasters.
     */
    distinct?: RegionMasterScalarFieldEnum | RegionMasterScalarFieldEnum[]
  }

  /**
   * RegionMaster findMany
   */
  export type RegionMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMaster
     */
    select?: RegionMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMaster
     */
    omit?: RegionMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMasterInclude<ExtArgs> | null
    /**
     * Filter, which RegionMasters to fetch.
     */
    where?: RegionMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionMasters to fetch.
     */
    orderBy?: RegionMasterOrderByWithRelationInput | RegionMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegionMasters.
     */
    cursor?: RegionMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionMasters.
     */
    skip?: number
    distinct?: RegionMasterScalarFieldEnum | RegionMasterScalarFieldEnum[]
  }

  /**
   * RegionMaster create
   */
  export type RegionMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMaster
     */
    select?: RegionMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMaster
     */
    omit?: RegionMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a RegionMaster.
     */
    data: XOR<RegionMasterCreateInput, RegionMasterUncheckedCreateInput>
  }

  /**
   * RegionMaster createMany
   */
  export type RegionMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RegionMasters.
     */
    data: RegionMasterCreateManyInput | RegionMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RegionMaster createManyAndReturn
   */
  export type RegionMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMaster
     */
    select?: RegionMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMaster
     */
    omit?: RegionMasterOmit<ExtArgs> | null
    /**
     * The data used to create many RegionMasters.
     */
    data: RegionMasterCreateManyInput | RegionMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RegionMaster update
   */
  export type RegionMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMaster
     */
    select?: RegionMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMaster
     */
    omit?: RegionMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a RegionMaster.
     */
    data: XOR<RegionMasterUpdateInput, RegionMasterUncheckedUpdateInput>
    /**
     * Choose, which RegionMaster to update.
     */
    where: RegionMasterWhereUniqueInput
  }

  /**
   * RegionMaster updateMany
   */
  export type RegionMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RegionMasters.
     */
    data: XOR<RegionMasterUpdateManyMutationInput, RegionMasterUncheckedUpdateManyInput>
    /**
     * Filter which RegionMasters to update
     */
    where?: RegionMasterWhereInput
    /**
     * Limit how many RegionMasters to update.
     */
    limit?: number
  }

  /**
   * RegionMaster updateManyAndReturn
   */
  export type RegionMasterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMaster
     */
    select?: RegionMasterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMaster
     */
    omit?: RegionMasterOmit<ExtArgs> | null
    /**
     * The data used to update RegionMasters.
     */
    data: XOR<RegionMasterUpdateManyMutationInput, RegionMasterUncheckedUpdateManyInput>
    /**
     * Filter which RegionMasters to update
     */
    where?: RegionMasterWhereInput
    /**
     * Limit how many RegionMasters to update.
     */
    limit?: number
  }

  /**
   * RegionMaster upsert
   */
  export type RegionMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMaster
     */
    select?: RegionMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMaster
     */
    omit?: RegionMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the RegionMaster to update in case it exists.
     */
    where: RegionMasterWhereUniqueInput
    /**
     * In case the RegionMaster found by the `where` argument doesn't exist, create a new RegionMaster with this data.
     */
    create: XOR<RegionMasterCreateInput, RegionMasterUncheckedCreateInput>
    /**
     * In case the RegionMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionMasterUpdateInput, RegionMasterUncheckedUpdateInput>
  }

  /**
   * RegionMaster delete
   */
  export type RegionMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMaster
     */
    select?: RegionMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMaster
     */
    omit?: RegionMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMasterInclude<ExtArgs> | null
    /**
     * Filter which RegionMaster to delete.
     */
    where: RegionMasterWhereUniqueInput
  }

  /**
   * RegionMaster deleteMany
   */
  export type RegionMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegionMasters to delete
     */
    where?: RegionMasterWhereInput
    /**
     * Limit how many RegionMasters to delete.
     */
    limit?: number
  }

  /**
   * RegionMaster.areas
   */
  export type RegionMaster$areasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaMaster
     */
    select?: AreaMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaMaster
     */
    omit?: AreaMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaMasterInclude<ExtArgs> | null
    where?: AreaMasterWhereInput
    orderBy?: AreaMasterOrderByWithRelationInput | AreaMasterOrderByWithRelationInput[]
    cursor?: AreaMasterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AreaMasterScalarFieldEnum | AreaMasterScalarFieldEnum[]
  }

  /**
   * RegionMaster without action
   */
  export type RegionMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMaster
     */
    select?: RegionMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMaster
     */
    omit?: RegionMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMasterInclude<ExtArgs> | null
  }


  /**
   * Model AreaMaster
   */

  export type AggregateAreaMaster = {
    _count: AreaMasterCountAggregateOutputType | null
    _avg: AreaMasterAvgAggregateOutputType | null
    _sum: AreaMasterSumAggregateOutputType | null
    _min: AreaMasterMinAggregateOutputType | null
    _max: AreaMasterMaxAggregateOutputType | null
  }

  export type AreaMasterAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type AreaMasterSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type AreaMasterMinAggregateOutputType = {
    id: string | null
    regionId: string | null
    prefectureCode: string | null
    prefecture: string | null
    cityCode: string | null
    city: string | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type AreaMasterMaxAggregateOutputType = {
    id: string | null
    regionId: string | null
    prefectureCode: string | null
    prefecture: string | null
    cityCode: string | null
    city: string | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type AreaMasterCountAggregateOutputType = {
    id: number
    regionId: number
    prefectureCode: number
    prefecture: number
    cityCode: number
    city: number
    displayOrder: number
    isActive: number
    _all: number
  }


  export type AreaMasterAvgAggregateInputType = {
    displayOrder?: true
  }

  export type AreaMasterSumAggregateInputType = {
    displayOrder?: true
  }

  export type AreaMasterMinAggregateInputType = {
    id?: true
    regionId?: true
    prefectureCode?: true
    prefecture?: true
    cityCode?: true
    city?: true
    displayOrder?: true
    isActive?: true
  }

  export type AreaMasterMaxAggregateInputType = {
    id?: true
    regionId?: true
    prefectureCode?: true
    prefecture?: true
    cityCode?: true
    city?: true
    displayOrder?: true
    isActive?: true
  }

  export type AreaMasterCountAggregateInputType = {
    id?: true
    regionId?: true
    prefectureCode?: true
    prefecture?: true
    cityCode?: true
    city?: true
    displayOrder?: true
    isActive?: true
    _all?: true
  }

  export type AreaMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AreaMaster to aggregate.
     */
    where?: AreaMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaMasters to fetch.
     */
    orderBy?: AreaMasterOrderByWithRelationInput | AreaMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AreaMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AreaMasters
    **/
    _count?: true | AreaMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AreaMasterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AreaMasterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AreaMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AreaMasterMaxAggregateInputType
  }

  export type GetAreaMasterAggregateType<T extends AreaMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateAreaMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAreaMaster[P]>
      : GetScalarType<T[P], AggregateAreaMaster[P]>
  }




  export type AreaMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaMasterWhereInput
    orderBy?: AreaMasterOrderByWithAggregationInput | AreaMasterOrderByWithAggregationInput[]
    by: AreaMasterScalarFieldEnum[] | AreaMasterScalarFieldEnum
    having?: AreaMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AreaMasterCountAggregateInputType | true
    _avg?: AreaMasterAvgAggregateInputType
    _sum?: AreaMasterSumAggregateInputType
    _min?: AreaMasterMinAggregateInputType
    _max?: AreaMasterMaxAggregateInputType
  }

  export type AreaMasterGroupByOutputType = {
    id: string
    regionId: string | null
    prefectureCode: string
    prefecture: string
    cityCode: string | null
    city: string
    displayOrder: number
    isActive: boolean
    _count: AreaMasterCountAggregateOutputType | null
    _avg: AreaMasterAvgAggregateOutputType | null
    _sum: AreaMasterSumAggregateOutputType | null
    _min: AreaMasterMinAggregateOutputType | null
    _max: AreaMasterMaxAggregateOutputType | null
  }

  type GetAreaMasterGroupByPayload<T extends AreaMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AreaMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AreaMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AreaMasterGroupByOutputType[P]>
            : GetScalarType<T[P], AreaMasterGroupByOutputType[P]>
        }
      >
    >


  export type AreaMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionId?: boolean
    prefectureCode?: boolean
    prefecture?: boolean
    cityCode?: boolean
    city?: boolean
    displayOrder?: boolean
    isActive?: boolean
    region?: boolean | AreaMaster$regionArgs<ExtArgs>
    properties?: boolean | AreaMaster$propertiesArgs<ExtArgs>
    _count?: boolean | AreaMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["areaMaster"]>

  export type AreaMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionId?: boolean
    prefectureCode?: boolean
    prefecture?: boolean
    cityCode?: boolean
    city?: boolean
    displayOrder?: boolean
    isActive?: boolean
    region?: boolean | AreaMaster$regionArgs<ExtArgs>
  }, ExtArgs["result"]["areaMaster"]>

  export type AreaMasterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionId?: boolean
    prefectureCode?: boolean
    prefecture?: boolean
    cityCode?: boolean
    city?: boolean
    displayOrder?: boolean
    isActive?: boolean
    region?: boolean | AreaMaster$regionArgs<ExtArgs>
  }, ExtArgs["result"]["areaMaster"]>

  export type AreaMasterSelectScalar = {
    id?: boolean
    regionId?: boolean
    prefectureCode?: boolean
    prefecture?: boolean
    cityCode?: boolean
    city?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }

  export type AreaMasterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "regionId" | "prefectureCode" | "prefecture" | "cityCode" | "city" | "displayOrder" | "isActive", ExtArgs["result"]["areaMaster"]>
  export type AreaMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | AreaMaster$regionArgs<ExtArgs>
    properties?: boolean | AreaMaster$propertiesArgs<ExtArgs>
    _count?: boolean | AreaMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AreaMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | AreaMaster$regionArgs<ExtArgs>
  }
  export type AreaMasterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | AreaMaster$regionArgs<ExtArgs>
  }

  export type $AreaMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AreaMaster"
    objects: {
      region: Prisma.$RegionMasterPayload<ExtArgs> | null
      properties: Prisma.$PropertyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      regionId: string | null
      prefectureCode: string
      prefecture: string
      cityCode: string | null
      city: string
      displayOrder: number
      isActive: boolean
    }, ExtArgs["result"]["areaMaster"]>
    composites: {}
  }

  type AreaMasterGetPayload<S extends boolean | null | undefined | AreaMasterDefaultArgs> = $Result.GetResult<Prisma.$AreaMasterPayload, S>

  type AreaMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AreaMasterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AreaMasterCountAggregateInputType | true
    }

  export interface AreaMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AreaMaster'], meta: { name: 'AreaMaster' } }
    /**
     * Find zero or one AreaMaster that matches the filter.
     * @param {AreaMasterFindUniqueArgs} args - Arguments to find a AreaMaster
     * @example
     * // Get one AreaMaster
     * const areaMaster = await prisma.areaMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AreaMasterFindUniqueArgs>(args: SelectSubset<T, AreaMasterFindUniqueArgs<ExtArgs>>): Prisma__AreaMasterClient<$Result.GetResult<Prisma.$AreaMasterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AreaMaster that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AreaMasterFindUniqueOrThrowArgs} args - Arguments to find a AreaMaster
     * @example
     * // Get one AreaMaster
     * const areaMaster = await prisma.areaMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AreaMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, AreaMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AreaMasterClient<$Result.GetResult<Prisma.$AreaMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AreaMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaMasterFindFirstArgs} args - Arguments to find a AreaMaster
     * @example
     * // Get one AreaMaster
     * const areaMaster = await prisma.areaMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AreaMasterFindFirstArgs>(args?: SelectSubset<T, AreaMasterFindFirstArgs<ExtArgs>>): Prisma__AreaMasterClient<$Result.GetResult<Prisma.$AreaMasterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AreaMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaMasterFindFirstOrThrowArgs} args - Arguments to find a AreaMaster
     * @example
     * // Get one AreaMaster
     * const areaMaster = await prisma.areaMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AreaMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, AreaMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__AreaMasterClient<$Result.GetResult<Prisma.$AreaMasterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AreaMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AreaMasters
     * const areaMasters = await prisma.areaMaster.findMany()
     * 
     * // Get first 10 AreaMasters
     * const areaMasters = await prisma.areaMaster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areaMasterWithIdOnly = await prisma.areaMaster.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AreaMasterFindManyArgs>(args?: SelectSubset<T, AreaMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AreaMaster.
     * @param {AreaMasterCreateArgs} args - Arguments to create a AreaMaster.
     * @example
     * // Create one AreaMaster
     * const AreaMaster = await prisma.areaMaster.create({
     *   data: {
     *     // ... data to create a AreaMaster
     *   }
     * })
     * 
     */
    create<T extends AreaMasterCreateArgs>(args: SelectSubset<T, AreaMasterCreateArgs<ExtArgs>>): Prisma__AreaMasterClient<$Result.GetResult<Prisma.$AreaMasterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AreaMasters.
     * @param {AreaMasterCreateManyArgs} args - Arguments to create many AreaMasters.
     * @example
     * // Create many AreaMasters
     * const areaMaster = await prisma.areaMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AreaMasterCreateManyArgs>(args?: SelectSubset<T, AreaMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AreaMasters and returns the data saved in the database.
     * @param {AreaMasterCreateManyAndReturnArgs} args - Arguments to create many AreaMasters.
     * @example
     * // Create many AreaMasters
     * const areaMaster = await prisma.areaMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AreaMasters and only return the `id`
     * const areaMasterWithIdOnly = await prisma.areaMaster.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AreaMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, AreaMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaMasterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AreaMaster.
     * @param {AreaMasterDeleteArgs} args - Arguments to delete one AreaMaster.
     * @example
     * // Delete one AreaMaster
     * const AreaMaster = await prisma.areaMaster.delete({
     *   where: {
     *     // ... filter to delete one AreaMaster
     *   }
     * })
     * 
     */
    delete<T extends AreaMasterDeleteArgs>(args: SelectSubset<T, AreaMasterDeleteArgs<ExtArgs>>): Prisma__AreaMasterClient<$Result.GetResult<Prisma.$AreaMasterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AreaMaster.
     * @param {AreaMasterUpdateArgs} args - Arguments to update one AreaMaster.
     * @example
     * // Update one AreaMaster
     * const areaMaster = await prisma.areaMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AreaMasterUpdateArgs>(args: SelectSubset<T, AreaMasterUpdateArgs<ExtArgs>>): Prisma__AreaMasterClient<$Result.GetResult<Prisma.$AreaMasterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AreaMasters.
     * @param {AreaMasterDeleteManyArgs} args - Arguments to filter AreaMasters to delete.
     * @example
     * // Delete a few AreaMasters
     * const { count } = await prisma.areaMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AreaMasterDeleteManyArgs>(args?: SelectSubset<T, AreaMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AreaMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AreaMasters
     * const areaMaster = await prisma.areaMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AreaMasterUpdateManyArgs>(args: SelectSubset<T, AreaMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AreaMasters and returns the data updated in the database.
     * @param {AreaMasterUpdateManyAndReturnArgs} args - Arguments to update many AreaMasters.
     * @example
     * // Update many AreaMasters
     * const areaMaster = await prisma.areaMaster.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AreaMasters and only return the `id`
     * const areaMasterWithIdOnly = await prisma.areaMaster.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AreaMasterUpdateManyAndReturnArgs>(args: SelectSubset<T, AreaMasterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaMasterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AreaMaster.
     * @param {AreaMasterUpsertArgs} args - Arguments to update or create a AreaMaster.
     * @example
     * // Update or create a AreaMaster
     * const areaMaster = await prisma.areaMaster.upsert({
     *   create: {
     *     // ... data to create a AreaMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AreaMaster we want to update
     *   }
     * })
     */
    upsert<T extends AreaMasterUpsertArgs>(args: SelectSubset<T, AreaMasterUpsertArgs<ExtArgs>>): Prisma__AreaMasterClient<$Result.GetResult<Prisma.$AreaMasterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AreaMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaMasterCountArgs} args - Arguments to filter AreaMasters to count.
     * @example
     * // Count the number of AreaMasters
     * const count = await prisma.areaMaster.count({
     *   where: {
     *     // ... the filter for the AreaMasters we want to count
     *   }
     * })
    **/
    count<T extends AreaMasterCountArgs>(
      args?: Subset<T, AreaMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreaMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AreaMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreaMasterAggregateArgs>(args: Subset<T, AreaMasterAggregateArgs>): Prisma.PrismaPromise<GetAreaMasterAggregateType<T>>

    /**
     * Group by AreaMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AreaMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AreaMasterGroupByArgs['orderBy'] }
        : { orderBy?: AreaMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AreaMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAreaMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AreaMaster model
   */
  readonly fields: AreaMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AreaMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AreaMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    region<T extends AreaMaster$regionArgs<ExtArgs> = {}>(args?: Subset<T, AreaMaster$regionArgs<ExtArgs>>): Prisma__RegionMasterClient<$Result.GetResult<Prisma.$RegionMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    properties<T extends AreaMaster$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, AreaMaster$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AreaMaster model
   */
  interface AreaMasterFieldRefs {
    readonly id: FieldRef<"AreaMaster", 'String'>
    readonly regionId: FieldRef<"AreaMaster", 'String'>
    readonly prefectureCode: FieldRef<"AreaMaster", 'String'>
    readonly prefecture: FieldRef<"AreaMaster", 'String'>
    readonly cityCode: FieldRef<"AreaMaster", 'String'>
    readonly city: FieldRef<"AreaMaster", 'String'>
    readonly displayOrder: FieldRef<"AreaMaster", 'Int'>
    readonly isActive: FieldRef<"AreaMaster", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AreaMaster findUnique
   */
  export type AreaMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaMaster
     */
    select?: AreaMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaMaster
     */
    omit?: AreaMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaMasterInclude<ExtArgs> | null
    /**
     * Filter, which AreaMaster to fetch.
     */
    where: AreaMasterWhereUniqueInput
  }

  /**
   * AreaMaster findUniqueOrThrow
   */
  export type AreaMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaMaster
     */
    select?: AreaMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaMaster
     */
    omit?: AreaMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaMasterInclude<ExtArgs> | null
    /**
     * Filter, which AreaMaster to fetch.
     */
    where: AreaMasterWhereUniqueInput
  }

  /**
   * AreaMaster findFirst
   */
  export type AreaMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaMaster
     */
    select?: AreaMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaMaster
     */
    omit?: AreaMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaMasterInclude<ExtArgs> | null
    /**
     * Filter, which AreaMaster to fetch.
     */
    where?: AreaMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaMasters to fetch.
     */
    orderBy?: AreaMasterOrderByWithRelationInput | AreaMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AreaMasters.
     */
    cursor?: AreaMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AreaMasters.
     */
    distinct?: AreaMasterScalarFieldEnum | AreaMasterScalarFieldEnum[]
  }

  /**
   * AreaMaster findFirstOrThrow
   */
  export type AreaMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaMaster
     */
    select?: AreaMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaMaster
     */
    omit?: AreaMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaMasterInclude<ExtArgs> | null
    /**
     * Filter, which AreaMaster to fetch.
     */
    where?: AreaMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaMasters to fetch.
     */
    orderBy?: AreaMasterOrderByWithRelationInput | AreaMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AreaMasters.
     */
    cursor?: AreaMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AreaMasters.
     */
    distinct?: AreaMasterScalarFieldEnum | AreaMasterScalarFieldEnum[]
  }

  /**
   * AreaMaster findMany
   */
  export type AreaMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaMaster
     */
    select?: AreaMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaMaster
     */
    omit?: AreaMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaMasterInclude<ExtArgs> | null
    /**
     * Filter, which AreaMasters to fetch.
     */
    where?: AreaMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaMasters to fetch.
     */
    orderBy?: AreaMasterOrderByWithRelationInput | AreaMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AreaMasters.
     */
    cursor?: AreaMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaMasters.
     */
    skip?: number
    distinct?: AreaMasterScalarFieldEnum | AreaMasterScalarFieldEnum[]
  }

  /**
   * AreaMaster create
   */
  export type AreaMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaMaster
     */
    select?: AreaMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaMaster
     */
    omit?: AreaMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a AreaMaster.
     */
    data: XOR<AreaMasterCreateInput, AreaMasterUncheckedCreateInput>
  }

  /**
   * AreaMaster createMany
   */
  export type AreaMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AreaMasters.
     */
    data: AreaMasterCreateManyInput | AreaMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AreaMaster createManyAndReturn
   */
  export type AreaMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaMaster
     */
    select?: AreaMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AreaMaster
     */
    omit?: AreaMasterOmit<ExtArgs> | null
    /**
     * The data used to create many AreaMasters.
     */
    data: AreaMasterCreateManyInput | AreaMasterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaMasterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AreaMaster update
   */
  export type AreaMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaMaster
     */
    select?: AreaMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaMaster
     */
    omit?: AreaMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a AreaMaster.
     */
    data: XOR<AreaMasterUpdateInput, AreaMasterUncheckedUpdateInput>
    /**
     * Choose, which AreaMaster to update.
     */
    where: AreaMasterWhereUniqueInput
  }

  /**
   * AreaMaster updateMany
   */
  export type AreaMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AreaMasters.
     */
    data: XOR<AreaMasterUpdateManyMutationInput, AreaMasterUncheckedUpdateManyInput>
    /**
     * Filter which AreaMasters to update
     */
    where?: AreaMasterWhereInput
    /**
     * Limit how many AreaMasters to update.
     */
    limit?: number
  }

  /**
   * AreaMaster updateManyAndReturn
   */
  export type AreaMasterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaMaster
     */
    select?: AreaMasterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AreaMaster
     */
    omit?: AreaMasterOmit<ExtArgs> | null
    /**
     * The data used to update AreaMasters.
     */
    data: XOR<AreaMasterUpdateManyMutationInput, AreaMasterUncheckedUpdateManyInput>
    /**
     * Filter which AreaMasters to update
     */
    where?: AreaMasterWhereInput
    /**
     * Limit how many AreaMasters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaMasterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AreaMaster upsert
   */
  export type AreaMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaMaster
     */
    select?: AreaMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaMaster
     */
    omit?: AreaMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the AreaMaster to update in case it exists.
     */
    where: AreaMasterWhereUniqueInput
    /**
     * In case the AreaMaster found by the `where` argument doesn't exist, create a new AreaMaster with this data.
     */
    create: XOR<AreaMasterCreateInput, AreaMasterUncheckedCreateInput>
    /**
     * In case the AreaMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AreaMasterUpdateInput, AreaMasterUncheckedUpdateInput>
  }

  /**
   * AreaMaster delete
   */
  export type AreaMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaMaster
     */
    select?: AreaMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaMaster
     */
    omit?: AreaMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaMasterInclude<ExtArgs> | null
    /**
     * Filter which AreaMaster to delete.
     */
    where: AreaMasterWhereUniqueInput
  }

  /**
   * AreaMaster deleteMany
   */
  export type AreaMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AreaMasters to delete
     */
    where?: AreaMasterWhereInput
    /**
     * Limit how many AreaMasters to delete.
     */
    limit?: number
  }

  /**
   * AreaMaster.region
   */
  export type AreaMaster$regionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMaster
     */
    select?: RegionMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMaster
     */
    omit?: RegionMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMasterInclude<ExtArgs> | null
    where?: RegionMasterWhereInput
  }

  /**
   * AreaMaster.properties
   */
  export type AreaMaster$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * AreaMaster without action
   */
  export type AreaMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaMaster
     */
    select?: AreaMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaMaster
     */
    omit?: AreaMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaMasterInclude<ExtArgs> | null
  }


  /**
   * Model PropertyTypeMaster
   */

  export type AggregatePropertyTypeMaster = {
    _count: PropertyTypeMasterCountAggregateOutputType | null
    _avg: PropertyTypeMasterAvgAggregateOutputType | null
    _sum: PropertyTypeMasterSumAggregateOutputType | null
    _min: PropertyTypeMasterMinAggregateOutputType | null
    _max: PropertyTypeMasterMaxAggregateOutputType | null
  }

  export type PropertyTypeMasterAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type PropertyTypeMasterSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type PropertyTypeMasterMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type PropertyTypeMasterMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type PropertyTypeMasterCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    displayOrder: number
    isActive: number
    _all: number
  }


  export type PropertyTypeMasterAvgAggregateInputType = {
    displayOrder?: true
  }

  export type PropertyTypeMasterSumAggregateInputType = {
    displayOrder?: true
  }

  export type PropertyTypeMasterMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    displayOrder?: true
    isActive?: true
  }

  export type PropertyTypeMasterMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    displayOrder?: true
    isActive?: true
  }

  export type PropertyTypeMasterCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    displayOrder?: true
    isActive?: true
    _all?: true
  }

  export type PropertyTypeMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyTypeMaster to aggregate.
     */
    where?: PropertyTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTypeMasters to fetch.
     */
    orderBy?: PropertyTypeMasterOrderByWithRelationInput | PropertyTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyTypeMasters
    **/
    _count?: true | PropertyTypeMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyTypeMasterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyTypeMasterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyTypeMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyTypeMasterMaxAggregateInputType
  }

  export type GetPropertyTypeMasterAggregateType<T extends PropertyTypeMasterAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyTypeMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyTypeMaster[P]>
      : GetScalarType<T[P], AggregatePropertyTypeMaster[P]>
  }




  export type PropertyTypeMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyTypeMasterWhereInput
    orderBy?: PropertyTypeMasterOrderByWithAggregationInput | PropertyTypeMasterOrderByWithAggregationInput[]
    by: PropertyTypeMasterScalarFieldEnum[] | PropertyTypeMasterScalarFieldEnum
    having?: PropertyTypeMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyTypeMasterCountAggregateInputType | true
    _avg?: PropertyTypeMasterAvgAggregateInputType
    _sum?: PropertyTypeMasterSumAggregateInputType
    _min?: PropertyTypeMasterMinAggregateInputType
    _max?: PropertyTypeMasterMaxAggregateInputType
  }

  export type PropertyTypeMasterGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    displayOrder: number
    isActive: boolean
    _count: PropertyTypeMasterCountAggregateOutputType | null
    _avg: PropertyTypeMasterAvgAggregateOutputType | null
    _sum: PropertyTypeMasterSumAggregateOutputType | null
    _min: PropertyTypeMasterMinAggregateOutputType | null
    _max: PropertyTypeMasterMaxAggregateOutputType | null
  }

  type GetPropertyTypeMasterGroupByPayload<T extends PropertyTypeMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyTypeMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyTypeMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyTypeMasterGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyTypeMasterGroupByOutputType[P]>
        }
      >
    >


  export type PropertyTypeMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
    properties?: boolean | PropertyTypeMaster$propertiesArgs<ExtArgs>
    bulkAssessments?: boolean | PropertyTypeMaster$bulkAssessmentsArgs<ExtArgs>
    _count?: boolean | PropertyTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyTypeMaster"]>

  export type PropertyTypeMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["propertyTypeMaster"]>

  export type PropertyTypeMasterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["propertyTypeMaster"]>

  export type PropertyTypeMasterSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }

  export type PropertyTypeMasterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "displayOrder" | "isActive", ExtArgs["result"]["propertyTypeMaster"]>
  export type PropertyTypeMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | PropertyTypeMaster$propertiesArgs<ExtArgs>
    bulkAssessments?: boolean | PropertyTypeMaster$bulkAssessmentsArgs<ExtArgs>
    _count?: boolean | PropertyTypeMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyTypeMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PropertyTypeMasterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PropertyTypeMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyTypeMaster"
    objects: {
      properties: Prisma.$PropertyPayload<ExtArgs>[]
      bulkAssessments: Prisma.$BulkAssessmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      displayOrder: number
      isActive: boolean
    }, ExtArgs["result"]["propertyTypeMaster"]>
    composites: {}
  }

  type PropertyTypeMasterGetPayload<S extends boolean | null | undefined | PropertyTypeMasterDefaultArgs> = $Result.GetResult<Prisma.$PropertyTypeMasterPayload, S>

  type PropertyTypeMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyTypeMasterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyTypeMasterCountAggregateInputType | true
    }

  export interface PropertyTypeMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyTypeMaster'], meta: { name: 'PropertyTypeMaster' } }
    /**
     * Find zero or one PropertyTypeMaster that matches the filter.
     * @param {PropertyTypeMasterFindUniqueArgs} args - Arguments to find a PropertyTypeMaster
     * @example
     * // Get one PropertyTypeMaster
     * const propertyTypeMaster = await prisma.propertyTypeMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyTypeMasterFindUniqueArgs>(args: SelectSubset<T, PropertyTypeMasterFindUniqueArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyTypeMaster that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyTypeMasterFindUniqueOrThrowArgs} args - Arguments to find a PropertyTypeMaster
     * @example
     * // Get one PropertyTypeMaster
     * const propertyTypeMaster = await prisma.propertyTypeMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyTypeMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyTypeMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyTypeMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeMasterFindFirstArgs} args - Arguments to find a PropertyTypeMaster
     * @example
     * // Get one PropertyTypeMaster
     * const propertyTypeMaster = await prisma.propertyTypeMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyTypeMasterFindFirstArgs>(args?: SelectSubset<T, PropertyTypeMasterFindFirstArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyTypeMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeMasterFindFirstOrThrowArgs} args - Arguments to find a PropertyTypeMaster
     * @example
     * // Get one PropertyTypeMaster
     * const propertyTypeMaster = await prisma.propertyTypeMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyTypeMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyTypeMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyTypeMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyTypeMasters
     * const propertyTypeMasters = await prisma.propertyTypeMaster.findMany()
     * 
     * // Get first 10 PropertyTypeMasters
     * const propertyTypeMasters = await prisma.propertyTypeMaster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyTypeMasterWithIdOnly = await prisma.propertyTypeMaster.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyTypeMasterFindManyArgs>(args?: SelectSubset<T, PropertyTypeMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyTypeMaster.
     * @param {PropertyTypeMasterCreateArgs} args - Arguments to create a PropertyTypeMaster.
     * @example
     * // Create one PropertyTypeMaster
     * const PropertyTypeMaster = await prisma.propertyTypeMaster.create({
     *   data: {
     *     // ... data to create a PropertyTypeMaster
     *   }
     * })
     * 
     */
    create<T extends PropertyTypeMasterCreateArgs>(args: SelectSubset<T, PropertyTypeMasterCreateArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyTypeMasters.
     * @param {PropertyTypeMasterCreateManyArgs} args - Arguments to create many PropertyTypeMasters.
     * @example
     * // Create many PropertyTypeMasters
     * const propertyTypeMaster = await prisma.propertyTypeMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyTypeMasterCreateManyArgs>(args?: SelectSubset<T, PropertyTypeMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyTypeMasters and returns the data saved in the database.
     * @param {PropertyTypeMasterCreateManyAndReturnArgs} args - Arguments to create many PropertyTypeMasters.
     * @example
     * // Create many PropertyTypeMasters
     * const propertyTypeMaster = await prisma.propertyTypeMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyTypeMasters and only return the `id`
     * const propertyTypeMasterWithIdOnly = await prisma.propertyTypeMaster.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyTypeMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyTypeMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyTypeMaster.
     * @param {PropertyTypeMasterDeleteArgs} args - Arguments to delete one PropertyTypeMaster.
     * @example
     * // Delete one PropertyTypeMaster
     * const PropertyTypeMaster = await prisma.propertyTypeMaster.delete({
     *   where: {
     *     // ... filter to delete one PropertyTypeMaster
     *   }
     * })
     * 
     */
    delete<T extends PropertyTypeMasterDeleteArgs>(args: SelectSubset<T, PropertyTypeMasterDeleteArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyTypeMaster.
     * @param {PropertyTypeMasterUpdateArgs} args - Arguments to update one PropertyTypeMaster.
     * @example
     * // Update one PropertyTypeMaster
     * const propertyTypeMaster = await prisma.propertyTypeMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyTypeMasterUpdateArgs>(args: SelectSubset<T, PropertyTypeMasterUpdateArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyTypeMasters.
     * @param {PropertyTypeMasterDeleteManyArgs} args - Arguments to filter PropertyTypeMasters to delete.
     * @example
     * // Delete a few PropertyTypeMasters
     * const { count } = await prisma.propertyTypeMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyTypeMasterDeleteManyArgs>(args?: SelectSubset<T, PropertyTypeMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyTypeMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyTypeMasters
     * const propertyTypeMaster = await prisma.propertyTypeMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyTypeMasterUpdateManyArgs>(args: SelectSubset<T, PropertyTypeMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyTypeMasters and returns the data updated in the database.
     * @param {PropertyTypeMasterUpdateManyAndReturnArgs} args - Arguments to update many PropertyTypeMasters.
     * @example
     * // Update many PropertyTypeMasters
     * const propertyTypeMaster = await prisma.propertyTypeMaster.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyTypeMasters and only return the `id`
     * const propertyTypeMasterWithIdOnly = await prisma.propertyTypeMaster.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyTypeMasterUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyTypeMasterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyTypeMaster.
     * @param {PropertyTypeMasterUpsertArgs} args - Arguments to update or create a PropertyTypeMaster.
     * @example
     * // Update or create a PropertyTypeMaster
     * const propertyTypeMaster = await prisma.propertyTypeMaster.upsert({
     *   create: {
     *     // ... data to create a PropertyTypeMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyTypeMaster we want to update
     *   }
     * })
     */
    upsert<T extends PropertyTypeMasterUpsertArgs>(args: SelectSubset<T, PropertyTypeMasterUpsertArgs<ExtArgs>>): Prisma__PropertyTypeMasterClient<$Result.GetResult<Prisma.$PropertyTypeMasterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyTypeMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeMasterCountArgs} args - Arguments to filter PropertyTypeMasters to count.
     * @example
     * // Count the number of PropertyTypeMasters
     * const count = await prisma.propertyTypeMaster.count({
     *   where: {
     *     // ... the filter for the PropertyTypeMasters we want to count
     *   }
     * })
    **/
    count<T extends PropertyTypeMasterCountArgs>(
      args?: Subset<T, PropertyTypeMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyTypeMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyTypeMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyTypeMasterAggregateArgs>(args: Subset<T, PropertyTypeMasterAggregateArgs>): Prisma.PrismaPromise<GetPropertyTypeMasterAggregateType<T>>

    /**
     * Group by PropertyTypeMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyTypeMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyTypeMasterGroupByArgs['orderBy'] }
        : { orderBy?: PropertyTypeMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyTypeMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyTypeMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyTypeMaster model
   */
  readonly fields: PropertyTypeMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyTypeMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyTypeMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    properties<T extends PropertyTypeMaster$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, PropertyTypeMaster$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bulkAssessments<T extends PropertyTypeMaster$bulkAssessmentsArgs<ExtArgs> = {}>(args?: Subset<T, PropertyTypeMaster$bulkAssessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkAssessmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyTypeMaster model
   */
  interface PropertyTypeMasterFieldRefs {
    readonly id: FieldRef<"PropertyTypeMaster", 'String'>
    readonly code: FieldRef<"PropertyTypeMaster", 'String'>
    readonly name: FieldRef<"PropertyTypeMaster", 'String'>
    readonly description: FieldRef<"PropertyTypeMaster", 'String'>
    readonly displayOrder: FieldRef<"PropertyTypeMaster", 'Int'>
    readonly isActive: FieldRef<"PropertyTypeMaster", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PropertyTypeMaster findUnique
   */
  export type PropertyTypeMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTypeMaster
     */
    omit?: PropertyTypeMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTypeMaster to fetch.
     */
    where: PropertyTypeMasterWhereUniqueInput
  }

  /**
   * PropertyTypeMaster findUniqueOrThrow
   */
  export type PropertyTypeMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTypeMaster
     */
    omit?: PropertyTypeMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTypeMaster to fetch.
     */
    where: PropertyTypeMasterWhereUniqueInput
  }

  /**
   * PropertyTypeMaster findFirst
   */
  export type PropertyTypeMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTypeMaster
     */
    omit?: PropertyTypeMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTypeMaster to fetch.
     */
    where?: PropertyTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTypeMasters to fetch.
     */
    orderBy?: PropertyTypeMasterOrderByWithRelationInput | PropertyTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyTypeMasters.
     */
    cursor?: PropertyTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyTypeMasters.
     */
    distinct?: PropertyTypeMasterScalarFieldEnum | PropertyTypeMasterScalarFieldEnum[]
  }

  /**
   * PropertyTypeMaster findFirstOrThrow
   */
  export type PropertyTypeMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTypeMaster
     */
    omit?: PropertyTypeMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTypeMaster to fetch.
     */
    where?: PropertyTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTypeMasters to fetch.
     */
    orderBy?: PropertyTypeMasterOrderByWithRelationInput | PropertyTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyTypeMasters.
     */
    cursor?: PropertyTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTypeMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyTypeMasters.
     */
    distinct?: PropertyTypeMasterScalarFieldEnum | PropertyTypeMasterScalarFieldEnum[]
  }

  /**
   * PropertyTypeMaster findMany
   */
  export type PropertyTypeMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTypeMaster
     */
    omit?: PropertyTypeMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTypeMasters to fetch.
     */
    where?: PropertyTypeMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTypeMasters to fetch.
     */
    orderBy?: PropertyTypeMasterOrderByWithRelationInput | PropertyTypeMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyTypeMasters.
     */
    cursor?: PropertyTypeMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTypeMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTypeMasters.
     */
    skip?: number
    distinct?: PropertyTypeMasterScalarFieldEnum | PropertyTypeMasterScalarFieldEnum[]
  }

  /**
   * PropertyTypeMaster create
   */
  export type PropertyTypeMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTypeMaster
     */
    omit?: PropertyTypeMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyTypeMaster.
     */
    data: XOR<PropertyTypeMasterCreateInput, PropertyTypeMasterUncheckedCreateInput>
  }

  /**
   * PropertyTypeMaster createMany
   */
  export type PropertyTypeMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyTypeMasters.
     */
    data: PropertyTypeMasterCreateManyInput | PropertyTypeMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyTypeMaster createManyAndReturn
   */
  export type PropertyTypeMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTypeMaster
     */
    omit?: PropertyTypeMasterOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyTypeMasters.
     */
    data: PropertyTypeMasterCreateManyInput | PropertyTypeMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyTypeMaster update
   */
  export type PropertyTypeMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTypeMaster
     */
    omit?: PropertyTypeMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyTypeMaster.
     */
    data: XOR<PropertyTypeMasterUpdateInput, PropertyTypeMasterUncheckedUpdateInput>
    /**
     * Choose, which PropertyTypeMaster to update.
     */
    where: PropertyTypeMasterWhereUniqueInput
  }

  /**
   * PropertyTypeMaster updateMany
   */
  export type PropertyTypeMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyTypeMasters.
     */
    data: XOR<PropertyTypeMasterUpdateManyMutationInput, PropertyTypeMasterUncheckedUpdateManyInput>
    /**
     * Filter which PropertyTypeMasters to update
     */
    where?: PropertyTypeMasterWhereInput
    /**
     * Limit how many PropertyTypeMasters to update.
     */
    limit?: number
  }

  /**
   * PropertyTypeMaster updateManyAndReturn
   */
  export type PropertyTypeMasterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTypeMaster
     */
    omit?: PropertyTypeMasterOmit<ExtArgs> | null
    /**
     * The data used to update PropertyTypeMasters.
     */
    data: XOR<PropertyTypeMasterUpdateManyMutationInput, PropertyTypeMasterUncheckedUpdateManyInput>
    /**
     * Filter which PropertyTypeMasters to update
     */
    where?: PropertyTypeMasterWhereInput
    /**
     * Limit how many PropertyTypeMasters to update.
     */
    limit?: number
  }

  /**
   * PropertyTypeMaster upsert
   */
  export type PropertyTypeMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTypeMaster
     */
    omit?: PropertyTypeMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyTypeMaster to update in case it exists.
     */
    where: PropertyTypeMasterWhereUniqueInput
    /**
     * In case the PropertyTypeMaster found by the `where` argument doesn't exist, create a new PropertyTypeMaster with this data.
     */
    create: XOR<PropertyTypeMasterCreateInput, PropertyTypeMasterUncheckedCreateInput>
    /**
     * In case the PropertyTypeMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyTypeMasterUpdateInput, PropertyTypeMasterUncheckedUpdateInput>
  }

  /**
   * PropertyTypeMaster delete
   */
  export type PropertyTypeMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTypeMaster
     */
    omit?: PropertyTypeMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
    /**
     * Filter which PropertyTypeMaster to delete.
     */
    where: PropertyTypeMasterWhereUniqueInput
  }

  /**
   * PropertyTypeMaster deleteMany
   */
  export type PropertyTypeMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyTypeMasters to delete
     */
    where?: PropertyTypeMasterWhereInput
    /**
     * Limit how many PropertyTypeMasters to delete.
     */
    limit?: number
  }

  /**
   * PropertyTypeMaster.properties
   */
  export type PropertyTypeMaster$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * PropertyTypeMaster.bulkAssessments
   */
  export type PropertyTypeMaster$bulkAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkAssessment
     */
    select?: BulkAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkAssessment
     */
    omit?: BulkAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkAssessmentInclude<ExtArgs> | null
    where?: BulkAssessmentWhereInput
    orderBy?: BulkAssessmentOrderByWithRelationInput | BulkAssessmentOrderByWithRelationInput[]
    cursor?: BulkAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BulkAssessmentScalarFieldEnum | BulkAssessmentScalarFieldEnum[]
  }

  /**
   * PropertyTypeMaster without action
   */
  export type PropertyTypeMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeMaster
     */
    select?: PropertyTypeMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTypeMaster
     */
    omit?: PropertyTypeMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTypeMasterInclude<ExtArgs> | null
  }


  /**
   * Model PropertyCategoryMaster
   */

  export type AggregatePropertyCategoryMaster = {
    _count: PropertyCategoryMasterCountAggregateOutputType | null
    _avg: PropertyCategoryMasterAvgAggregateOutputType | null
    _sum: PropertyCategoryMasterSumAggregateOutputType | null
    _min: PropertyCategoryMasterMinAggregateOutputType | null
    _max: PropertyCategoryMasterMaxAggregateOutputType | null
  }

  export type PropertyCategoryMasterAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type PropertyCategoryMasterSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type PropertyCategoryMasterMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type PropertyCategoryMasterMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type PropertyCategoryMasterCountAggregateOutputType = {
    id: number
    code: number
    name: number
    displayOrder: number
    isActive: number
    _all: number
  }


  export type PropertyCategoryMasterAvgAggregateInputType = {
    displayOrder?: true
  }

  export type PropertyCategoryMasterSumAggregateInputType = {
    displayOrder?: true
  }

  export type PropertyCategoryMasterMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    displayOrder?: true
    isActive?: true
  }

  export type PropertyCategoryMasterMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    displayOrder?: true
    isActive?: true
  }

  export type PropertyCategoryMasterCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    displayOrder?: true
    isActive?: true
    _all?: true
  }

  export type PropertyCategoryMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyCategoryMaster to aggregate.
     */
    where?: PropertyCategoryMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyCategoryMasters to fetch.
     */
    orderBy?: PropertyCategoryMasterOrderByWithRelationInput | PropertyCategoryMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyCategoryMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyCategoryMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyCategoryMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyCategoryMasters
    **/
    _count?: true | PropertyCategoryMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyCategoryMasterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyCategoryMasterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyCategoryMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyCategoryMasterMaxAggregateInputType
  }

  export type GetPropertyCategoryMasterAggregateType<T extends PropertyCategoryMasterAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyCategoryMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyCategoryMaster[P]>
      : GetScalarType<T[P], AggregatePropertyCategoryMaster[P]>
  }




  export type PropertyCategoryMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyCategoryMasterWhereInput
    orderBy?: PropertyCategoryMasterOrderByWithAggregationInput | PropertyCategoryMasterOrderByWithAggregationInput[]
    by: PropertyCategoryMasterScalarFieldEnum[] | PropertyCategoryMasterScalarFieldEnum
    having?: PropertyCategoryMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCategoryMasterCountAggregateInputType | true
    _avg?: PropertyCategoryMasterAvgAggregateInputType
    _sum?: PropertyCategoryMasterSumAggregateInputType
    _min?: PropertyCategoryMasterMinAggregateInputType
    _max?: PropertyCategoryMasterMaxAggregateInputType
  }

  export type PropertyCategoryMasterGroupByOutputType = {
    id: string
    code: string
    name: string
    displayOrder: number
    isActive: boolean
    _count: PropertyCategoryMasterCountAggregateOutputType | null
    _avg: PropertyCategoryMasterAvgAggregateOutputType | null
    _sum: PropertyCategoryMasterSumAggregateOutputType | null
    _min: PropertyCategoryMasterMinAggregateOutputType | null
    _max: PropertyCategoryMasterMaxAggregateOutputType | null
  }

  type GetPropertyCategoryMasterGroupByPayload<T extends PropertyCategoryMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyCategoryMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyCategoryMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyCategoryMasterGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyCategoryMasterGroupByOutputType[P]>
        }
      >
    >


  export type PropertyCategoryMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    displayOrder?: boolean
    isActive?: boolean
    properties?: boolean | PropertyCategoryMaster$propertiesArgs<ExtArgs>
    _count?: boolean | PropertyCategoryMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyCategoryMaster"]>

  export type PropertyCategoryMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["propertyCategoryMaster"]>

  export type PropertyCategoryMasterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["propertyCategoryMaster"]>

  export type PropertyCategoryMasterSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }

  export type PropertyCategoryMasterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "displayOrder" | "isActive", ExtArgs["result"]["propertyCategoryMaster"]>
  export type PropertyCategoryMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | PropertyCategoryMaster$propertiesArgs<ExtArgs>
    _count?: boolean | PropertyCategoryMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyCategoryMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PropertyCategoryMasterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PropertyCategoryMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyCategoryMaster"
    objects: {
      properties: Prisma.$PropertyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      displayOrder: number
      isActive: boolean
    }, ExtArgs["result"]["propertyCategoryMaster"]>
    composites: {}
  }

  type PropertyCategoryMasterGetPayload<S extends boolean | null | undefined | PropertyCategoryMasterDefaultArgs> = $Result.GetResult<Prisma.$PropertyCategoryMasterPayload, S>

  type PropertyCategoryMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyCategoryMasterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyCategoryMasterCountAggregateInputType | true
    }

  export interface PropertyCategoryMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyCategoryMaster'], meta: { name: 'PropertyCategoryMaster' } }
    /**
     * Find zero or one PropertyCategoryMaster that matches the filter.
     * @param {PropertyCategoryMasterFindUniqueArgs} args - Arguments to find a PropertyCategoryMaster
     * @example
     * // Get one PropertyCategoryMaster
     * const propertyCategoryMaster = await prisma.propertyCategoryMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyCategoryMasterFindUniqueArgs>(args: SelectSubset<T, PropertyCategoryMasterFindUniqueArgs<ExtArgs>>): Prisma__PropertyCategoryMasterClient<$Result.GetResult<Prisma.$PropertyCategoryMasterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyCategoryMaster that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyCategoryMasterFindUniqueOrThrowArgs} args - Arguments to find a PropertyCategoryMaster
     * @example
     * // Get one PropertyCategoryMaster
     * const propertyCategoryMaster = await prisma.propertyCategoryMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyCategoryMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyCategoryMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyCategoryMasterClient<$Result.GetResult<Prisma.$PropertyCategoryMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyCategoryMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryMasterFindFirstArgs} args - Arguments to find a PropertyCategoryMaster
     * @example
     * // Get one PropertyCategoryMaster
     * const propertyCategoryMaster = await prisma.propertyCategoryMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyCategoryMasterFindFirstArgs>(args?: SelectSubset<T, PropertyCategoryMasterFindFirstArgs<ExtArgs>>): Prisma__PropertyCategoryMasterClient<$Result.GetResult<Prisma.$PropertyCategoryMasterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyCategoryMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryMasterFindFirstOrThrowArgs} args - Arguments to find a PropertyCategoryMaster
     * @example
     * // Get one PropertyCategoryMaster
     * const propertyCategoryMaster = await prisma.propertyCategoryMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyCategoryMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyCategoryMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyCategoryMasterClient<$Result.GetResult<Prisma.$PropertyCategoryMasterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyCategoryMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyCategoryMasters
     * const propertyCategoryMasters = await prisma.propertyCategoryMaster.findMany()
     * 
     * // Get first 10 PropertyCategoryMasters
     * const propertyCategoryMasters = await prisma.propertyCategoryMaster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyCategoryMasterWithIdOnly = await prisma.propertyCategoryMaster.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyCategoryMasterFindManyArgs>(args?: SelectSubset<T, PropertyCategoryMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyCategoryMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyCategoryMaster.
     * @param {PropertyCategoryMasterCreateArgs} args - Arguments to create a PropertyCategoryMaster.
     * @example
     * // Create one PropertyCategoryMaster
     * const PropertyCategoryMaster = await prisma.propertyCategoryMaster.create({
     *   data: {
     *     // ... data to create a PropertyCategoryMaster
     *   }
     * })
     * 
     */
    create<T extends PropertyCategoryMasterCreateArgs>(args: SelectSubset<T, PropertyCategoryMasterCreateArgs<ExtArgs>>): Prisma__PropertyCategoryMasterClient<$Result.GetResult<Prisma.$PropertyCategoryMasterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyCategoryMasters.
     * @param {PropertyCategoryMasterCreateManyArgs} args - Arguments to create many PropertyCategoryMasters.
     * @example
     * // Create many PropertyCategoryMasters
     * const propertyCategoryMaster = await prisma.propertyCategoryMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCategoryMasterCreateManyArgs>(args?: SelectSubset<T, PropertyCategoryMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyCategoryMasters and returns the data saved in the database.
     * @param {PropertyCategoryMasterCreateManyAndReturnArgs} args - Arguments to create many PropertyCategoryMasters.
     * @example
     * // Create many PropertyCategoryMasters
     * const propertyCategoryMaster = await prisma.propertyCategoryMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyCategoryMasters and only return the `id`
     * const propertyCategoryMasterWithIdOnly = await prisma.propertyCategoryMaster.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCategoryMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCategoryMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyCategoryMasterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyCategoryMaster.
     * @param {PropertyCategoryMasterDeleteArgs} args - Arguments to delete one PropertyCategoryMaster.
     * @example
     * // Delete one PropertyCategoryMaster
     * const PropertyCategoryMaster = await prisma.propertyCategoryMaster.delete({
     *   where: {
     *     // ... filter to delete one PropertyCategoryMaster
     *   }
     * })
     * 
     */
    delete<T extends PropertyCategoryMasterDeleteArgs>(args: SelectSubset<T, PropertyCategoryMasterDeleteArgs<ExtArgs>>): Prisma__PropertyCategoryMasterClient<$Result.GetResult<Prisma.$PropertyCategoryMasterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyCategoryMaster.
     * @param {PropertyCategoryMasterUpdateArgs} args - Arguments to update one PropertyCategoryMaster.
     * @example
     * // Update one PropertyCategoryMaster
     * const propertyCategoryMaster = await prisma.propertyCategoryMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyCategoryMasterUpdateArgs>(args: SelectSubset<T, PropertyCategoryMasterUpdateArgs<ExtArgs>>): Prisma__PropertyCategoryMasterClient<$Result.GetResult<Prisma.$PropertyCategoryMasterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyCategoryMasters.
     * @param {PropertyCategoryMasterDeleteManyArgs} args - Arguments to filter PropertyCategoryMasters to delete.
     * @example
     * // Delete a few PropertyCategoryMasters
     * const { count } = await prisma.propertyCategoryMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyCategoryMasterDeleteManyArgs>(args?: SelectSubset<T, PropertyCategoryMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyCategoryMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyCategoryMasters
     * const propertyCategoryMaster = await prisma.propertyCategoryMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyCategoryMasterUpdateManyArgs>(args: SelectSubset<T, PropertyCategoryMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyCategoryMasters and returns the data updated in the database.
     * @param {PropertyCategoryMasterUpdateManyAndReturnArgs} args - Arguments to update many PropertyCategoryMasters.
     * @example
     * // Update many PropertyCategoryMasters
     * const propertyCategoryMaster = await prisma.propertyCategoryMaster.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyCategoryMasters and only return the `id`
     * const propertyCategoryMasterWithIdOnly = await prisma.propertyCategoryMaster.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyCategoryMasterUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyCategoryMasterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyCategoryMasterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyCategoryMaster.
     * @param {PropertyCategoryMasterUpsertArgs} args - Arguments to update or create a PropertyCategoryMaster.
     * @example
     * // Update or create a PropertyCategoryMaster
     * const propertyCategoryMaster = await prisma.propertyCategoryMaster.upsert({
     *   create: {
     *     // ... data to create a PropertyCategoryMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyCategoryMaster we want to update
     *   }
     * })
     */
    upsert<T extends PropertyCategoryMasterUpsertArgs>(args: SelectSubset<T, PropertyCategoryMasterUpsertArgs<ExtArgs>>): Prisma__PropertyCategoryMasterClient<$Result.GetResult<Prisma.$PropertyCategoryMasterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyCategoryMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryMasterCountArgs} args - Arguments to filter PropertyCategoryMasters to count.
     * @example
     * // Count the number of PropertyCategoryMasters
     * const count = await prisma.propertyCategoryMaster.count({
     *   where: {
     *     // ... the filter for the PropertyCategoryMasters we want to count
     *   }
     * })
    **/
    count<T extends PropertyCategoryMasterCountArgs>(
      args?: Subset<T, PropertyCategoryMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCategoryMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyCategoryMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyCategoryMasterAggregateArgs>(args: Subset<T, PropertyCategoryMasterAggregateArgs>): Prisma.PrismaPromise<GetPropertyCategoryMasterAggregateType<T>>

    /**
     * Group by PropertyCategoryMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCategoryMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyCategoryMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyCategoryMasterGroupByArgs['orderBy'] }
        : { orderBy?: PropertyCategoryMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyCategoryMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyCategoryMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyCategoryMaster model
   */
  readonly fields: PropertyCategoryMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyCategoryMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyCategoryMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    properties<T extends PropertyCategoryMaster$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, PropertyCategoryMaster$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyCategoryMaster model
   */
  interface PropertyCategoryMasterFieldRefs {
    readonly id: FieldRef<"PropertyCategoryMaster", 'String'>
    readonly code: FieldRef<"PropertyCategoryMaster", 'String'>
    readonly name: FieldRef<"PropertyCategoryMaster", 'String'>
    readonly displayOrder: FieldRef<"PropertyCategoryMaster", 'Int'>
    readonly isActive: FieldRef<"PropertyCategoryMaster", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PropertyCategoryMaster findUnique
   */
  export type PropertyCategoryMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategoryMaster
     */
    select?: PropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategoryMaster
     */
    omit?: PropertyCategoryMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryMasterInclude<ExtArgs> | null
    /**
     * Filter, which PropertyCategoryMaster to fetch.
     */
    where: PropertyCategoryMasterWhereUniqueInput
  }

  /**
   * PropertyCategoryMaster findUniqueOrThrow
   */
  export type PropertyCategoryMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategoryMaster
     */
    select?: PropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategoryMaster
     */
    omit?: PropertyCategoryMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryMasterInclude<ExtArgs> | null
    /**
     * Filter, which PropertyCategoryMaster to fetch.
     */
    where: PropertyCategoryMasterWhereUniqueInput
  }

  /**
   * PropertyCategoryMaster findFirst
   */
  export type PropertyCategoryMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategoryMaster
     */
    select?: PropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategoryMaster
     */
    omit?: PropertyCategoryMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryMasterInclude<ExtArgs> | null
    /**
     * Filter, which PropertyCategoryMaster to fetch.
     */
    where?: PropertyCategoryMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyCategoryMasters to fetch.
     */
    orderBy?: PropertyCategoryMasterOrderByWithRelationInput | PropertyCategoryMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyCategoryMasters.
     */
    cursor?: PropertyCategoryMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyCategoryMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyCategoryMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyCategoryMasters.
     */
    distinct?: PropertyCategoryMasterScalarFieldEnum | PropertyCategoryMasterScalarFieldEnum[]
  }

  /**
   * PropertyCategoryMaster findFirstOrThrow
   */
  export type PropertyCategoryMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategoryMaster
     */
    select?: PropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategoryMaster
     */
    omit?: PropertyCategoryMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryMasterInclude<ExtArgs> | null
    /**
     * Filter, which PropertyCategoryMaster to fetch.
     */
    where?: PropertyCategoryMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyCategoryMasters to fetch.
     */
    orderBy?: PropertyCategoryMasterOrderByWithRelationInput | PropertyCategoryMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyCategoryMasters.
     */
    cursor?: PropertyCategoryMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyCategoryMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyCategoryMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyCategoryMasters.
     */
    distinct?: PropertyCategoryMasterScalarFieldEnum | PropertyCategoryMasterScalarFieldEnum[]
  }

  /**
   * PropertyCategoryMaster findMany
   */
  export type PropertyCategoryMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategoryMaster
     */
    select?: PropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategoryMaster
     */
    omit?: PropertyCategoryMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryMasterInclude<ExtArgs> | null
    /**
     * Filter, which PropertyCategoryMasters to fetch.
     */
    where?: PropertyCategoryMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyCategoryMasters to fetch.
     */
    orderBy?: PropertyCategoryMasterOrderByWithRelationInput | PropertyCategoryMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyCategoryMasters.
     */
    cursor?: PropertyCategoryMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyCategoryMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyCategoryMasters.
     */
    skip?: number
    distinct?: PropertyCategoryMasterScalarFieldEnum | PropertyCategoryMasterScalarFieldEnum[]
  }

  /**
   * PropertyCategoryMaster create
   */
  export type PropertyCategoryMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategoryMaster
     */
    select?: PropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategoryMaster
     */
    omit?: PropertyCategoryMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyCategoryMaster.
     */
    data: XOR<PropertyCategoryMasterCreateInput, PropertyCategoryMasterUncheckedCreateInput>
  }

  /**
   * PropertyCategoryMaster createMany
   */
  export type PropertyCategoryMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyCategoryMasters.
     */
    data: PropertyCategoryMasterCreateManyInput | PropertyCategoryMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyCategoryMaster createManyAndReturn
   */
  export type PropertyCategoryMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategoryMaster
     */
    select?: PropertyCategoryMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategoryMaster
     */
    omit?: PropertyCategoryMasterOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyCategoryMasters.
     */
    data: PropertyCategoryMasterCreateManyInput | PropertyCategoryMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyCategoryMaster update
   */
  export type PropertyCategoryMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategoryMaster
     */
    select?: PropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategoryMaster
     */
    omit?: PropertyCategoryMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyCategoryMaster.
     */
    data: XOR<PropertyCategoryMasterUpdateInput, PropertyCategoryMasterUncheckedUpdateInput>
    /**
     * Choose, which PropertyCategoryMaster to update.
     */
    where: PropertyCategoryMasterWhereUniqueInput
  }

  /**
   * PropertyCategoryMaster updateMany
   */
  export type PropertyCategoryMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyCategoryMasters.
     */
    data: XOR<PropertyCategoryMasterUpdateManyMutationInput, PropertyCategoryMasterUncheckedUpdateManyInput>
    /**
     * Filter which PropertyCategoryMasters to update
     */
    where?: PropertyCategoryMasterWhereInput
    /**
     * Limit how many PropertyCategoryMasters to update.
     */
    limit?: number
  }

  /**
   * PropertyCategoryMaster updateManyAndReturn
   */
  export type PropertyCategoryMasterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategoryMaster
     */
    select?: PropertyCategoryMasterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategoryMaster
     */
    omit?: PropertyCategoryMasterOmit<ExtArgs> | null
    /**
     * The data used to update PropertyCategoryMasters.
     */
    data: XOR<PropertyCategoryMasterUpdateManyMutationInput, PropertyCategoryMasterUncheckedUpdateManyInput>
    /**
     * Filter which PropertyCategoryMasters to update
     */
    where?: PropertyCategoryMasterWhereInput
    /**
     * Limit how many PropertyCategoryMasters to update.
     */
    limit?: number
  }

  /**
   * PropertyCategoryMaster upsert
   */
  export type PropertyCategoryMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategoryMaster
     */
    select?: PropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategoryMaster
     */
    omit?: PropertyCategoryMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyCategoryMaster to update in case it exists.
     */
    where: PropertyCategoryMasterWhereUniqueInput
    /**
     * In case the PropertyCategoryMaster found by the `where` argument doesn't exist, create a new PropertyCategoryMaster with this data.
     */
    create: XOR<PropertyCategoryMasterCreateInput, PropertyCategoryMasterUncheckedCreateInput>
    /**
     * In case the PropertyCategoryMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyCategoryMasterUpdateInput, PropertyCategoryMasterUncheckedUpdateInput>
  }

  /**
   * PropertyCategoryMaster delete
   */
  export type PropertyCategoryMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategoryMaster
     */
    select?: PropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategoryMaster
     */
    omit?: PropertyCategoryMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryMasterInclude<ExtArgs> | null
    /**
     * Filter which PropertyCategoryMaster to delete.
     */
    where: PropertyCategoryMasterWhereUniqueInput
  }

  /**
   * PropertyCategoryMaster deleteMany
   */
  export type PropertyCategoryMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyCategoryMasters to delete
     */
    where?: PropertyCategoryMasterWhereInput
    /**
     * Limit how many PropertyCategoryMasters to delete.
     */
    limit?: number
  }

  /**
   * PropertyCategoryMaster.properties
   */
  export type PropertyCategoryMaster$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * PropertyCategoryMaster without action
   */
  export type PropertyCategoryMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCategoryMaster
     */
    select?: PropertyCategoryMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyCategoryMaster
     */
    omit?: PropertyCategoryMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyCategoryMasterInclude<ExtArgs> | null
  }


  /**
   * Model FloorPlanMaster
   */

  export type AggregateFloorPlanMaster = {
    _count: FloorPlanMasterCountAggregateOutputType | null
    _avg: FloorPlanMasterAvgAggregateOutputType | null
    _sum: FloorPlanMasterSumAggregateOutputType | null
    _min: FloorPlanMasterMinAggregateOutputType | null
    _max: FloorPlanMasterMaxAggregateOutputType | null
  }

  export type FloorPlanMasterAvgAggregateOutputType = {
    roomCount: number | null
    displayOrder: number | null
  }

  export type FloorPlanMasterSumAggregateOutputType = {
    roomCount: number | null
    displayOrder: number | null
  }

  export type FloorPlanMasterMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    roomCount: number | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type FloorPlanMasterMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    roomCount: number | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type FloorPlanMasterCountAggregateOutputType = {
    id: number
    code: number
    name: number
    roomCount: number
    displayOrder: number
    isActive: number
    _all: number
  }


  export type FloorPlanMasterAvgAggregateInputType = {
    roomCount?: true
    displayOrder?: true
  }

  export type FloorPlanMasterSumAggregateInputType = {
    roomCount?: true
    displayOrder?: true
  }

  export type FloorPlanMasterMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    roomCount?: true
    displayOrder?: true
    isActive?: true
  }

  export type FloorPlanMasterMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    roomCount?: true
    displayOrder?: true
    isActive?: true
  }

  export type FloorPlanMasterCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    roomCount?: true
    displayOrder?: true
    isActive?: true
    _all?: true
  }

  export type FloorPlanMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FloorPlanMaster to aggregate.
     */
    where?: FloorPlanMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FloorPlanMasters to fetch.
     */
    orderBy?: FloorPlanMasterOrderByWithRelationInput | FloorPlanMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FloorPlanMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FloorPlanMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FloorPlanMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FloorPlanMasters
    **/
    _count?: true | FloorPlanMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FloorPlanMasterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FloorPlanMasterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FloorPlanMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FloorPlanMasterMaxAggregateInputType
  }

  export type GetFloorPlanMasterAggregateType<T extends FloorPlanMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateFloorPlanMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFloorPlanMaster[P]>
      : GetScalarType<T[P], AggregateFloorPlanMaster[P]>
  }




  export type FloorPlanMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FloorPlanMasterWhereInput
    orderBy?: FloorPlanMasterOrderByWithAggregationInput | FloorPlanMasterOrderByWithAggregationInput[]
    by: FloorPlanMasterScalarFieldEnum[] | FloorPlanMasterScalarFieldEnum
    having?: FloorPlanMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FloorPlanMasterCountAggregateInputType | true
    _avg?: FloorPlanMasterAvgAggregateInputType
    _sum?: FloorPlanMasterSumAggregateInputType
    _min?: FloorPlanMasterMinAggregateInputType
    _max?: FloorPlanMasterMaxAggregateInputType
  }

  export type FloorPlanMasterGroupByOutputType = {
    id: string
    code: string
    name: string
    roomCount: number | null
    displayOrder: number
    isActive: boolean
    _count: FloorPlanMasterCountAggregateOutputType | null
    _avg: FloorPlanMasterAvgAggregateOutputType | null
    _sum: FloorPlanMasterSumAggregateOutputType | null
    _min: FloorPlanMasterMinAggregateOutputType | null
    _max: FloorPlanMasterMaxAggregateOutputType | null
  }

  type GetFloorPlanMasterGroupByPayload<T extends FloorPlanMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FloorPlanMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FloorPlanMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FloorPlanMasterGroupByOutputType[P]>
            : GetScalarType<T[P], FloorPlanMasterGroupByOutputType[P]>
        }
      >
    >


  export type FloorPlanMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    roomCount?: boolean
    displayOrder?: boolean
    isActive?: boolean
    properties?: boolean | FloorPlanMaster$propertiesArgs<ExtArgs>
    _count?: boolean | FloorPlanMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["floorPlanMaster"]>

  export type FloorPlanMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    roomCount?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["floorPlanMaster"]>

  export type FloorPlanMasterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    roomCount?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["floorPlanMaster"]>

  export type FloorPlanMasterSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    roomCount?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }

  export type FloorPlanMasterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "roomCount" | "displayOrder" | "isActive", ExtArgs["result"]["floorPlanMaster"]>
  export type FloorPlanMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | FloorPlanMaster$propertiesArgs<ExtArgs>
    _count?: boolean | FloorPlanMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FloorPlanMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FloorPlanMasterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FloorPlanMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FloorPlanMaster"
    objects: {
      properties: Prisma.$PropertyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      roomCount: number | null
      displayOrder: number
      isActive: boolean
    }, ExtArgs["result"]["floorPlanMaster"]>
    composites: {}
  }

  type FloorPlanMasterGetPayload<S extends boolean | null | undefined | FloorPlanMasterDefaultArgs> = $Result.GetResult<Prisma.$FloorPlanMasterPayload, S>

  type FloorPlanMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FloorPlanMasterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FloorPlanMasterCountAggregateInputType | true
    }

  export interface FloorPlanMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FloorPlanMaster'], meta: { name: 'FloorPlanMaster' } }
    /**
     * Find zero or one FloorPlanMaster that matches the filter.
     * @param {FloorPlanMasterFindUniqueArgs} args - Arguments to find a FloorPlanMaster
     * @example
     * // Get one FloorPlanMaster
     * const floorPlanMaster = await prisma.floorPlanMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FloorPlanMasterFindUniqueArgs>(args: SelectSubset<T, FloorPlanMasterFindUniqueArgs<ExtArgs>>): Prisma__FloorPlanMasterClient<$Result.GetResult<Prisma.$FloorPlanMasterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FloorPlanMaster that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FloorPlanMasterFindUniqueOrThrowArgs} args - Arguments to find a FloorPlanMaster
     * @example
     * // Get one FloorPlanMaster
     * const floorPlanMaster = await prisma.floorPlanMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FloorPlanMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, FloorPlanMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FloorPlanMasterClient<$Result.GetResult<Prisma.$FloorPlanMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FloorPlanMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorPlanMasterFindFirstArgs} args - Arguments to find a FloorPlanMaster
     * @example
     * // Get one FloorPlanMaster
     * const floorPlanMaster = await prisma.floorPlanMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FloorPlanMasterFindFirstArgs>(args?: SelectSubset<T, FloorPlanMasterFindFirstArgs<ExtArgs>>): Prisma__FloorPlanMasterClient<$Result.GetResult<Prisma.$FloorPlanMasterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FloorPlanMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorPlanMasterFindFirstOrThrowArgs} args - Arguments to find a FloorPlanMaster
     * @example
     * // Get one FloorPlanMaster
     * const floorPlanMaster = await prisma.floorPlanMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FloorPlanMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, FloorPlanMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__FloorPlanMasterClient<$Result.GetResult<Prisma.$FloorPlanMasterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FloorPlanMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorPlanMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FloorPlanMasters
     * const floorPlanMasters = await prisma.floorPlanMaster.findMany()
     * 
     * // Get first 10 FloorPlanMasters
     * const floorPlanMasters = await prisma.floorPlanMaster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const floorPlanMasterWithIdOnly = await prisma.floorPlanMaster.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FloorPlanMasterFindManyArgs>(args?: SelectSubset<T, FloorPlanMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FloorPlanMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FloorPlanMaster.
     * @param {FloorPlanMasterCreateArgs} args - Arguments to create a FloorPlanMaster.
     * @example
     * // Create one FloorPlanMaster
     * const FloorPlanMaster = await prisma.floorPlanMaster.create({
     *   data: {
     *     // ... data to create a FloorPlanMaster
     *   }
     * })
     * 
     */
    create<T extends FloorPlanMasterCreateArgs>(args: SelectSubset<T, FloorPlanMasterCreateArgs<ExtArgs>>): Prisma__FloorPlanMasterClient<$Result.GetResult<Prisma.$FloorPlanMasterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FloorPlanMasters.
     * @param {FloorPlanMasterCreateManyArgs} args - Arguments to create many FloorPlanMasters.
     * @example
     * // Create many FloorPlanMasters
     * const floorPlanMaster = await prisma.floorPlanMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FloorPlanMasterCreateManyArgs>(args?: SelectSubset<T, FloorPlanMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FloorPlanMasters and returns the data saved in the database.
     * @param {FloorPlanMasterCreateManyAndReturnArgs} args - Arguments to create many FloorPlanMasters.
     * @example
     * // Create many FloorPlanMasters
     * const floorPlanMaster = await prisma.floorPlanMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FloorPlanMasters and only return the `id`
     * const floorPlanMasterWithIdOnly = await prisma.floorPlanMaster.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FloorPlanMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, FloorPlanMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FloorPlanMasterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FloorPlanMaster.
     * @param {FloorPlanMasterDeleteArgs} args - Arguments to delete one FloorPlanMaster.
     * @example
     * // Delete one FloorPlanMaster
     * const FloorPlanMaster = await prisma.floorPlanMaster.delete({
     *   where: {
     *     // ... filter to delete one FloorPlanMaster
     *   }
     * })
     * 
     */
    delete<T extends FloorPlanMasterDeleteArgs>(args: SelectSubset<T, FloorPlanMasterDeleteArgs<ExtArgs>>): Prisma__FloorPlanMasterClient<$Result.GetResult<Prisma.$FloorPlanMasterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FloorPlanMaster.
     * @param {FloorPlanMasterUpdateArgs} args - Arguments to update one FloorPlanMaster.
     * @example
     * // Update one FloorPlanMaster
     * const floorPlanMaster = await prisma.floorPlanMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FloorPlanMasterUpdateArgs>(args: SelectSubset<T, FloorPlanMasterUpdateArgs<ExtArgs>>): Prisma__FloorPlanMasterClient<$Result.GetResult<Prisma.$FloorPlanMasterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FloorPlanMasters.
     * @param {FloorPlanMasterDeleteManyArgs} args - Arguments to filter FloorPlanMasters to delete.
     * @example
     * // Delete a few FloorPlanMasters
     * const { count } = await prisma.floorPlanMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FloorPlanMasterDeleteManyArgs>(args?: SelectSubset<T, FloorPlanMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FloorPlanMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorPlanMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FloorPlanMasters
     * const floorPlanMaster = await prisma.floorPlanMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FloorPlanMasterUpdateManyArgs>(args: SelectSubset<T, FloorPlanMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FloorPlanMasters and returns the data updated in the database.
     * @param {FloorPlanMasterUpdateManyAndReturnArgs} args - Arguments to update many FloorPlanMasters.
     * @example
     * // Update many FloorPlanMasters
     * const floorPlanMaster = await prisma.floorPlanMaster.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FloorPlanMasters and only return the `id`
     * const floorPlanMasterWithIdOnly = await prisma.floorPlanMaster.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FloorPlanMasterUpdateManyAndReturnArgs>(args: SelectSubset<T, FloorPlanMasterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FloorPlanMasterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FloorPlanMaster.
     * @param {FloorPlanMasterUpsertArgs} args - Arguments to update or create a FloorPlanMaster.
     * @example
     * // Update or create a FloorPlanMaster
     * const floorPlanMaster = await prisma.floorPlanMaster.upsert({
     *   create: {
     *     // ... data to create a FloorPlanMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FloorPlanMaster we want to update
     *   }
     * })
     */
    upsert<T extends FloorPlanMasterUpsertArgs>(args: SelectSubset<T, FloorPlanMasterUpsertArgs<ExtArgs>>): Prisma__FloorPlanMasterClient<$Result.GetResult<Prisma.$FloorPlanMasterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FloorPlanMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorPlanMasterCountArgs} args - Arguments to filter FloorPlanMasters to count.
     * @example
     * // Count the number of FloorPlanMasters
     * const count = await prisma.floorPlanMaster.count({
     *   where: {
     *     // ... the filter for the FloorPlanMasters we want to count
     *   }
     * })
    **/
    count<T extends FloorPlanMasterCountArgs>(
      args?: Subset<T, FloorPlanMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FloorPlanMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FloorPlanMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorPlanMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FloorPlanMasterAggregateArgs>(args: Subset<T, FloorPlanMasterAggregateArgs>): Prisma.PrismaPromise<GetFloorPlanMasterAggregateType<T>>

    /**
     * Group by FloorPlanMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorPlanMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FloorPlanMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FloorPlanMasterGroupByArgs['orderBy'] }
        : { orderBy?: FloorPlanMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FloorPlanMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFloorPlanMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FloorPlanMaster model
   */
  readonly fields: FloorPlanMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FloorPlanMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FloorPlanMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    properties<T extends FloorPlanMaster$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, FloorPlanMaster$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FloorPlanMaster model
   */
  interface FloorPlanMasterFieldRefs {
    readonly id: FieldRef<"FloorPlanMaster", 'String'>
    readonly code: FieldRef<"FloorPlanMaster", 'String'>
    readonly name: FieldRef<"FloorPlanMaster", 'String'>
    readonly roomCount: FieldRef<"FloorPlanMaster", 'Int'>
    readonly displayOrder: FieldRef<"FloorPlanMaster", 'Int'>
    readonly isActive: FieldRef<"FloorPlanMaster", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * FloorPlanMaster findUnique
   */
  export type FloorPlanMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlanMaster
     */
    select?: FloorPlanMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FloorPlanMaster
     */
    omit?: FloorPlanMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanMasterInclude<ExtArgs> | null
    /**
     * Filter, which FloorPlanMaster to fetch.
     */
    where: FloorPlanMasterWhereUniqueInput
  }

  /**
   * FloorPlanMaster findUniqueOrThrow
   */
  export type FloorPlanMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlanMaster
     */
    select?: FloorPlanMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FloorPlanMaster
     */
    omit?: FloorPlanMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanMasterInclude<ExtArgs> | null
    /**
     * Filter, which FloorPlanMaster to fetch.
     */
    where: FloorPlanMasterWhereUniqueInput
  }

  /**
   * FloorPlanMaster findFirst
   */
  export type FloorPlanMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlanMaster
     */
    select?: FloorPlanMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FloorPlanMaster
     */
    omit?: FloorPlanMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanMasterInclude<ExtArgs> | null
    /**
     * Filter, which FloorPlanMaster to fetch.
     */
    where?: FloorPlanMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FloorPlanMasters to fetch.
     */
    orderBy?: FloorPlanMasterOrderByWithRelationInput | FloorPlanMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FloorPlanMasters.
     */
    cursor?: FloorPlanMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FloorPlanMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FloorPlanMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FloorPlanMasters.
     */
    distinct?: FloorPlanMasterScalarFieldEnum | FloorPlanMasterScalarFieldEnum[]
  }

  /**
   * FloorPlanMaster findFirstOrThrow
   */
  export type FloorPlanMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlanMaster
     */
    select?: FloorPlanMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FloorPlanMaster
     */
    omit?: FloorPlanMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanMasterInclude<ExtArgs> | null
    /**
     * Filter, which FloorPlanMaster to fetch.
     */
    where?: FloorPlanMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FloorPlanMasters to fetch.
     */
    orderBy?: FloorPlanMasterOrderByWithRelationInput | FloorPlanMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FloorPlanMasters.
     */
    cursor?: FloorPlanMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FloorPlanMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FloorPlanMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FloorPlanMasters.
     */
    distinct?: FloorPlanMasterScalarFieldEnum | FloorPlanMasterScalarFieldEnum[]
  }

  /**
   * FloorPlanMaster findMany
   */
  export type FloorPlanMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlanMaster
     */
    select?: FloorPlanMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FloorPlanMaster
     */
    omit?: FloorPlanMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanMasterInclude<ExtArgs> | null
    /**
     * Filter, which FloorPlanMasters to fetch.
     */
    where?: FloorPlanMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FloorPlanMasters to fetch.
     */
    orderBy?: FloorPlanMasterOrderByWithRelationInput | FloorPlanMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FloorPlanMasters.
     */
    cursor?: FloorPlanMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FloorPlanMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FloorPlanMasters.
     */
    skip?: number
    distinct?: FloorPlanMasterScalarFieldEnum | FloorPlanMasterScalarFieldEnum[]
  }

  /**
   * FloorPlanMaster create
   */
  export type FloorPlanMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlanMaster
     */
    select?: FloorPlanMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FloorPlanMaster
     */
    omit?: FloorPlanMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a FloorPlanMaster.
     */
    data: XOR<FloorPlanMasterCreateInput, FloorPlanMasterUncheckedCreateInput>
  }

  /**
   * FloorPlanMaster createMany
   */
  export type FloorPlanMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FloorPlanMasters.
     */
    data: FloorPlanMasterCreateManyInput | FloorPlanMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FloorPlanMaster createManyAndReturn
   */
  export type FloorPlanMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlanMaster
     */
    select?: FloorPlanMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FloorPlanMaster
     */
    omit?: FloorPlanMasterOmit<ExtArgs> | null
    /**
     * The data used to create many FloorPlanMasters.
     */
    data: FloorPlanMasterCreateManyInput | FloorPlanMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FloorPlanMaster update
   */
  export type FloorPlanMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlanMaster
     */
    select?: FloorPlanMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FloorPlanMaster
     */
    omit?: FloorPlanMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a FloorPlanMaster.
     */
    data: XOR<FloorPlanMasterUpdateInput, FloorPlanMasterUncheckedUpdateInput>
    /**
     * Choose, which FloorPlanMaster to update.
     */
    where: FloorPlanMasterWhereUniqueInput
  }

  /**
   * FloorPlanMaster updateMany
   */
  export type FloorPlanMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FloorPlanMasters.
     */
    data: XOR<FloorPlanMasterUpdateManyMutationInput, FloorPlanMasterUncheckedUpdateManyInput>
    /**
     * Filter which FloorPlanMasters to update
     */
    where?: FloorPlanMasterWhereInput
    /**
     * Limit how many FloorPlanMasters to update.
     */
    limit?: number
  }

  /**
   * FloorPlanMaster updateManyAndReturn
   */
  export type FloorPlanMasterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlanMaster
     */
    select?: FloorPlanMasterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FloorPlanMaster
     */
    omit?: FloorPlanMasterOmit<ExtArgs> | null
    /**
     * The data used to update FloorPlanMasters.
     */
    data: XOR<FloorPlanMasterUpdateManyMutationInput, FloorPlanMasterUncheckedUpdateManyInput>
    /**
     * Filter which FloorPlanMasters to update
     */
    where?: FloorPlanMasterWhereInput
    /**
     * Limit how many FloorPlanMasters to update.
     */
    limit?: number
  }

  /**
   * FloorPlanMaster upsert
   */
  export type FloorPlanMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlanMaster
     */
    select?: FloorPlanMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FloorPlanMaster
     */
    omit?: FloorPlanMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the FloorPlanMaster to update in case it exists.
     */
    where: FloorPlanMasterWhereUniqueInput
    /**
     * In case the FloorPlanMaster found by the `where` argument doesn't exist, create a new FloorPlanMaster with this data.
     */
    create: XOR<FloorPlanMasterCreateInput, FloorPlanMasterUncheckedCreateInput>
    /**
     * In case the FloorPlanMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FloorPlanMasterUpdateInput, FloorPlanMasterUncheckedUpdateInput>
  }

  /**
   * FloorPlanMaster delete
   */
  export type FloorPlanMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlanMaster
     */
    select?: FloorPlanMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FloorPlanMaster
     */
    omit?: FloorPlanMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanMasterInclude<ExtArgs> | null
    /**
     * Filter which FloorPlanMaster to delete.
     */
    where: FloorPlanMasterWhereUniqueInput
  }

  /**
   * FloorPlanMaster deleteMany
   */
  export type FloorPlanMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FloorPlanMasters to delete
     */
    where?: FloorPlanMasterWhereInput
    /**
     * Limit how many FloorPlanMasters to delete.
     */
    limit?: number
  }

  /**
   * FloorPlanMaster.properties
   */
  export type FloorPlanMaster$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * FloorPlanMaster without action
   */
  export type FloorPlanMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlanMaster
     */
    select?: FloorPlanMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FloorPlanMaster
     */
    omit?: FloorPlanMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanMasterInclude<ExtArgs> | null
  }


  /**
   * Model RouteMaster
   */

  export type AggregateRouteMaster = {
    _count: RouteMasterCountAggregateOutputType | null
    _avg: RouteMasterAvgAggregateOutputType | null
    _sum: RouteMasterSumAggregateOutputType | null
    _min: RouteMasterMinAggregateOutputType | null
    _max: RouteMasterMaxAggregateOutputType | null
  }

  export type RouteMasterAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type RouteMasterSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type RouteMasterMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    companyName: string | null
    lineColor: string | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type RouteMasterMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    companyName: string | null
    lineColor: string | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type RouteMasterCountAggregateOutputType = {
    id: number
    code: number
    name: number
    companyName: number
    lineColor: number
    displayOrder: number
    isActive: number
    _all: number
  }


  export type RouteMasterAvgAggregateInputType = {
    displayOrder?: true
  }

  export type RouteMasterSumAggregateInputType = {
    displayOrder?: true
  }

  export type RouteMasterMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    companyName?: true
    lineColor?: true
    displayOrder?: true
    isActive?: true
  }

  export type RouteMasterMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    companyName?: true
    lineColor?: true
    displayOrder?: true
    isActive?: true
  }

  export type RouteMasterCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    companyName?: true
    lineColor?: true
    displayOrder?: true
    isActive?: true
    _all?: true
  }

  export type RouteMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteMaster to aggregate.
     */
    where?: RouteMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteMasters to fetch.
     */
    orderBy?: RouteMasterOrderByWithRelationInput | RouteMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RouteMasters
    **/
    _count?: true | RouteMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RouteMasterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RouteMasterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteMasterMaxAggregateInputType
  }

  export type GetRouteMasterAggregateType<T extends RouteMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateRouteMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRouteMaster[P]>
      : GetScalarType<T[P], AggregateRouteMaster[P]>
  }




  export type RouteMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteMasterWhereInput
    orderBy?: RouteMasterOrderByWithAggregationInput | RouteMasterOrderByWithAggregationInput[]
    by: RouteMasterScalarFieldEnum[] | RouteMasterScalarFieldEnum
    having?: RouteMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteMasterCountAggregateInputType | true
    _avg?: RouteMasterAvgAggregateInputType
    _sum?: RouteMasterSumAggregateInputType
    _min?: RouteMasterMinAggregateInputType
    _max?: RouteMasterMaxAggregateInputType
  }

  export type RouteMasterGroupByOutputType = {
    id: string
    code: string
    name: string
    companyName: string | null
    lineColor: string | null
    displayOrder: number
    isActive: boolean
    _count: RouteMasterCountAggregateOutputType | null
    _avg: RouteMasterAvgAggregateOutputType | null
    _sum: RouteMasterSumAggregateOutputType | null
    _min: RouteMasterMinAggregateOutputType | null
    _max: RouteMasterMaxAggregateOutputType | null
  }

  type GetRouteMasterGroupByPayload<T extends RouteMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteMasterGroupByOutputType[P]>
            : GetScalarType<T[P], RouteMasterGroupByOutputType[P]>
        }
      >
    >


  export type RouteMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    companyName?: boolean
    lineColor?: boolean
    displayOrder?: boolean
    isActive?: boolean
    stations?: boolean | RouteMaster$stationsArgs<ExtArgs>
    _count?: boolean | RouteMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeMaster"]>

  export type RouteMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    companyName?: boolean
    lineColor?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["routeMaster"]>

  export type RouteMasterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    companyName?: boolean
    lineColor?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["routeMaster"]>

  export type RouteMasterSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    companyName?: boolean
    lineColor?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }

  export type RouteMasterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "companyName" | "lineColor" | "displayOrder" | "isActive", ExtArgs["result"]["routeMaster"]>
  export type RouteMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stations?: boolean | RouteMaster$stationsArgs<ExtArgs>
    _count?: boolean | RouteMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RouteMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RouteMasterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RouteMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RouteMaster"
    objects: {
      stations: Prisma.$StationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      companyName: string | null
      lineColor: string | null
      displayOrder: number
      isActive: boolean
    }, ExtArgs["result"]["routeMaster"]>
    composites: {}
  }

  type RouteMasterGetPayload<S extends boolean | null | undefined | RouteMasterDefaultArgs> = $Result.GetResult<Prisma.$RouteMasterPayload, S>

  type RouteMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RouteMasterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RouteMasterCountAggregateInputType | true
    }

  export interface RouteMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RouteMaster'], meta: { name: 'RouteMaster' } }
    /**
     * Find zero or one RouteMaster that matches the filter.
     * @param {RouteMasterFindUniqueArgs} args - Arguments to find a RouteMaster
     * @example
     * // Get one RouteMaster
     * const routeMaster = await prisma.routeMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteMasterFindUniqueArgs>(args: SelectSubset<T, RouteMasterFindUniqueArgs<ExtArgs>>): Prisma__RouteMasterClient<$Result.GetResult<Prisma.$RouteMasterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RouteMaster that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RouteMasterFindUniqueOrThrowArgs} args - Arguments to find a RouteMaster
     * @example
     * // Get one RouteMaster
     * const routeMaster = await prisma.routeMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteMasterClient<$Result.GetResult<Prisma.$RouteMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RouteMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteMasterFindFirstArgs} args - Arguments to find a RouteMaster
     * @example
     * // Get one RouteMaster
     * const routeMaster = await prisma.routeMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteMasterFindFirstArgs>(args?: SelectSubset<T, RouteMasterFindFirstArgs<ExtArgs>>): Prisma__RouteMasterClient<$Result.GetResult<Prisma.$RouteMasterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RouteMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteMasterFindFirstOrThrowArgs} args - Arguments to find a RouteMaster
     * @example
     * // Get one RouteMaster
     * const routeMaster = await prisma.routeMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteMasterClient<$Result.GetResult<Prisma.$RouteMasterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RouteMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RouteMasters
     * const routeMasters = await prisma.routeMaster.findMany()
     * 
     * // Get first 10 RouteMasters
     * const routeMasters = await prisma.routeMaster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routeMasterWithIdOnly = await prisma.routeMaster.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RouteMasterFindManyArgs>(args?: SelectSubset<T, RouteMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RouteMaster.
     * @param {RouteMasterCreateArgs} args - Arguments to create a RouteMaster.
     * @example
     * // Create one RouteMaster
     * const RouteMaster = await prisma.routeMaster.create({
     *   data: {
     *     // ... data to create a RouteMaster
     *   }
     * })
     * 
     */
    create<T extends RouteMasterCreateArgs>(args: SelectSubset<T, RouteMasterCreateArgs<ExtArgs>>): Prisma__RouteMasterClient<$Result.GetResult<Prisma.$RouteMasterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RouteMasters.
     * @param {RouteMasterCreateManyArgs} args - Arguments to create many RouteMasters.
     * @example
     * // Create many RouteMasters
     * const routeMaster = await prisma.routeMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteMasterCreateManyArgs>(args?: SelectSubset<T, RouteMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RouteMasters and returns the data saved in the database.
     * @param {RouteMasterCreateManyAndReturnArgs} args - Arguments to create many RouteMasters.
     * @example
     * // Create many RouteMasters
     * const routeMaster = await prisma.routeMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RouteMasters and only return the `id`
     * const routeMasterWithIdOnly = await prisma.routeMaster.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RouteMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, RouteMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteMasterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RouteMaster.
     * @param {RouteMasterDeleteArgs} args - Arguments to delete one RouteMaster.
     * @example
     * // Delete one RouteMaster
     * const RouteMaster = await prisma.routeMaster.delete({
     *   where: {
     *     // ... filter to delete one RouteMaster
     *   }
     * })
     * 
     */
    delete<T extends RouteMasterDeleteArgs>(args: SelectSubset<T, RouteMasterDeleteArgs<ExtArgs>>): Prisma__RouteMasterClient<$Result.GetResult<Prisma.$RouteMasterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RouteMaster.
     * @param {RouteMasterUpdateArgs} args - Arguments to update one RouteMaster.
     * @example
     * // Update one RouteMaster
     * const routeMaster = await prisma.routeMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteMasterUpdateArgs>(args: SelectSubset<T, RouteMasterUpdateArgs<ExtArgs>>): Prisma__RouteMasterClient<$Result.GetResult<Prisma.$RouteMasterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RouteMasters.
     * @param {RouteMasterDeleteManyArgs} args - Arguments to filter RouteMasters to delete.
     * @example
     * // Delete a few RouteMasters
     * const { count } = await prisma.routeMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteMasterDeleteManyArgs>(args?: SelectSubset<T, RouteMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RouteMasters
     * const routeMaster = await prisma.routeMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteMasterUpdateManyArgs>(args: SelectSubset<T, RouteMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteMasters and returns the data updated in the database.
     * @param {RouteMasterUpdateManyAndReturnArgs} args - Arguments to update many RouteMasters.
     * @example
     * // Update many RouteMasters
     * const routeMaster = await prisma.routeMaster.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RouteMasters and only return the `id`
     * const routeMasterWithIdOnly = await prisma.routeMaster.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RouteMasterUpdateManyAndReturnArgs>(args: SelectSubset<T, RouteMasterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteMasterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RouteMaster.
     * @param {RouteMasterUpsertArgs} args - Arguments to update or create a RouteMaster.
     * @example
     * // Update or create a RouteMaster
     * const routeMaster = await prisma.routeMaster.upsert({
     *   create: {
     *     // ... data to create a RouteMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RouteMaster we want to update
     *   }
     * })
     */
    upsert<T extends RouteMasterUpsertArgs>(args: SelectSubset<T, RouteMasterUpsertArgs<ExtArgs>>): Prisma__RouteMasterClient<$Result.GetResult<Prisma.$RouteMasterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RouteMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteMasterCountArgs} args - Arguments to filter RouteMasters to count.
     * @example
     * // Count the number of RouteMasters
     * const count = await prisma.routeMaster.count({
     *   where: {
     *     // ... the filter for the RouteMasters we want to count
     *   }
     * })
    **/
    count<T extends RouteMasterCountArgs>(
      args?: Subset<T, RouteMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RouteMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteMasterAggregateArgs>(args: Subset<T, RouteMasterAggregateArgs>): Prisma.PrismaPromise<GetRouteMasterAggregateType<T>>

    /**
     * Group by RouteMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteMasterGroupByArgs['orderBy'] }
        : { orderBy?: RouteMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RouteMaster model
   */
  readonly fields: RouteMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RouteMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stations<T extends RouteMaster$stationsArgs<ExtArgs> = {}>(args?: Subset<T, RouteMaster$stationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RouteMaster model
   */
  interface RouteMasterFieldRefs {
    readonly id: FieldRef<"RouteMaster", 'String'>
    readonly code: FieldRef<"RouteMaster", 'String'>
    readonly name: FieldRef<"RouteMaster", 'String'>
    readonly companyName: FieldRef<"RouteMaster", 'String'>
    readonly lineColor: FieldRef<"RouteMaster", 'String'>
    readonly displayOrder: FieldRef<"RouteMaster", 'Int'>
    readonly isActive: FieldRef<"RouteMaster", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RouteMaster findUnique
   */
  export type RouteMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteMaster
     */
    select?: RouteMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteMaster
     */
    omit?: RouteMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteMasterInclude<ExtArgs> | null
    /**
     * Filter, which RouteMaster to fetch.
     */
    where: RouteMasterWhereUniqueInput
  }

  /**
   * RouteMaster findUniqueOrThrow
   */
  export type RouteMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteMaster
     */
    select?: RouteMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteMaster
     */
    omit?: RouteMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteMasterInclude<ExtArgs> | null
    /**
     * Filter, which RouteMaster to fetch.
     */
    where: RouteMasterWhereUniqueInput
  }

  /**
   * RouteMaster findFirst
   */
  export type RouteMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteMaster
     */
    select?: RouteMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteMaster
     */
    omit?: RouteMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteMasterInclude<ExtArgs> | null
    /**
     * Filter, which RouteMaster to fetch.
     */
    where?: RouteMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteMasters to fetch.
     */
    orderBy?: RouteMasterOrderByWithRelationInput | RouteMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteMasters.
     */
    cursor?: RouteMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteMasters.
     */
    distinct?: RouteMasterScalarFieldEnum | RouteMasterScalarFieldEnum[]
  }

  /**
   * RouteMaster findFirstOrThrow
   */
  export type RouteMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteMaster
     */
    select?: RouteMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteMaster
     */
    omit?: RouteMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteMasterInclude<ExtArgs> | null
    /**
     * Filter, which RouteMaster to fetch.
     */
    where?: RouteMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteMasters to fetch.
     */
    orderBy?: RouteMasterOrderByWithRelationInput | RouteMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteMasters.
     */
    cursor?: RouteMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteMasters.
     */
    distinct?: RouteMasterScalarFieldEnum | RouteMasterScalarFieldEnum[]
  }

  /**
   * RouteMaster findMany
   */
  export type RouteMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteMaster
     */
    select?: RouteMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteMaster
     */
    omit?: RouteMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteMasterInclude<ExtArgs> | null
    /**
     * Filter, which RouteMasters to fetch.
     */
    where?: RouteMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteMasters to fetch.
     */
    orderBy?: RouteMasterOrderByWithRelationInput | RouteMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RouteMasters.
     */
    cursor?: RouteMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteMasters.
     */
    skip?: number
    distinct?: RouteMasterScalarFieldEnum | RouteMasterScalarFieldEnum[]
  }

  /**
   * RouteMaster create
   */
  export type RouteMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteMaster
     */
    select?: RouteMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteMaster
     */
    omit?: RouteMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a RouteMaster.
     */
    data: XOR<RouteMasterCreateInput, RouteMasterUncheckedCreateInput>
  }

  /**
   * RouteMaster createMany
   */
  export type RouteMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RouteMasters.
     */
    data: RouteMasterCreateManyInput | RouteMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RouteMaster createManyAndReturn
   */
  export type RouteMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteMaster
     */
    select?: RouteMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RouteMaster
     */
    omit?: RouteMasterOmit<ExtArgs> | null
    /**
     * The data used to create many RouteMasters.
     */
    data: RouteMasterCreateManyInput | RouteMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RouteMaster update
   */
  export type RouteMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteMaster
     */
    select?: RouteMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteMaster
     */
    omit?: RouteMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a RouteMaster.
     */
    data: XOR<RouteMasterUpdateInput, RouteMasterUncheckedUpdateInput>
    /**
     * Choose, which RouteMaster to update.
     */
    where: RouteMasterWhereUniqueInput
  }

  /**
   * RouteMaster updateMany
   */
  export type RouteMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RouteMasters.
     */
    data: XOR<RouteMasterUpdateManyMutationInput, RouteMasterUncheckedUpdateManyInput>
    /**
     * Filter which RouteMasters to update
     */
    where?: RouteMasterWhereInput
    /**
     * Limit how many RouteMasters to update.
     */
    limit?: number
  }

  /**
   * RouteMaster updateManyAndReturn
   */
  export type RouteMasterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteMaster
     */
    select?: RouteMasterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RouteMaster
     */
    omit?: RouteMasterOmit<ExtArgs> | null
    /**
     * The data used to update RouteMasters.
     */
    data: XOR<RouteMasterUpdateManyMutationInput, RouteMasterUncheckedUpdateManyInput>
    /**
     * Filter which RouteMasters to update
     */
    where?: RouteMasterWhereInput
    /**
     * Limit how many RouteMasters to update.
     */
    limit?: number
  }

  /**
   * RouteMaster upsert
   */
  export type RouteMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteMaster
     */
    select?: RouteMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteMaster
     */
    omit?: RouteMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the RouteMaster to update in case it exists.
     */
    where: RouteMasterWhereUniqueInput
    /**
     * In case the RouteMaster found by the `where` argument doesn't exist, create a new RouteMaster with this data.
     */
    create: XOR<RouteMasterCreateInput, RouteMasterUncheckedCreateInput>
    /**
     * In case the RouteMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteMasterUpdateInput, RouteMasterUncheckedUpdateInput>
  }

  /**
   * RouteMaster delete
   */
  export type RouteMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteMaster
     */
    select?: RouteMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteMaster
     */
    omit?: RouteMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteMasterInclude<ExtArgs> | null
    /**
     * Filter which RouteMaster to delete.
     */
    where: RouteMasterWhereUniqueInput
  }

  /**
   * RouteMaster deleteMany
   */
  export type RouteMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteMasters to delete
     */
    where?: RouteMasterWhereInput
    /**
     * Limit how many RouteMasters to delete.
     */
    limit?: number
  }

  /**
   * RouteMaster.stations
   */
  export type RouteMaster$stationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Station
     */
    omit?: StationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    where?: StationWhereInput
    orderBy?: StationOrderByWithRelationInput | StationOrderByWithRelationInput[]
    cursor?: StationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StationScalarFieldEnum | StationScalarFieldEnum[]
  }

  /**
   * RouteMaster without action
   */
  export type RouteMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteMaster
     */
    select?: RouteMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteMaster
     */
    omit?: RouteMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteMasterInclude<ExtArgs> | null
  }


  /**
   * Model Station
   */

  export type AggregateStation = {
    _count: StationCountAggregateOutputType | null
    _avg: StationAvgAggregateOutputType | null
    _sum: StationSumAggregateOutputType | null
    _min: StationMinAggregateOutputType | null
    _max: StationMaxAggregateOutputType | null
  }

  export type StationAvgAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
    displayOrder: number | null
  }

  export type StationSumAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
    displayOrder: number | null
  }

  export type StationMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    nameKana: string | null
    routeId: string | null
    prefecture: string | null
    city: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type StationMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    nameKana: string | null
    routeId: string | null
    prefecture: string | null
    city: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type StationCountAggregateOutputType = {
    id: number
    code: number
    name: number
    nameKana: number
    routeId: number
    prefecture: number
    city: number
    latitude: number
    longitude: number
    displayOrder: number
    isActive: number
    _all: number
  }


  export type StationAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    displayOrder?: true
  }

  export type StationSumAggregateInputType = {
    latitude?: true
    longitude?: true
    displayOrder?: true
  }

  export type StationMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nameKana?: true
    routeId?: true
    prefecture?: true
    city?: true
    latitude?: true
    longitude?: true
    displayOrder?: true
    isActive?: true
  }

  export type StationMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nameKana?: true
    routeId?: true
    prefecture?: true
    city?: true
    latitude?: true
    longitude?: true
    displayOrder?: true
    isActive?: true
  }

  export type StationCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nameKana?: true
    routeId?: true
    prefecture?: true
    city?: true
    latitude?: true
    longitude?: true
    displayOrder?: true
    isActive?: true
    _all?: true
  }

  export type StationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Station to aggregate.
     */
    where?: StationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stations to fetch.
     */
    orderBy?: StationOrderByWithRelationInput | StationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stations
    **/
    _count?: true | StationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StationMaxAggregateInputType
  }

  export type GetStationAggregateType<T extends StationAggregateArgs> = {
        [P in keyof T & keyof AggregateStation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStation[P]>
      : GetScalarType<T[P], AggregateStation[P]>
  }




  export type StationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StationWhereInput
    orderBy?: StationOrderByWithAggregationInput | StationOrderByWithAggregationInput[]
    by: StationScalarFieldEnum[] | StationScalarFieldEnum
    having?: StationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StationCountAggregateInputType | true
    _avg?: StationAvgAggregateInputType
    _sum?: StationSumAggregateInputType
    _min?: StationMinAggregateInputType
    _max?: StationMaxAggregateInputType
  }

  export type StationGroupByOutputType = {
    id: string
    code: string
    name: string
    nameKana: string | null
    routeId: string | null
    prefecture: string | null
    city: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    displayOrder: number
    isActive: boolean
    _count: StationCountAggregateOutputType | null
    _avg: StationAvgAggregateOutputType | null
    _sum: StationSumAggregateOutputType | null
    _min: StationMinAggregateOutputType | null
    _max: StationMaxAggregateOutputType | null
  }

  type GetStationGroupByPayload<T extends StationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StationGroupByOutputType[P]>
            : GetScalarType<T[P], StationGroupByOutputType[P]>
        }
      >
    >


  export type StationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    nameKana?: boolean
    routeId?: boolean
    prefecture?: boolean
    city?: boolean
    latitude?: boolean
    longitude?: boolean
    displayOrder?: boolean
    isActive?: boolean
    route?: boolean | Station$routeArgs<ExtArgs>
    propertyStations?: boolean | Station$propertyStationsArgs<ExtArgs>
    _count?: boolean | StationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["station"]>

  export type StationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    nameKana?: boolean
    routeId?: boolean
    prefecture?: boolean
    city?: boolean
    latitude?: boolean
    longitude?: boolean
    displayOrder?: boolean
    isActive?: boolean
    route?: boolean | Station$routeArgs<ExtArgs>
  }, ExtArgs["result"]["station"]>

  export type StationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    nameKana?: boolean
    routeId?: boolean
    prefecture?: boolean
    city?: boolean
    latitude?: boolean
    longitude?: boolean
    displayOrder?: boolean
    isActive?: boolean
    route?: boolean | Station$routeArgs<ExtArgs>
  }, ExtArgs["result"]["station"]>

  export type StationSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    nameKana?: boolean
    routeId?: boolean
    prefecture?: boolean
    city?: boolean
    latitude?: boolean
    longitude?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }

  export type StationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "nameKana" | "routeId" | "prefecture" | "city" | "latitude" | "longitude" | "displayOrder" | "isActive", ExtArgs["result"]["station"]>
  export type StationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | Station$routeArgs<ExtArgs>
    propertyStations?: boolean | Station$propertyStationsArgs<ExtArgs>
    _count?: boolean | StationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | Station$routeArgs<ExtArgs>
  }
  export type StationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | Station$routeArgs<ExtArgs>
  }

  export type $StationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Station"
    objects: {
      route: Prisma.$RouteMasterPayload<ExtArgs> | null
      propertyStations: Prisma.$PropertyStationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      nameKana: string | null
      routeId: string | null
      prefecture: string | null
      city: string | null
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      displayOrder: number
      isActive: boolean
    }, ExtArgs["result"]["station"]>
    composites: {}
  }

  type StationGetPayload<S extends boolean | null | undefined | StationDefaultArgs> = $Result.GetResult<Prisma.$StationPayload, S>

  type StationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StationCountAggregateInputType | true
    }

  export interface StationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Station'], meta: { name: 'Station' } }
    /**
     * Find zero or one Station that matches the filter.
     * @param {StationFindUniqueArgs} args - Arguments to find a Station
     * @example
     * // Get one Station
     * const station = await prisma.station.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StationFindUniqueArgs>(args: SelectSubset<T, StationFindUniqueArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Station that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StationFindUniqueOrThrowArgs} args - Arguments to find a Station
     * @example
     * // Get one Station
     * const station = await prisma.station.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StationFindUniqueOrThrowArgs>(args: SelectSubset<T, StationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Station that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationFindFirstArgs} args - Arguments to find a Station
     * @example
     * // Get one Station
     * const station = await prisma.station.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StationFindFirstArgs>(args?: SelectSubset<T, StationFindFirstArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Station that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationFindFirstOrThrowArgs} args - Arguments to find a Station
     * @example
     * // Get one Station
     * const station = await prisma.station.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StationFindFirstOrThrowArgs>(args?: SelectSubset<T, StationFindFirstOrThrowArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stations
     * const stations = await prisma.station.findMany()
     * 
     * // Get first 10 Stations
     * const stations = await prisma.station.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stationWithIdOnly = await prisma.station.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StationFindManyArgs>(args?: SelectSubset<T, StationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Station.
     * @param {StationCreateArgs} args - Arguments to create a Station.
     * @example
     * // Create one Station
     * const Station = await prisma.station.create({
     *   data: {
     *     // ... data to create a Station
     *   }
     * })
     * 
     */
    create<T extends StationCreateArgs>(args: SelectSubset<T, StationCreateArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stations.
     * @param {StationCreateManyArgs} args - Arguments to create many Stations.
     * @example
     * // Create many Stations
     * const station = await prisma.station.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StationCreateManyArgs>(args?: SelectSubset<T, StationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stations and returns the data saved in the database.
     * @param {StationCreateManyAndReturnArgs} args - Arguments to create many Stations.
     * @example
     * // Create many Stations
     * const station = await prisma.station.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stations and only return the `id`
     * const stationWithIdOnly = await prisma.station.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StationCreateManyAndReturnArgs>(args?: SelectSubset<T, StationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Station.
     * @param {StationDeleteArgs} args - Arguments to delete one Station.
     * @example
     * // Delete one Station
     * const Station = await prisma.station.delete({
     *   where: {
     *     // ... filter to delete one Station
     *   }
     * })
     * 
     */
    delete<T extends StationDeleteArgs>(args: SelectSubset<T, StationDeleteArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Station.
     * @param {StationUpdateArgs} args - Arguments to update one Station.
     * @example
     * // Update one Station
     * const station = await prisma.station.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StationUpdateArgs>(args: SelectSubset<T, StationUpdateArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stations.
     * @param {StationDeleteManyArgs} args - Arguments to filter Stations to delete.
     * @example
     * // Delete a few Stations
     * const { count } = await prisma.station.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StationDeleteManyArgs>(args?: SelectSubset<T, StationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stations
     * const station = await prisma.station.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StationUpdateManyArgs>(args: SelectSubset<T, StationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stations and returns the data updated in the database.
     * @param {StationUpdateManyAndReturnArgs} args - Arguments to update many Stations.
     * @example
     * // Update many Stations
     * const station = await prisma.station.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stations and only return the `id`
     * const stationWithIdOnly = await prisma.station.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StationUpdateManyAndReturnArgs>(args: SelectSubset<T, StationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Station.
     * @param {StationUpsertArgs} args - Arguments to update or create a Station.
     * @example
     * // Update or create a Station
     * const station = await prisma.station.upsert({
     *   create: {
     *     // ... data to create a Station
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Station we want to update
     *   }
     * })
     */
    upsert<T extends StationUpsertArgs>(args: SelectSubset<T, StationUpsertArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationCountArgs} args - Arguments to filter Stations to count.
     * @example
     * // Count the number of Stations
     * const count = await prisma.station.count({
     *   where: {
     *     // ... the filter for the Stations we want to count
     *   }
     * })
    **/
    count<T extends StationCountArgs>(
      args?: Subset<T, StationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Station.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StationAggregateArgs>(args: Subset<T, StationAggregateArgs>): Prisma.PrismaPromise<GetStationAggregateType<T>>

    /**
     * Group by Station.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StationGroupByArgs['orderBy'] }
        : { orderBy?: StationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Station model
   */
  readonly fields: StationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Station.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    route<T extends Station$routeArgs<ExtArgs> = {}>(args?: Subset<T, Station$routeArgs<ExtArgs>>): Prisma__RouteMasterClient<$Result.GetResult<Prisma.$RouteMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    propertyStations<T extends Station$propertyStationsArgs<ExtArgs> = {}>(args?: Subset<T, Station$propertyStationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyStationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Station model
   */
  interface StationFieldRefs {
    readonly id: FieldRef<"Station", 'String'>
    readonly code: FieldRef<"Station", 'String'>
    readonly name: FieldRef<"Station", 'String'>
    readonly nameKana: FieldRef<"Station", 'String'>
    readonly routeId: FieldRef<"Station", 'String'>
    readonly prefecture: FieldRef<"Station", 'String'>
    readonly city: FieldRef<"Station", 'String'>
    readonly latitude: FieldRef<"Station", 'Decimal'>
    readonly longitude: FieldRef<"Station", 'Decimal'>
    readonly displayOrder: FieldRef<"Station", 'Int'>
    readonly isActive: FieldRef<"Station", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Station findUnique
   */
  export type StationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Station
     */
    omit?: StationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * Filter, which Station to fetch.
     */
    where: StationWhereUniqueInput
  }

  /**
   * Station findUniqueOrThrow
   */
  export type StationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Station
     */
    omit?: StationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * Filter, which Station to fetch.
     */
    where: StationWhereUniqueInput
  }

  /**
   * Station findFirst
   */
  export type StationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Station
     */
    omit?: StationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * Filter, which Station to fetch.
     */
    where?: StationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stations to fetch.
     */
    orderBy?: StationOrderByWithRelationInput | StationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stations.
     */
    cursor?: StationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stations.
     */
    distinct?: StationScalarFieldEnum | StationScalarFieldEnum[]
  }

  /**
   * Station findFirstOrThrow
   */
  export type StationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Station
     */
    omit?: StationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * Filter, which Station to fetch.
     */
    where?: StationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stations to fetch.
     */
    orderBy?: StationOrderByWithRelationInput | StationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stations.
     */
    cursor?: StationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stations.
     */
    distinct?: StationScalarFieldEnum | StationScalarFieldEnum[]
  }

  /**
   * Station findMany
   */
  export type StationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Station
     */
    omit?: StationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * Filter, which Stations to fetch.
     */
    where?: StationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stations to fetch.
     */
    orderBy?: StationOrderByWithRelationInput | StationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stations.
     */
    cursor?: StationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stations.
     */
    skip?: number
    distinct?: StationScalarFieldEnum | StationScalarFieldEnum[]
  }

  /**
   * Station create
   */
  export type StationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Station
     */
    omit?: StationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * The data needed to create a Station.
     */
    data: XOR<StationCreateInput, StationUncheckedCreateInput>
  }

  /**
   * Station createMany
   */
  export type StationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stations.
     */
    data: StationCreateManyInput | StationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Station createManyAndReturn
   */
  export type StationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Station
     */
    omit?: StationOmit<ExtArgs> | null
    /**
     * The data used to create many Stations.
     */
    data: StationCreateManyInput | StationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Station update
   */
  export type StationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Station
     */
    omit?: StationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * The data needed to update a Station.
     */
    data: XOR<StationUpdateInput, StationUncheckedUpdateInput>
    /**
     * Choose, which Station to update.
     */
    where: StationWhereUniqueInput
  }

  /**
   * Station updateMany
   */
  export type StationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stations.
     */
    data: XOR<StationUpdateManyMutationInput, StationUncheckedUpdateManyInput>
    /**
     * Filter which Stations to update
     */
    where?: StationWhereInput
    /**
     * Limit how many Stations to update.
     */
    limit?: number
  }

  /**
   * Station updateManyAndReturn
   */
  export type StationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Station
     */
    omit?: StationOmit<ExtArgs> | null
    /**
     * The data used to update Stations.
     */
    data: XOR<StationUpdateManyMutationInput, StationUncheckedUpdateManyInput>
    /**
     * Filter which Stations to update
     */
    where?: StationWhereInput
    /**
     * Limit how many Stations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Station upsert
   */
  export type StationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Station
     */
    omit?: StationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * The filter to search for the Station to update in case it exists.
     */
    where: StationWhereUniqueInput
    /**
     * In case the Station found by the `where` argument doesn't exist, create a new Station with this data.
     */
    create: XOR<StationCreateInput, StationUncheckedCreateInput>
    /**
     * In case the Station was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StationUpdateInput, StationUncheckedUpdateInput>
  }

  /**
   * Station delete
   */
  export type StationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Station
     */
    omit?: StationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * Filter which Station to delete.
     */
    where: StationWhereUniqueInput
  }

  /**
   * Station deleteMany
   */
  export type StationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stations to delete
     */
    where?: StationWhereInput
    /**
     * Limit how many Stations to delete.
     */
    limit?: number
  }

  /**
   * Station.route
   */
  export type Station$routeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteMaster
     */
    select?: RouteMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteMaster
     */
    omit?: RouteMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteMasterInclude<ExtArgs> | null
    where?: RouteMasterWhereInput
  }

  /**
   * Station.propertyStations
   */
  export type Station$propertyStationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyStation
     */
    select?: PropertyStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyStation
     */
    omit?: PropertyStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyStationInclude<ExtArgs> | null
    where?: PropertyStationWhereInput
    orderBy?: PropertyStationOrderByWithRelationInput | PropertyStationOrderByWithRelationInput[]
    cursor?: PropertyStationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyStationScalarFieldEnum | PropertyStationScalarFieldEnum[]
  }

  /**
   * Station without action
   */
  export type StationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Station
     */
    omit?: StationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
  }


  /**
   * Model QuestionCategory
   */

  export type AggregateQuestionCategory = {
    _count: QuestionCategoryCountAggregateOutputType | null
    _avg: QuestionCategoryAvgAggregateOutputType | null
    _sum: QuestionCategorySumAggregateOutputType | null
    _min: QuestionCategoryMinAggregateOutputType | null
    _max: QuestionCategoryMaxAggregateOutputType | null
  }

  export type QuestionCategoryAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type QuestionCategorySumAggregateOutputType = {
    displayOrder: number | null
  }

  export type QuestionCategoryMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type QuestionCategoryMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type QuestionCategoryCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    displayOrder: number
    isActive: number
    _all: number
  }


  export type QuestionCategoryAvgAggregateInputType = {
    displayOrder?: true
  }

  export type QuestionCategorySumAggregateInputType = {
    displayOrder?: true
  }

  export type QuestionCategoryMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    displayOrder?: true
    isActive?: true
  }

  export type QuestionCategoryMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    displayOrder?: true
    isActive?: true
  }

  export type QuestionCategoryCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    displayOrder?: true
    isActive?: true
    _all?: true
  }

  export type QuestionCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionCategory to aggregate.
     */
    where?: QuestionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionCategories to fetch.
     */
    orderBy?: QuestionCategoryOrderByWithRelationInput | QuestionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionCategories
    **/
    _count?: true | QuestionCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionCategoryMaxAggregateInputType
  }

  export type GetQuestionCategoryAggregateType<T extends QuestionCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionCategory[P]>
      : GetScalarType<T[P], AggregateQuestionCategory[P]>
  }




  export type QuestionCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionCategoryWhereInput
    orderBy?: QuestionCategoryOrderByWithAggregationInput | QuestionCategoryOrderByWithAggregationInput[]
    by: QuestionCategoryScalarFieldEnum[] | QuestionCategoryScalarFieldEnum
    having?: QuestionCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCategoryCountAggregateInputType | true
    _avg?: QuestionCategoryAvgAggregateInputType
    _sum?: QuestionCategorySumAggregateInputType
    _min?: QuestionCategoryMinAggregateInputType
    _max?: QuestionCategoryMaxAggregateInputType
  }

  export type QuestionCategoryGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    displayOrder: number
    isActive: boolean
    _count: QuestionCategoryCountAggregateOutputType | null
    _avg: QuestionCategoryAvgAggregateOutputType | null
    _sum: QuestionCategorySumAggregateOutputType | null
    _min: QuestionCategoryMinAggregateOutputType | null
    _max: QuestionCategoryMaxAggregateOutputType | null
  }

  type GetQuestionCategoryGroupByPayload<T extends QuestionCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionCategoryGroupByOutputType[P]>
        }
      >
    >


  export type QuestionCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
    questions?: boolean | QuestionCategory$questionsArgs<ExtArgs>
    _count?: boolean | QuestionCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionCategory"]>

  export type QuestionCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["questionCategory"]>

  export type QuestionCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["questionCategory"]>

  export type QuestionCategorySelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }

  export type QuestionCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "displayOrder" | "isActive", ExtArgs["result"]["questionCategory"]>
  export type QuestionCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | QuestionCategory$questionsArgs<ExtArgs>
    _count?: boolean | QuestionCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestionCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type QuestionCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $QuestionCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionCategory"
    objects: {
      questions: Prisma.$QuestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      displayOrder: number
      isActive: boolean
    }, ExtArgs["result"]["questionCategory"]>
    composites: {}
  }

  type QuestionCategoryGetPayload<S extends boolean | null | undefined | QuestionCategoryDefaultArgs> = $Result.GetResult<Prisma.$QuestionCategoryPayload, S>

  type QuestionCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionCategoryCountAggregateInputType | true
    }

  export interface QuestionCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionCategory'], meta: { name: 'QuestionCategory' } }
    /**
     * Find zero or one QuestionCategory that matches the filter.
     * @param {QuestionCategoryFindUniqueArgs} args - Arguments to find a QuestionCategory
     * @example
     * // Get one QuestionCategory
     * const questionCategory = await prisma.questionCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionCategoryFindUniqueArgs>(args: SelectSubset<T, QuestionCategoryFindUniqueArgs<ExtArgs>>): Prisma__QuestionCategoryClient<$Result.GetResult<Prisma.$QuestionCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuestionCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionCategoryFindUniqueOrThrowArgs} args - Arguments to find a QuestionCategory
     * @example
     * // Get one QuestionCategory
     * const questionCategory = await prisma.questionCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionCategoryClient<$Result.GetResult<Prisma.$QuestionCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCategoryFindFirstArgs} args - Arguments to find a QuestionCategory
     * @example
     * // Get one QuestionCategory
     * const questionCategory = await prisma.questionCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionCategoryFindFirstArgs>(args?: SelectSubset<T, QuestionCategoryFindFirstArgs<ExtArgs>>): Prisma__QuestionCategoryClient<$Result.GetResult<Prisma.$QuestionCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCategoryFindFirstOrThrowArgs} args - Arguments to find a QuestionCategory
     * @example
     * // Get one QuestionCategory
     * const questionCategory = await prisma.questionCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionCategoryClient<$Result.GetResult<Prisma.$QuestionCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuestionCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionCategories
     * const questionCategories = await prisma.questionCategory.findMany()
     * 
     * // Get first 10 QuestionCategories
     * const questionCategories = await prisma.questionCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionCategoryWithIdOnly = await prisma.questionCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionCategoryFindManyArgs>(args?: SelectSubset<T, QuestionCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuestionCategory.
     * @param {QuestionCategoryCreateArgs} args - Arguments to create a QuestionCategory.
     * @example
     * // Create one QuestionCategory
     * const QuestionCategory = await prisma.questionCategory.create({
     *   data: {
     *     // ... data to create a QuestionCategory
     *   }
     * })
     * 
     */
    create<T extends QuestionCategoryCreateArgs>(args: SelectSubset<T, QuestionCategoryCreateArgs<ExtArgs>>): Prisma__QuestionCategoryClient<$Result.GetResult<Prisma.$QuestionCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuestionCategories.
     * @param {QuestionCategoryCreateManyArgs} args - Arguments to create many QuestionCategories.
     * @example
     * // Create many QuestionCategories
     * const questionCategory = await prisma.questionCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionCategoryCreateManyArgs>(args?: SelectSubset<T, QuestionCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionCategories and returns the data saved in the database.
     * @param {QuestionCategoryCreateManyAndReturnArgs} args - Arguments to create many QuestionCategories.
     * @example
     * // Create many QuestionCategories
     * const questionCategory = await prisma.questionCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionCategories and only return the `id`
     * const questionCategoryWithIdOnly = await prisma.questionCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuestionCategory.
     * @param {QuestionCategoryDeleteArgs} args - Arguments to delete one QuestionCategory.
     * @example
     * // Delete one QuestionCategory
     * const QuestionCategory = await prisma.questionCategory.delete({
     *   where: {
     *     // ... filter to delete one QuestionCategory
     *   }
     * })
     * 
     */
    delete<T extends QuestionCategoryDeleteArgs>(args: SelectSubset<T, QuestionCategoryDeleteArgs<ExtArgs>>): Prisma__QuestionCategoryClient<$Result.GetResult<Prisma.$QuestionCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuestionCategory.
     * @param {QuestionCategoryUpdateArgs} args - Arguments to update one QuestionCategory.
     * @example
     * // Update one QuestionCategory
     * const questionCategory = await prisma.questionCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionCategoryUpdateArgs>(args: SelectSubset<T, QuestionCategoryUpdateArgs<ExtArgs>>): Prisma__QuestionCategoryClient<$Result.GetResult<Prisma.$QuestionCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuestionCategories.
     * @param {QuestionCategoryDeleteManyArgs} args - Arguments to filter QuestionCategories to delete.
     * @example
     * // Delete a few QuestionCategories
     * const { count } = await prisma.questionCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionCategoryDeleteManyArgs>(args?: SelectSubset<T, QuestionCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionCategories
     * const questionCategory = await prisma.questionCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionCategoryUpdateManyArgs>(args: SelectSubset<T, QuestionCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionCategories and returns the data updated in the database.
     * @param {QuestionCategoryUpdateManyAndReturnArgs} args - Arguments to update many QuestionCategories.
     * @example
     * // Update many QuestionCategories
     * const questionCategory = await prisma.questionCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuestionCategories and only return the `id`
     * const questionCategoryWithIdOnly = await prisma.questionCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuestionCategory.
     * @param {QuestionCategoryUpsertArgs} args - Arguments to update or create a QuestionCategory.
     * @example
     * // Update or create a QuestionCategory
     * const questionCategory = await prisma.questionCategory.upsert({
     *   create: {
     *     // ... data to create a QuestionCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionCategory we want to update
     *   }
     * })
     */
    upsert<T extends QuestionCategoryUpsertArgs>(args: SelectSubset<T, QuestionCategoryUpsertArgs<ExtArgs>>): Prisma__QuestionCategoryClient<$Result.GetResult<Prisma.$QuestionCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuestionCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCategoryCountArgs} args - Arguments to filter QuestionCategories to count.
     * @example
     * // Count the number of QuestionCategories
     * const count = await prisma.questionCategory.count({
     *   where: {
     *     // ... the filter for the QuestionCategories we want to count
     *   }
     * })
    **/
    count<T extends QuestionCategoryCountArgs>(
      args?: Subset<T, QuestionCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionCategoryAggregateArgs>(args: Subset<T, QuestionCategoryAggregateArgs>): Prisma.PrismaPromise<GetQuestionCategoryAggregateType<T>>

    /**
     * Group by QuestionCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionCategoryGroupByArgs['orderBy'] }
        : { orderBy?: QuestionCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionCategory model
   */
  readonly fields: QuestionCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends QuestionCategory$questionsArgs<ExtArgs> = {}>(args?: Subset<T, QuestionCategory$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionCategory model
   */
  interface QuestionCategoryFieldRefs {
    readonly id: FieldRef<"QuestionCategory", 'String'>
    readonly code: FieldRef<"QuestionCategory", 'String'>
    readonly name: FieldRef<"QuestionCategory", 'String'>
    readonly description: FieldRef<"QuestionCategory", 'String'>
    readonly displayOrder: FieldRef<"QuestionCategory", 'Int'>
    readonly isActive: FieldRef<"QuestionCategory", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * QuestionCategory findUnique
   */
  export type QuestionCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     */
    select?: QuestionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionCategory
     */
    omit?: QuestionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which QuestionCategory to fetch.
     */
    where: QuestionCategoryWhereUniqueInput
  }

  /**
   * QuestionCategory findUniqueOrThrow
   */
  export type QuestionCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     */
    select?: QuestionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionCategory
     */
    omit?: QuestionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which QuestionCategory to fetch.
     */
    where: QuestionCategoryWhereUniqueInput
  }

  /**
   * QuestionCategory findFirst
   */
  export type QuestionCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     */
    select?: QuestionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionCategory
     */
    omit?: QuestionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which QuestionCategory to fetch.
     */
    where?: QuestionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionCategories to fetch.
     */
    orderBy?: QuestionCategoryOrderByWithRelationInput | QuestionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionCategories.
     */
    cursor?: QuestionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionCategories.
     */
    distinct?: QuestionCategoryScalarFieldEnum | QuestionCategoryScalarFieldEnum[]
  }

  /**
   * QuestionCategory findFirstOrThrow
   */
  export type QuestionCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     */
    select?: QuestionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionCategory
     */
    omit?: QuestionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which QuestionCategory to fetch.
     */
    where?: QuestionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionCategories to fetch.
     */
    orderBy?: QuestionCategoryOrderByWithRelationInput | QuestionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionCategories.
     */
    cursor?: QuestionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionCategories.
     */
    distinct?: QuestionCategoryScalarFieldEnum | QuestionCategoryScalarFieldEnum[]
  }

  /**
   * QuestionCategory findMany
   */
  export type QuestionCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     */
    select?: QuestionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionCategory
     */
    omit?: QuestionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which QuestionCategories to fetch.
     */
    where?: QuestionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionCategories to fetch.
     */
    orderBy?: QuestionCategoryOrderByWithRelationInput | QuestionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionCategories.
     */
    cursor?: QuestionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionCategories.
     */
    skip?: number
    distinct?: QuestionCategoryScalarFieldEnum | QuestionCategoryScalarFieldEnum[]
  }

  /**
   * QuestionCategory create
   */
  export type QuestionCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     */
    select?: QuestionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionCategory
     */
    omit?: QuestionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionCategory.
     */
    data: XOR<QuestionCategoryCreateInput, QuestionCategoryUncheckedCreateInput>
  }

  /**
   * QuestionCategory createMany
   */
  export type QuestionCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionCategories.
     */
    data: QuestionCategoryCreateManyInput | QuestionCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionCategory createManyAndReturn
   */
  export type QuestionCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     */
    select?: QuestionCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionCategory
     */
    omit?: QuestionCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many QuestionCategories.
     */
    data: QuestionCategoryCreateManyInput | QuestionCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionCategory update
   */
  export type QuestionCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     */
    select?: QuestionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionCategory
     */
    omit?: QuestionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionCategory.
     */
    data: XOR<QuestionCategoryUpdateInput, QuestionCategoryUncheckedUpdateInput>
    /**
     * Choose, which QuestionCategory to update.
     */
    where: QuestionCategoryWhereUniqueInput
  }

  /**
   * QuestionCategory updateMany
   */
  export type QuestionCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionCategories.
     */
    data: XOR<QuestionCategoryUpdateManyMutationInput, QuestionCategoryUncheckedUpdateManyInput>
    /**
     * Filter which QuestionCategories to update
     */
    where?: QuestionCategoryWhereInput
    /**
     * Limit how many QuestionCategories to update.
     */
    limit?: number
  }

  /**
   * QuestionCategory updateManyAndReturn
   */
  export type QuestionCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     */
    select?: QuestionCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionCategory
     */
    omit?: QuestionCategoryOmit<ExtArgs> | null
    /**
     * The data used to update QuestionCategories.
     */
    data: XOR<QuestionCategoryUpdateManyMutationInput, QuestionCategoryUncheckedUpdateManyInput>
    /**
     * Filter which QuestionCategories to update
     */
    where?: QuestionCategoryWhereInput
    /**
     * Limit how many QuestionCategories to update.
     */
    limit?: number
  }

  /**
   * QuestionCategory upsert
   */
  export type QuestionCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     */
    select?: QuestionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionCategory
     */
    omit?: QuestionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionCategory to update in case it exists.
     */
    where: QuestionCategoryWhereUniqueInput
    /**
     * In case the QuestionCategory found by the `where` argument doesn't exist, create a new QuestionCategory with this data.
     */
    create: XOR<QuestionCategoryCreateInput, QuestionCategoryUncheckedCreateInput>
    /**
     * In case the QuestionCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionCategoryUpdateInput, QuestionCategoryUncheckedUpdateInput>
  }

  /**
   * QuestionCategory delete
   */
  export type QuestionCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     */
    select?: QuestionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionCategory
     */
    omit?: QuestionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCategoryInclude<ExtArgs> | null
    /**
     * Filter which QuestionCategory to delete.
     */
    where: QuestionCategoryWhereUniqueInput
  }

  /**
   * QuestionCategory deleteMany
   */
  export type QuestionCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionCategories to delete
     */
    where?: QuestionCategoryWhereInput
    /**
     * Limit how many QuestionCategories to delete.
     */
    limit?: number
  }

  /**
   * QuestionCategory.questions
   */
  export type QuestionCategory$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * QuestionCategory without action
   */
  export type QuestionCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     */
    select?: QuestionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionCategory
     */
    omit?: QuestionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Mail
   */

  export type AggregateMail = {
    _count: MailCountAggregateOutputType | null
    _avg: MailAvgAggregateOutputType | null
    _sum: MailSumAggregateOutputType | null
    _min: MailMinAggregateOutputType | null
    _max: MailMaxAggregateOutputType | null
  }

  export type MailAvgAggregateOutputType = {
    retryCount: number | null
  }

  export type MailSumAggregateOutputType = {
    retryCount: number | null
  }

  export type MailMinAggregateOutputType = {
    id: string | null
    fromEmail: string | null
    fromName: string | null
    toEmail: string | null
    toName: string | null
    subject: string | null
    bodyText: string | null
    bodyHtml: string | null
    status: $Enums.MailStatus | null
    mailType: $Enums.MailType | null
    templateCode: string | null
    errorMessage: string | null
    userId: string | null
    retryCount: number | null
    scheduledAt: Date | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type MailMaxAggregateOutputType = {
    id: string | null
    fromEmail: string | null
    fromName: string | null
    toEmail: string | null
    toName: string | null
    subject: string | null
    bodyText: string | null
    bodyHtml: string | null
    status: $Enums.MailStatus | null
    mailType: $Enums.MailType | null
    templateCode: string | null
    errorMessage: string | null
    userId: string | null
    retryCount: number | null
    scheduledAt: Date | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type MailCountAggregateOutputType = {
    id: number
    fromEmail: number
    fromName: number
    toEmail: number
    toName: number
    ccEmail: number
    bccEmail: number
    subject: number
    bodyText: number
    bodyHtml: number
    status: number
    mailType: number
    templateCode: number
    templateVariables: number
    errorMessage: number
    userId: number
    retryCount: number
    scheduledAt: number
    sentAt: number
    createdAt: number
    _all: number
  }


  export type MailAvgAggregateInputType = {
    retryCount?: true
  }

  export type MailSumAggregateInputType = {
    retryCount?: true
  }

  export type MailMinAggregateInputType = {
    id?: true
    fromEmail?: true
    fromName?: true
    toEmail?: true
    toName?: true
    subject?: true
    bodyText?: true
    bodyHtml?: true
    status?: true
    mailType?: true
    templateCode?: true
    errorMessage?: true
    userId?: true
    retryCount?: true
    scheduledAt?: true
    sentAt?: true
    createdAt?: true
  }

  export type MailMaxAggregateInputType = {
    id?: true
    fromEmail?: true
    fromName?: true
    toEmail?: true
    toName?: true
    subject?: true
    bodyText?: true
    bodyHtml?: true
    status?: true
    mailType?: true
    templateCode?: true
    errorMessage?: true
    userId?: true
    retryCount?: true
    scheduledAt?: true
    sentAt?: true
    createdAt?: true
  }

  export type MailCountAggregateInputType = {
    id?: true
    fromEmail?: true
    fromName?: true
    toEmail?: true
    toName?: true
    ccEmail?: true
    bccEmail?: true
    subject?: true
    bodyText?: true
    bodyHtml?: true
    status?: true
    mailType?: true
    templateCode?: true
    templateVariables?: true
    errorMessage?: true
    userId?: true
    retryCount?: true
    scheduledAt?: true
    sentAt?: true
    createdAt?: true
    _all?: true
  }

  export type MailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mail to aggregate.
     */
    where?: MailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mail to fetch.
     */
    orderBy?: MailOrderByWithRelationInput | MailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mail from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mail.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mail
    **/
    _count?: true | MailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MailMaxAggregateInputType
  }

  export type GetMailAggregateType<T extends MailAggregateArgs> = {
        [P in keyof T & keyof AggregateMail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMail[P]>
      : GetScalarType<T[P], AggregateMail[P]>
  }




  export type MailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MailWhereInput
    orderBy?: MailOrderByWithAggregationInput | MailOrderByWithAggregationInput[]
    by: MailScalarFieldEnum[] | MailScalarFieldEnum
    having?: MailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MailCountAggregateInputType | true
    _avg?: MailAvgAggregateInputType
    _sum?: MailSumAggregateInputType
    _min?: MailMinAggregateInputType
    _max?: MailMaxAggregateInputType
  }

  export type MailGroupByOutputType = {
    id: string
    fromEmail: string
    fromName: string | null
    toEmail: string
    toName: string | null
    ccEmail: string[]
    bccEmail: string[]
    subject: string
    bodyText: string
    bodyHtml: string | null
    status: $Enums.MailStatus
    mailType: $Enums.MailType
    templateCode: string | null
    templateVariables: JsonValue | null
    errorMessage: string | null
    userId: string | null
    retryCount: number
    scheduledAt: Date | null
    sentAt: Date | null
    createdAt: Date
    _count: MailCountAggregateOutputType | null
    _avg: MailAvgAggregateOutputType | null
    _sum: MailSumAggregateOutputType | null
    _min: MailMinAggregateOutputType | null
    _max: MailMaxAggregateOutputType | null
  }

  type GetMailGroupByPayload<T extends MailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MailGroupByOutputType[P]>
            : GetScalarType<T[P], MailGroupByOutputType[P]>
        }
      >
    >


  export type MailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromEmail?: boolean
    fromName?: boolean
    toEmail?: boolean
    toName?: boolean
    ccEmail?: boolean
    bccEmail?: boolean
    subject?: boolean
    bodyText?: boolean
    bodyHtml?: boolean
    status?: boolean
    mailType?: boolean
    templateCode?: boolean
    templateVariables?: boolean
    errorMessage?: boolean
    userId?: boolean
    retryCount?: boolean
    scheduledAt?: boolean
    sentAt?: boolean
    createdAt?: boolean
    user?: boolean | Mail$userArgs<ExtArgs>
  }, ExtArgs["result"]["mail"]>

  export type MailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromEmail?: boolean
    fromName?: boolean
    toEmail?: boolean
    toName?: boolean
    ccEmail?: boolean
    bccEmail?: boolean
    subject?: boolean
    bodyText?: boolean
    bodyHtml?: boolean
    status?: boolean
    mailType?: boolean
    templateCode?: boolean
    templateVariables?: boolean
    errorMessage?: boolean
    userId?: boolean
    retryCount?: boolean
    scheduledAt?: boolean
    sentAt?: boolean
    createdAt?: boolean
    user?: boolean | Mail$userArgs<ExtArgs>
  }, ExtArgs["result"]["mail"]>

  export type MailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromEmail?: boolean
    fromName?: boolean
    toEmail?: boolean
    toName?: boolean
    ccEmail?: boolean
    bccEmail?: boolean
    subject?: boolean
    bodyText?: boolean
    bodyHtml?: boolean
    status?: boolean
    mailType?: boolean
    templateCode?: boolean
    templateVariables?: boolean
    errorMessage?: boolean
    userId?: boolean
    retryCount?: boolean
    scheduledAt?: boolean
    sentAt?: boolean
    createdAt?: boolean
    user?: boolean | Mail$userArgs<ExtArgs>
  }, ExtArgs["result"]["mail"]>

  export type MailSelectScalar = {
    id?: boolean
    fromEmail?: boolean
    fromName?: boolean
    toEmail?: boolean
    toName?: boolean
    ccEmail?: boolean
    bccEmail?: boolean
    subject?: boolean
    bodyText?: boolean
    bodyHtml?: boolean
    status?: boolean
    mailType?: boolean
    templateCode?: boolean
    templateVariables?: boolean
    errorMessage?: boolean
    userId?: boolean
    retryCount?: boolean
    scheduledAt?: boolean
    sentAt?: boolean
    createdAt?: boolean
  }

  export type MailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fromEmail" | "fromName" | "toEmail" | "toName" | "ccEmail" | "bccEmail" | "subject" | "bodyText" | "bodyHtml" | "status" | "mailType" | "templateCode" | "templateVariables" | "errorMessage" | "userId" | "retryCount" | "scheduledAt" | "sentAt" | "createdAt", ExtArgs["result"]["mail"]>
  export type MailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Mail$userArgs<ExtArgs>
  }
  export type MailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Mail$userArgs<ExtArgs>
  }
  export type MailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Mail$userArgs<ExtArgs>
  }

  export type $MailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mail"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromEmail: string
      fromName: string | null
      toEmail: string
      toName: string | null
      ccEmail: string[]
      bccEmail: string[]
      subject: string
      bodyText: string
      bodyHtml: string | null
      status: $Enums.MailStatus
      mailType: $Enums.MailType
      templateCode: string | null
      templateVariables: Prisma.JsonValue | null
      errorMessage: string | null
      userId: string | null
      retryCount: number
      scheduledAt: Date | null
      sentAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["mail"]>
    composites: {}
  }

  type MailGetPayload<S extends boolean | null | undefined | MailDefaultArgs> = $Result.GetResult<Prisma.$MailPayload, S>

  type MailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MailCountAggregateInputType | true
    }

  export interface MailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mail'], meta: { name: 'Mail' } }
    /**
     * Find zero or one Mail that matches the filter.
     * @param {MailFindUniqueArgs} args - Arguments to find a Mail
     * @example
     * // Get one Mail
     * const mail = await prisma.mail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MailFindUniqueArgs>(args: SelectSubset<T, MailFindUniqueArgs<ExtArgs>>): Prisma__MailClient<$Result.GetResult<Prisma.$MailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MailFindUniqueOrThrowArgs} args - Arguments to find a Mail
     * @example
     * // Get one Mail
     * const mail = await prisma.mail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MailFindUniqueOrThrowArgs>(args: SelectSubset<T, MailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MailClient<$Result.GetResult<Prisma.$MailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailFindFirstArgs} args - Arguments to find a Mail
     * @example
     * // Get one Mail
     * const mail = await prisma.mail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MailFindFirstArgs>(args?: SelectSubset<T, MailFindFirstArgs<ExtArgs>>): Prisma__MailClient<$Result.GetResult<Prisma.$MailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailFindFirstOrThrowArgs} args - Arguments to find a Mail
     * @example
     * // Get one Mail
     * const mail = await prisma.mail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MailFindFirstOrThrowArgs>(args?: SelectSubset<T, MailFindFirstOrThrowArgs<ExtArgs>>): Prisma__MailClient<$Result.GetResult<Prisma.$MailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mail
     * const mail = await prisma.mail.findMany()
     * 
     * // Get first 10 Mail
     * const mail = await prisma.mail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mailWithIdOnly = await prisma.mail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MailFindManyArgs>(args?: SelectSubset<T, MailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mail.
     * @param {MailCreateArgs} args - Arguments to create a Mail.
     * @example
     * // Create one Mail
     * const Mail = await prisma.mail.create({
     *   data: {
     *     // ... data to create a Mail
     *   }
     * })
     * 
     */
    create<T extends MailCreateArgs>(args: SelectSubset<T, MailCreateArgs<ExtArgs>>): Prisma__MailClient<$Result.GetResult<Prisma.$MailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mail.
     * @param {MailCreateManyArgs} args - Arguments to create many Mail.
     * @example
     * // Create many Mail
     * const mail = await prisma.mail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MailCreateManyArgs>(args?: SelectSubset<T, MailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mail and returns the data saved in the database.
     * @param {MailCreateManyAndReturnArgs} args - Arguments to create many Mail.
     * @example
     * // Create many Mail
     * const mail = await prisma.mail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mail and only return the `id`
     * const mailWithIdOnly = await prisma.mail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MailCreateManyAndReturnArgs>(args?: SelectSubset<T, MailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mail.
     * @param {MailDeleteArgs} args - Arguments to delete one Mail.
     * @example
     * // Delete one Mail
     * const Mail = await prisma.mail.delete({
     *   where: {
     *     // ... filter to delete one Mail
     *   }
     * })
     * 
     */
    delete<T extends MailDeleteArgs>(args: SelectSubset<T, MailDeleteArgs<ExtArgs>>): Prisma__MailClient<$Result.GetResult<Prisma.$MailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mail.
     * @param {MailUpdateArgs} args - Arguments to update one Mail.
     * @example
     * // Update one Mail
     * const mail = await prisma.mail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MailUpdateArgs>(args: SelectSubset<T, MailUpdateArgs<ExtArgs>>): Prisma__MailClient<$Result.GetResult<Prisma.$MailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mail.
     * @param {MailDeleteManyArgs} args - Arguments to filter Mail to delete.
     * @example
     * // Delete a few Mail
     * const { count } = await prisma.mail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MailDeleteManyArgs>(args?: SelectSubset<T, MailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mail
     * const mail = await prisma.mail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MailUpdateManyArgs>(args: SelectSubset<T, MailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mail and returns the data updated in the database.
     * @param {MailUpdateManyAndReturnArgs} args - Arguments to update many Mail.
     * @example
     * // Update many Mail
     * const mail = await prisma.mail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mail and only return the `id`
     * const mailWithIdOnly = await prisma.mail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MailUpdateManyAndReturnArgs>(args: SelectSubset<T, MailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mail.
     * @param {MailUpsertArgs} args - Arguments to update or create a Mail.
     * @example
     * // Update or create a Mail
     * const mail = await prisma.mail.upsert({
     *   create: {
     *     // ... data to create a Mail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mail we want to update
     *   }
     * })
     */
    upsert<T extends MailUpsertArgs>(args: SelectSubset<T, MailUpsertArgs<ExtArgs>>): Prisma__MailClient<$Result.GetResult<Prisma.$MailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailCountArgs} args - Arguments to filter Mail to count.
     * @example
     * // Count the number of Mail
     * const count = await prisma.mail.count({
     *   where: {
     *     // ... the filter for the Mail we want to count
     *   }
     * })
    **/
    count<T extends MailCountArgs>(
      args?: Subset<T, MailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MailAggregateArgs>(args: Subset<T, MailAggregateArgs>): Prisma.PrismaPromise<GetMailAggregateType<T>>

    /**
     * Group by Mail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MailGroupByArgs['orderBy'] }
        : { orderBy?: MailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mail model
   */
  readonly fields: MailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Mail$userArgs<ExtArgs> = {}>(args?: Subset<T, Mail$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mail model
   */
  interface MailFieldRefs {
    readonly id: FieldRef<"Mail", 'String'>
    readonly fromEmail: FieldRef<"Mail", 'String'>
    readonly fromName: FieldRef<"Mail", 'String'>
    readonly toEmail: FieldRef<"Mail", 'String'>
    readonly toName: FieldRef<"Mail", 'String'>
    readonly ccEmail: FieldRef<"Mail", 'String[]'>
    readonly bccEmail: FieldRef<"Mail", 'String[]'>
    readonly subject: FieldRef<"Mail", 'String'>
    readonly bodyText: FieldRef<"Mail", 'String'>
    readonly bodyHtml: FieldRef<"Mail", 'String'>
    readonly status: FieldRef<"Mail", 'MailStatus'>
    readonly mailType: FieldRef<"Mail", 'MailType'>
    readonly templateCode: FieldRef<"Mail", 'String'>
    readonly templateVariables: FieldRef<"Mail", 'Json'>
    readonly errorMessage: FieldRef<"Mail", 'String'>
    readonly userId: FieldRef<"Mail", 'String'>
    readonly retryCount: FieldRef<"Mail", 'Int'>
    readonly scheduledAt: FieldRef<"Mail", 'DateTime'>
    readonly sentAt: FieldRef<"Mail", 'DateTime'>
    readonly createdAt: FieldRef<"Mail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mail findUnique
   */
  export type MailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mail
     */
    select?: MailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mail
     */
    omit?: MailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailInclude<ExtArgs> | null
    /**
     * Filter, which Mail to fetch.
     */
    where: MailWhereUniqueInput
  }

  /**
   * Mail findUniqueOrThrow
   */
  export type MailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mail
     */
    select?: MailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mail
     */
    omit?: MailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailInclude<ExtArgs> | null
    /**
     * Filter, which Mail to fetch.
     */
    where: MailWhereUniqueInput
  }

  /**
   * Mail findFirst
   */
  export type MailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mail
     */
    select?: MailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mail
     */
    omit?: MailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailInclude<ExtArgs> | null
    /**
     * Filter, which Mail to fetch.
     */
    where?: MailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mail to fetch.
     */
    orderBy?: MailOrderByWithRelationInput | MailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mail.
     */
    cursor?: MailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mail from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mail.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mail.
     */
    distinct?: MailScalarFieldEnum | MailScalarFieldEnum[]
  }

  /**
   * Mail findFirstOrThrow
   */
  export type MailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mail
     */
    select?: MailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mail
     */
    omit?: MailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailInclude<ExtArgs> | null
    /**
     * Filter, which Mail to fetch.
     */
    where?: MailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mail to fetch.
     */
    orderBy?: MailOrderByWithRelationInput | MailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mail.
     */
    cursor?: MailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mail from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mail.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mail.
     */
    distinct?: MailScalarFieldEnum | MailScalarFieldEnum[]
  }

  /**
   * Mail findMany
   */
  export type MailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mail
     */
    select?: MailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mail
     */
    omit?: MailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailInclude<ExtArgs> | null
    /**
     * Filter, which Mail to fetch.
     */
    where?: MailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mail to fetch.
     */
    orderBy?: MailOrderByWithRelationInput | MailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mail.
     */
    cursor?: MailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mail from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mail.
     */
    skip?: number
    distinct?: MailScalarFieldEnum | MailScalarFieldEnum[]
  }

  /**
   * Mail create
   */
  export type MailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mail
     */
    select?: MailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mail
     */
    omit?: MailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailInclude<ExtArgs> | null
    /**
     * The data needed to create a Mail.
     */
    data: XOR<MailCreateInput, MailUncheckedCreateInput>
  }

  /**
   * Mail createMany
   */
  export type MailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mail.
     */
    data: MailCreateManyInput | MailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mail createManyAndReturn
   */
  export type MailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mail
     */
    select?: MailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mail
     */
    omit?: MailOmit<ExtArgs> | null
    /**
     * The data used to create many Mail.
     */
    data: MailCreateManyInput | MailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mail update
   */
  export type MailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mail
     */
    select?: MailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mail
     */
    omit?: MailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailInclude<ExtArgs> | null
    /**
     * The data needed to update a Mail.
     */
    data: XOR<MailUpdateInput, MailUncheckedUpdateInput>
    /**
     * Choose, which Mail to update.
     */
    where: MailWhereUniqueInput
  }

  /**
   * Mail updateMany
   */
  export type MailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mail.
     */
    data: XOR<MailUpdateManyMutationInput, MailUncheckedUpdateManyInput>
    /**
     * Filter which Mail to update
     */
    where?: MailWhereInput
    /**
     * Limit how many Mail to update.
     */
    limit?: number
  }

  /**
   * Mail updateManyAndReturn
   */
  export type MailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mail
     */
    select?: MailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mail
     */
    omit?: MailOmit<ExtArgs> | null
    /**
     * The data used to update Mail.
     */
    data: XOR<MailUpdateManyMutationInput, MailUncheckedUpdateManyInput>
    /**
     * Filter which Mail to update
     */
    where?: MailWhereInput
    /**
     * Limit how many Mail to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mail upsert
   */
  export type MailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mail
     */
    select?: MailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mail
     */
    omit?: MailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailInclude<ExtArgs> | null
    /**
     * The filter to search for the Mail to update in case it exists.
     */
    where: MailWhereUniqueInput
    /**
     * In case the Mail found by the `where` argument doesn't exist, create a new Mail with this data.
     */
    create: XOR<MailCreateInput, MailUncheckedCreateInput>
    /**
     * In case the Mail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MailUpdateInput, MailUncheckedUpdateInput>
  }

  /**
   * Mail delete
   */
  export type MailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mail
     */
    select?: MailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mail
     */
    omit?: MailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailInclude<ExtArgs> | null
    /**
     * Filter which Mail to delete.
     */
    where: MailWhereUniqueInput
  }

  /**
   * Mail deleteMany
   */
  export type MailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mail to delete
     */
    where?: MailWhereInput
    /**
     * Limit how many Mail to delete.
     */
    limit?: number
  }

  /**
   * Mail.user
   */
  export type Mail$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Mail without action
   */
  export type MailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mail
     */
    select?: MailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mail
     */
    omit?: MailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailInclude<ExtArgs> | null
  }


  /**
   * Model FileBox
   */

  export type AggregateFileBox = {
    _count: FileBoxCountAggregateOutputType | null
    _avg: FileBoxAvgAggregateOutputType | null
    _sum: FileBoxSumAggregateOutputType | null
    _min: FileBoxMinAggregateOutputType | null
    _max: FileBoxMaxAggregateOutputType | null
  }

  export type FileBoxAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type FileBoxSumAggregateOutputType = {
    fileSize: bigint | null
  }

  export type FileBoxMinAggregateOutputType = {
    id: string | null
    bucketName: string | null
    storagePath: string | null
    fileName: string | null
    originalName: string | null
    publicUrl: string | null
    mimeType: string | null
    fileSize: bigint | null
    category: string | null
    userId: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type FileBoxMaxAggregateOutputType = {
    id: string | null
    bucketName: string | null
    storagePath: string | null
    fileName: string | null
    originalName: string | null
    publicUrl: string | null
    mimeType: string | null
    fileSize: bigint | null
    category: string | null
    userId: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type FileBoxCountAggregateOutputType = {
    id: number
    bucketName: number
    storagePath: number
    fileName: number
    originalName: number
    publicUrl: number
    mimeType: number
    fileSize: number
    category: number
    metadata: number
    userId: number
    isPublic: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type FileBoxAvgAggregateInputType = {
    fileSize?: true
  }

  export type FileBoxSumAggregateInputType = {
    fileSize?: true
  }

  export type FileBoxMinAggregateInputType = {
    id?: true
    bucketName?: true
    storagePath?: true
    fileName?: true
    originalName?: true
    publicUrl?: true
    mimeType?: true
    fileSize?: true
    category?: true
    userId?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type FileBoxMaxAggregateInputType = {
    id?: true
    bucketName?: true
    storagePath?: true
    fileName?: true
    originalName?: true
    publicUrl?: true
    mimeType?: true
    fileSize?: true
    category?: true
    userId?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type FileBoxCountAggregateInputType = {
    id?: true
    bucketName?: true
    storagePath?: true
    fileName?: true
    originalName?: true
    publicUrl?: true
    mimeType?: true
    fileSize?: true
    category?: true
    metadata?: true
    userId?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type FileBoxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileBox to aggregate.
     */
    where?: FileBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileBoxes to fetch.
     */
    orderBy?: FileBoxOrderByWithRelationInput | FileBoxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileBoxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileBoxes
    **/
    _count?: true | FileBoxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileBoxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileBoxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileBoxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileBoxMaxAggregateInputType
  }

  export type GetFileBoxAggregateType<T extends FileBoxAggregateArgs> = {
        [P in keyof T & keyof AggregateFileBox]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileBox[P]>
      : GetScalarType<T[P], AggregateFileBox[P]>
  }




  export type FileBoxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileBoxWhereInput
    orderBy?: FileBoxOrderByWithAggregationInput | FileBoxOrderByWithAggregationInput[]
    by: FileBoxScalarFieldEnum[] | FileBoxScalarFieldEnum
    having?: FileBoxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileBoxCountAggregateInputType | true
    _avg?: FileBoxAvgAggregateInputType
    _sum?: FileBoxSumAggregateInputType
    _min?: FileBoxMinAggregateInputType
    _max?: FileBoxMaxAggregateInputType
  }

  export type FileBoxGroupByOutputType = {
    id: string
    bucketName: string
    storagePath: string
    fileName: string
    originalName: string
    publicUrl: string | null
    mimeType: string
    fileSize: bigint
    category: string | null
    metadata: JsonValue | null
    userId: string | null
    isPublic: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: FileBoxCountAggregateOutputType | null
    _avg: FileBoxAvgAggregateOutputType | null
    _sum: FileBoxSumAggregateOutputType | null
    _min: FileBoxMinAggregateOutputType | null
    _max: FileBoxMaxAggregateOutputType | null
  }

  type GetFileBoxGroupByPayload<T extends FileBoxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileBoxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileBoxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileBoxGroupByOutputType[P]>
            : GetScalarType<T[P], FileBoxGroupByOutputType[P]>
        }
      >
    >


  export type FileBoxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bucketName?: boolean
    storagePath?: boolean
    fileName?: boolean
    originalName?: boolean
    publicUrl?: boolean
    mimeType?: boolean
    fileSize?: boolean
    category?: boolean
    metadata?: boolean
    userId?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | FileBox$userArgs<ExtArgs>
    propertyImages?: boolean | FileBox$propertyImagesArgs<ExtArgs>
    _count?: boolean | FileBoxCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileBox"]>

  export type FileBoxSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bucketName?: boolean
    storagePath?: boolean
    fileName?: boolean
    originalName?: boolean
    publicUrl?: boolean
    mimeType?: boolean
    fileSize?: boolean
    category?: boolean
    metadata?: boolean
    userId?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | FileBox$userArgs<ExtArgs>
  }, ExtArgs["result"]["fileBox"]>

  export type FileBoxSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bucketName?: boolean
    storagePath?: boolean
    fileName?: boolean
    originalName?: boolean
    publicUrl?: boolean
    mimeType?: boolean
    fileSize?: boolean
    category?: boolean
    metadata?: boolean
    userId?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | FileBox$userArgs<ExtArgs>
  }, ExtArgs["result"]["fileBox"]>

  export type FileBoxSelectScalar = {
    id?: boolean
    bucketName?: boolean
    storagePath?: boolean
    fileName?: boolean
    originalName?: boolean
    publicUrl?: boolean
    mimeType?: boolean
    fileSize?: boolean
    category?: boolean
    metadata?: boolean
    userId?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type FileBoxOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bucketName" | "storagePath" | "fileName" | "originalName" | "publicUrl" | "mimeType" | "fileSize" | "category" | "metadata" | "userId" | "isPublic" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["fileBox"]>
  export type FileBoxInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | FileBox$userArgs<ExtArgs>
    propertyImages?: boolean | FileBox$propertyImagesArgs<ExtArgs>
    _count?: boolean | FileBoxCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FileBoxIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | FileBox$userArgs<ExtArgs>
  }
  export type FileBoxIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | FileBox$userArgs<ExtArgs>
  }

  export type $FileBoxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileBox"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      propertyImages: Prisma.$PropertyImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bucketName: string
      storagePath: string
      fileName: string
      originalName: string
      publicUrl: string | null
      mimeType: string
      fileSize: bigint
      category: string | null
      metadata: Prisma.JsonValue | null
      userId: string | null
      isPublic: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["fileBox"]>
    composites: {}
  }

  type FileBoxGetPayload<S extends boolean | null | undefined | FileBoxDefaultArgs> = $Result.GetResult<Prisma.$FileBoxPayload, S>

  type FileBoxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileBoxFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileBoxCountAggregateInputType | true
    }

  export interface FileBoxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileBox'], meta: { name: 'FileBox' } }
    /**
     * Find zero or one FileBox that matches the filter.
     * @param {FileBoxFindUniqueArgs} args - Arguments to find a FileBox
     * @example
     * // Get one FileBox
     * const fileBox = await prisma.fileBox.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileBoxFindUniqueArgs>(args: SelectSubset<T, FileBoxFindUniqueArgs<ExtArgs>>): Prisma__FileBoxClient<$Result.GetResult<Prisma.$FileBoxPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FileBox that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileBoxFindUniqueOrThrowArgs} args - Arguments to find a FileBox
     * @example
     * // Get one FileBox
     * const fileBox = await prisma.fileBox.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileBoxFindUniqueOrThrowArgs>(args: SelectSubset<T, FileBoxFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileBoxClient<$Result.GetResult<Prisma.$FileBoxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileBox that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileBoxFindFirstArgs} args - Arguments to find a FileBox
     * @example
     * // Get one FileBox
     * const fileBox = await prisma.fileBox.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileBoxFindFirstArgs>(args?: SelectSubset<T, FileBoxFindFirstArgs<ExtArgs>>): Prisma__FileBoxClient<$Result.GetResult<Prisma.$FileBoxPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileBox that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileBoxFindFirstOrThrowArgs} args - Arguments to find a FileBox
     * @example
     * // Get one FileBox
     * const fileBox = await prisma.fileBox.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileBoxFindFirstOrThrowArgs>(args?: SelectSubset<T, FileBoxFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileBoxClient<$Result.GetResult<Prisma.$FileBoxPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileBoxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileBoxFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileBoxes
     * const fileBoxes = await prisma.fileBox.findMany()
     * 
     * // Get first 10 FileBoxes
     * const fileBoxes = await prisma.fileBox.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileBoxWithIdOnly = await prisma.fileBox.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileBoxFindManyArgs>(args?: SelectSubset<T, FileBoxFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileBoxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FileBox.
     * @param {FileBoxCreateArgs} args - Arguments to create a FileBox.
     * @example
     * // Create one FileBox
     * const FileBox = await prisma.fileBox.create({
     *   data: {
     *     // ... data to create a FileBox
     *   }
     * })
     * 
     */
    create<T extends FileBoxCreateArgs>(args: SelectSubset<T, FileBoxCreateArgs<ExtArgs>>): Prisma__FileBoxClient<$Result.GetResult<Prisma.$FileBoxPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FileBoxes.
     * @param {FileBoxCreateManyArgs} args - Arguments to create many FileBoxes.
     * @example
     * // Create many FileBoxes
     * const fileBox = await prisma.fileBox.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileBoxCreateManyArgs>(args?: SelectSubset<T, FileBoxCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileBoxes and returns the data saved in the database.
     * @param {FileBoxCreateManyAndReturnArgs} args - Arguments to create many FileBoxes.
     * @example
     * // Create many FileBoxes
     * const fileBox = await prisma.fileBox.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileBoxes and only return the `id`
     * const fileBoxWithIdOnly = await prisma.fileBox.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileBoxCreateManyAndReturnArgs>(args?: SelectSubset<T, FileBoxCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileBoxPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FileBox.
     * @param {FileBoxDeleteArgs} args - Arguments to delete one FileBox.
     * @example
     * // Delete one FileBox
     * const FileBox = await prisma.fileBox.delete({
     *   where: {
     *     // ... filter to delete one FileBox
     *   }
     * })
     * 
     */
    delete<T extends FileBoxDeleteArgs>(args: SelectSubset<T, FileBoxDeleteArgs<ExtArgs>>): Prisma__FileBoxClient<$Result.GetResult<Prisma.$FileBoxPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FileBox.
     * @param {FileBoxUpdateArgs} args - Arguments to update one FileBox.
     * @example
     * // Update one FileBox
     * const fileBox = await prisma.fileBox.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileBoxUpdateArgs>(args: SelectSubset<T, FileBoxUpdateArgs<ExtArgs>>): Prisma__FileBoxClient<$Result.GetResult<Prisma.$FileBoxPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FileBoxes.
     * @param {FileBoxDeleteManyArgs} args - Arguments to filter FileBoxes to delete.
     * @example
     * // Delete a few FileBoxes
     * const { count } = await prisma.fileBox.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileBoxDeleteManyArgs>(args?: SelectSubset<T, FileBoxDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileBoxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileBoxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileBoxes
     * const fileBox = await prisma.fileBox.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileBoxUpdateManyArgs>(args: SelectSubset<T, FileBoxUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileBoxes and returns the data updated in the database.
     * @param {FileBoxUpdateManyAndReturnArgs} args - Arguments to update many FileBoxes.
     * @example
     * // Update many FileBoxes
     * const fileBox = await prisma.fileBox.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FileBoxes and only return the `id`
     * const fileBoxWithIdOnly = await prisma.fileBox.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileBoxUpdateManyAndReturnArgs>(args: SelectSubset<T, FileBoxUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileBoxPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FileBox.
     * @param {FileBoxUpsertArgs} args - Arguments to update or create a FileBox.
     * @example
     * // Update or create a FileBox
     * const fileBox = await prisma.fileBox.upsert({
     *   create: {
     *     // ... data to create a FileBox
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileBox we want to update
     *   }
     * })
     */
    upsert<T extends FileBoxUpsertArgs>(args: SelectSubset<T, FileBoxUpsertArgs<ExtArgs>>): Prisma__FileBoxClient<$Result.GetResult<Prisma.$FileBoxPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FileBoxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileBoxCountArgs} args - Arguments to filter FileBoxes to count.
     * @example
     * // Count the number of FileBoxes
     * const count = await prisma.fileBox.count({
     *   where: {
     *     // ... the filter for the FileBoxes we want to count
     *   }
     * })
    **/
    count<T extends FileBoxCountArgs>(
      args?: Subset<T, FileBoxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileBoxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileBox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileBoxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileBoxAggregateArgs>(args: Subset<T, FileBoxAggregateArgs>): Prisma.PrismaPromise<GetFileBoxAggregateType<T>>

    /**
     * Group by FileBox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileBoxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileBoxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileBoxGroupByArgs['orderBy'] }
        : { orderBy?: FileBoxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileBoxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileBoxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileBox model
   */
  readonly fields: FileBoxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileBox.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileBoxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends FileBox$userArgs<ExtArgs> = {}>(args?: Subset<T, FileBox$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    propertyImages<T extends FileBox$propertyImagesArgs<ExtArgs> = {}>(args?: Subset<T, FileBox$propertyImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileBox model
   */
  interface FileBoxFieldRefs {
    readonly id: FieldRef<"FileBox", 'String'>
    readonly bucketName: FieldRef<"FileBox", 'String'>
    readonly storagePath: FieldRef<"FileBox", 'String'>
    readonly fileName: FieldRef<"FileBox", 'String'>
    readonly originalName: FieldRef<"FileBox", 'String'>
    readonly publicUrl: FieldRef<"FileBox", 'String'>
    readonly mimeType: FieldRef<"FileBox", 'String'>
    readonly fileSize: FieldRef<"FileBox", 'BigInt'>
    readonly category: FieldRef<"FileBox", 'String'>
    readonly metadata: FieldRef<"FileBox", 'Json'>
    readonly userId: FieldRef<"FileBox", 'String'>
    readonly isPublic: FieldRef<"FileBox", 'Boolean'>
    readonly createdAt: FieldRef<"FileBox", 'DateTime'>
    readonly updatedAt: FieldRef<"FileBox", 'DateTime'>
    readonly deletedAt: FieldRef<"FileBox", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FileBox findUnique
   */
  export type FileBoxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileBox
     */
    select?: FileBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileBox
     */
    omit?: FileBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileBoxInclude<ExtArgs> | null
    /**
     * Filter, which FileBox to fetch.
     */
    where: FileBoxWhereUniqueInput
  }

  /**
   * FileBox findUniqueOrThrow
   */
  export type FileBoxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileBox
     */
    select?: FileBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileBox
     */
    omit?: FileBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileBoxInclude<ExtArgs> | null
    /**
     * Filter, which FileBox to fetch.
     */
    where: FileBoxWhereUniqueInput
  }

  /**
   * FileBox findFirst
   */
  export type FileBoxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileBox
     */
    select?: FileBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileBox
     */
    omit?: FileBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileBoxInclude<ExtArgs> | null
    /**
     * Filter, which FileBox to fetch.
     */
    where?: FileBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileBoxes to fetch.
     */
    orderBy?: FileBoxOrderByWithRelationInput | FileBoxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileBoxes.
     */
    cursor?: FileBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileBoxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileBoxes.
     */
    distinct?: FileBoxScalarFieldEnum | FileBoxScalarFieldEnum[]
  }

  /**
   * FileBox findFirstOrThrow
   */
  export type FileBoxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileBox
     */
    select?: FileBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileBox
     */
    omit?: FileBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileBoxInclude<ExtArgs> | null
    /**
     * Filter, which FileBox to fetch.
     */
    where?: FileBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileBoxes to fetch.
     */
    orderBy?: FileBoxOrderByWithRelationInput | FileBoxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileBoxes.
     */
    cursor?: FileBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileBoxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileBoxes.
     */
    distinct?: FileBoxScalarFieldEnum | FileBoxScalarFieldEnum[]
  }

  /**
   * FileBox findMany
   */
  export type FileBoxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileBox
     */
    select?: FileBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileBox
     */
    omit?: FileBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileBoxInclude<ExtArgs> | null
    /**
     * Filter, which FileBoxes to fetch.
     */
    where?: FileBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileBoxes to fetch.
     */
    orderBy?: FileBoxOrderByWithRelationInput | FileBoxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileBoxes.
     */
    cursor?: FileBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileBoxes.
     */
    skip?: number
    distinct?: FileBoxScalarFieldEnum | FileBoxScalarFieldEnum[]
  }

  /**
   * FileBox create
   */
  export type FileBoxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileBox
     */
    select?: FileBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileBox
     */
    omit?: FileBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileBoxInclude<ExtArgs> | null
    /**
     * The data needed to create a FileBox.
     */
    data: XOR<FileBoxCreateInput, FileBoxUncheckedCreateInput>
  }

  /**
   * FileBox createMany
   */
  export type FileBoxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileBoxes.
     */
    data: FileBoxCreateManyInput | FileBoxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileBox createManyAndReturn
   */
  export type FileBoxCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileBox
     */
    select?: FileBoxSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileBox
     */
    omit?: FileBoxOmit<ExtArgs> | null
    /**
     * The data used to create many FileBoxes.
     */
    data: FileBoxCreateManyInput | FileBoxCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileBoxIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileBox update
   */
  export type FileBoxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileBox
     */
    select?: FileBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileBox
     */
    omit?: FileBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileBoxInclude<ExtArgs> | null
    /**
     * The data needed to update a FileBox.
     */
    data: XOR<FileBoxUpdateInput, FileBoxUncheckedUpdateInput>
    /**
     * Choose, which FileBox to update.
     */
    where: FileBoxWhereUniqueInput
  }

  /**
   * FileBox updateMany
   */
  export type FileBoxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileBoxes.
     */
    data: XOR<FileBoxUpdateManyMutationInput, FileBoxUncheckedUpdateManyInput>
    /**
     * Filter which FileBoxes to update
     */
    where?: FileBoxWhereInput
    /**
     * Limit how many FileBoxes to update.
     */
    limit?: number
  }

  /**
   * FileBox updateManyAndReturn
   */
  export type FileBoxUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileBox
     */
    select?: FileBoxSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileBox
     */
    omit?: FileBoxOmit<ExtArgs> | null
    /**
     * The data used to update FileBoxes.
     */
    data: XOR<FileBoxUpdateManyMutationInput, FileBoxUncheckedUpdateManyInput>
    /**
     * Filter which FileBoxes to update
     */
    where?: FileBoxWhereInput
    /**
     * Limit how many FileBoxes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileBoxIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileBox upsert
   */
  export type FileBoxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileBox
     */
    select?: FileBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileBox
     */
    omit?: FileBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileBoxInclude<ExtArgs> | null
    /**
     * The filter to search for the FileBox to update in case it exists.
     */
    where: FileBoxWhereUniqueInput
    /**
     * In case the FileBox found by the `where` argument doesn't exist, create a new FileBox with this data.
     */
    create: XOR<FileBoxCreateInput, FileBoxUncheckedCreateInput>
    /**
     * In case the FileBox was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileBoxUpdateInput, FileBoxUncheckedUpdateInput>
  }

  /**
   * FileBox delete
   */
  export type FileBoxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileBox
     */
    select?: FileBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileBox
     */
    omit?: FileBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileBoxInclude<ExtArgs> | null
    /**
     * Filter which FileBox to delete.
     */
    where: FileBoxWhereUniqueInput
  }

  /**
   * FileBox deleteMany
   */
  export type FileBoxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileBoxes to delete
     */
    where?: FileBoxWhereInput
    /**
     * Limit how many FileBoxes to delete.
     */
    limit?: number
  }

  /**
   * FileBox.user
   */
  export type FileBox$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * FileBox.propertyImages
   */
  export type FileBox$propertyImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    where?: PropertyImageWhereInput
    orderBy?: PropertyImageOrderByWithRelationInput | PropertyImageOrderByWithRelationInput[]
    cursor?: PropertyImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyImageScalarFieldEnum | PropertyImageScalarFieldEnum[]
  }

  /**
   * FileBox without action
   */
  export type FileBoxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileBox
     */
    select?: FileBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileBox
     */
    omit?: FileBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileBoxInclude<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    valueType: string | null
    category: string | null
    description: string | null
    isPublic: boolean | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    valueType: string | null
    category: string | null
    description: string | null
    isPublic: boolean | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    valueType: number
    category: number
    description: number
    isPublic: number
    updatedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingMinAggregateInputType = {
    id?: true
    key?: true
    valueType?: true
    category?: true
    description?: true
    isPublic?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    id?: true
    key?: true
    valueType?: true
    category?: true
    description?: true
    isPublic?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    valueType?: true
    category?: true
    description?: true
    isPublic?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    id: string
    key: string
    value: JsonValue
    valueType: string
    category: string | null
    description: string | null
    isPublic: boolean
    updatedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    valueType?: boolean
    category?: boolean
    description?: boolean
    isPublic?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean | SystemSetting$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    valueType?: boolean
    category?: boolean
    description?: boolean
    isPublic?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean | SystemSetting$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    valueType?: boolean
    category?: boolean
    description?: boolean
    isPublic?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean | SystemSetting$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    valueType?: boolean
    category?: boolean
    description?: boolean
    isPublic?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "valueType" | "category" | "description" | "isPublic" | "updatedById" | "createdAt" | "updatedAt", ExtArgs["result"]["systemSetting"]>
  export type SystemSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    updatedBy?: boolean | SystemSetting$updatedByArgs<ExtArgs>
  }
  export type SystemSettingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    updatedBy?: boolean | SystemSetting$updatedByArgs<ExtArgs>
  }
  export type SystemSettingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    updatedBy?: boolean | SystemSetting$updatedByArgs<ExtArgs>
  }

  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: Prisma.JsonValue
      valueType: string
      category: string | null
      description: string | null
      isPublic: boolean
      updatedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    updatedBy<T extends SystemSetting$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, SystemSetting$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */
  interface SystemSettingFieldRefs {
    readonly id: FieldRef<"SystemSetting", 'String'>
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'Json'>
    readonly valueType: FieldRef<"SystemSetting", 'String'>
    readonly category: FieldRef<"SystemSetting", 'String'>
    readonly description: FieldRef<"SystemSetting", 'String'>
    readonly isPublic: FieldRef<"SystemSetting", 'Boolean'>
    readonly updatedById: FieldRef<"SystemSetting", 'String'>
    readonly createdAt: FieldRef<"SystemSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting createManyAndReturn
   */
  export type SystemSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting updateManyAndReturn
   */
  export type SystemSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSetting.updatedBy
   */
  export type SystemSetting$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    tableName: string | null
    recordId: string | null
    action: $Enums.AuditAction | null
    userId: string | null
    userEmail: string | null
    ipAddress: string | null
    userAgent: string | null
    sessionId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    tableName: string | null
    recordId: string | null
    action: $Enums.AuditAction | null
    userId: string | null
    userEmail: string | null
    ipAddress: string | null
    userAgent: string | null
    sessionId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    tableName: number
    recordId: number
    action: number
    oldData: number
    newData: number
    changedFields: number
    userId: number
    userEmail: number
    ipAddress: number
    userAgent: number
    sessionId: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    action?: true
    userId?: true
    userEmail?: true
    ipAddress?: true
    userAgent?: true
    sessionId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    action?: true
    userId?: true
    userEmail?: true
    ipAddress?: true
    userAgent?: true
    sessionId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    action?: true
    oldData?: true
    newData?: true
    changedFields?: true
    userId?: true
    userEmail?: true
    ipAddress?: true
    userAgent?: true
    sessionId?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    tableName: string
    recordId: string
    action: $Enums.AuditAction
    oldData: JsonValue | null
    newData: JsonValue | null
    changedFields: string[]
    userId: string | null
    userEmail: string | null
    ipAddress: string | null
    userAgent: string | null
    sessionId: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    action?: boolean
    oldData?: boolean
    newData?: boolean
    changedFields?: boolean
    userId?: boolean
    userEmail?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    sessionId?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    action?: boolean
    oldData?: boolean
    newData?: boolean
    changedFields?: boolean
    userId?: boolean
    userEmail?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    sessionId?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    action?: boolean
    oldData?: boolean
    newData?: boolean
    changedFields?: boolean
    userId?: boolean
    userEmail?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    sessionId?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    action?: boolean
    oldData?: boolean
    newData?: boolean
    changedFields?: boolean
    userId?: boolean
    userEmail?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    sessionId?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableName" | "recordId" | "action" | "oldData" | "newData" | "changedFields" | "userId" | "userEmail" | "ipAddress" | "userAgent" | "sessionId" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tableName: string
      recordId: string
      action: $Enums.AuditAction
      oldData: Prisma.JsonValue | null
      newData: Prisma.JsonValue | null
      changedFields: string[]
      userId: string | null
      userEmail: string | null
      ipAddress: string | null
      userAgent: string | null
      sessionId: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly tableName: FieldRef<"AuditLog", 'String'>
    readonly recordId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'AuditAction'>
    readonly oldData: FieldRef<"AuditLog", 'Json'>
    readonly newData: FieldRef<"AuditLog", 'Json'>
    readonly changedFields: FieldRef<"AuditLog", 'String[]'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly userEmail: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly sessionId: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    linkUrl: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    linkUrl: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    linkUrl: number
    isRead: number
    readAt: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    linkUrl?: true
    isRead?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    linkUrl?: true
    isRead?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    linkUrl?: true
    isRead?: true
    readAt?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    message: string
    linkUrl: string | null
    isRead: boolean
    readAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    linkUrl?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    linkUrl?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    linkUrl?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    linkUrl?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "linkUrl" | "isRead" | "readAt" | "metadata" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      message: string
      linkUrl: string | null
      isRead: boolean
      readAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly linkUrl: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    furigana: 'furigana',
    gender: 'gender',
    birthDate: 'birthDate',
    phone: 'phone',
    avatarUrl: 'avatarUrl',
    status: 'status',
    emailVerifiedAt: 'emailVerifiedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    permissions: 'permissions',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId',
    createdAt: 'createdAt'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    companyNameKana: 'companyNameKana',
    representativeName: 'representativeName',
    postalCode: 'postalCode',
    prefecture: 'prefecture',
    city: 'city',
    address: 'address',
    latitude: 'latitude',
    longitude: 'longitude',
    phone: 'phone',
    fax: 'fax',
    website: 'website',
    licenseNumber: 'licenseNumber',
    associationMembership: 'associationMembership',
    accountType: 'accountType',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    id: 'id',
    branchName: 'branchName',
    postalCode: 'postalCode',
    prefecture: 'prefecture',
    city: 'city',
    address: 'address',
    latitude: 'latitude',
    longitude: 'longitude',
    phone: 'phone',
    fax: 'fax',
    businessHours: 'businessHours',
    isHeadquarters: 'isHeadquarters',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const AgentScalarFieldEnum: {
    id: 'id',
    position: 'position',
    department: 'department',
    licenseNumber: 'licenseNumber',
    licenseExpireDate: 'licenseExpireDate',
    goodCount: 'goodCount',
    responseRate: 'responseRate',
    avgResponseMinutes: 'avgResponseMinutes',
    userId: 'userId',
    branchId: 'branchId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    propertyCode: 'propertyCode',
    propertyName: 'propertyName',
    propertyNameKana: 'propertyNameKana',
    propertyTypeId: 'propertyTypeId',
    propertyCategoryId: 'propertyCategoryId',
    areaId: 'areaId',
    transactionType: 'transactionType',
    propertyCondition: 'propertyCondition',
    postalCode: 'postalCode',
    prefecture: 'prefecture',
    city: 'city',
    town: 'town',
    block: 'block',
    building: 'building',
    roomNumber: 'roomNumber',
    fullAddress: 'fullAddress',
    latitude: 'latitude',
    longitude: 'longitude',
    layoutNumber: 'layoutNumber',
    layoutTypeId: 'layoutTypeId',
    layoutDisplay: 'layoutDisplay',
    buildingArea: 'buildingArea',
    landArea: 'landArea',
    balconyArea: 'balconyArea',
    buildingStructure: 'buildingStructure',
    constructionDate: 'constructionDate',
    constructionYearMonth: 'constructionYearMonth',
    totalFloors: 'totalFloors',
    floor: 'floor',
    currentPrice: 'currentPrice',
    pricePerTsubo: 'pricePerTsubo',
    managementFee: 'managementFee',
    commonServiceFee: 'commonServiceFee',
    depositMonths: 'depositMonths',
    keyMoneyMonths: 'keyMoneyMonths',
    mainImageUrl: 'mainImageUrl',
    primaryStationName: 'primaryStationName',
    primaryStationWalkMinutes: 'primaryStationWalkMinutes',
    featureTags: 'featureTags',
    viewCount: 'viewCount',
    inquiryCount: 'inquiryCount',
    favoriteCount: 'favoriteCount',
    agentId: 'agentId',
    remarks: 'remarks',
    internalMemo: 'internalMemo',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    userId: 'userId'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const PropertyPublicationScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    status: 'status',
    scope: 'scope',
    featured: 'featured',
    featuredOrder: 'featuredOrder',
    publishedAt: 'publishedAt',
    unpublishedAt: 'unpublishedAt',
    soldAt: 'soldAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyPublicationScalarFieldEnum = (typeof PropertyPublicationScalarFieldEnum)[keyof typeof PropertyPublicationScalarFieldEnum]


  export const PropertyPriceHistoryScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    previousPrice: 'previousPrice',
    newPrice: 'newPrice',
    changePercent: 'changePercent',
    changeReason: 'changeReason',
    changedById: 'changedById',
    createdAt: 'createdAt'
  };

  export type PropertyPriceHistoryScalarFieldEnum = (typeof PropertyPriceHistoryScalarFieldEnum)[keyof typeof PropertyPriceHistoryScalarFieldEnum]


  export const PropertyStatusHistoryScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    previousStatus: 'previousStatus',
    newStatus: 'newStatus',
    changeReason: 'changeReason',
    changedById: 'changedById',
    createdAt: 'createdAt'
  };

  export type PropertyStatusHistoryScalarFieldEnum = (typeof PropertyStatusHistoryScalarFieldEnum)[keyof typeof PropertyStatusHistoryScalarFieldEnum]


  export const PropertyImageScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    fileBoxId: 'fileBoxId',
    url: 'url',
    thumbnailUrl: 'thumbnailUrl',
    caption: 'caption',
    imageType: 'imageType',
    displayOrder: 'displayOrder',
    isMain: 'isMain',
    width: 'width',
    height: 'height',
    createdAt: 'createdAt'
  };

  export type PropertyImageScalarFieldEnum = (typeof PropertyImageScalarFieldEnum)[keyof typeof PropertyImageScalarFieldEnum]


  export const PropertyFeatureScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    featureId: 'featureId'
  };

  export type PropertyFeatureScalarFieldEnum = (typeof PropertyFeatureScalarFieldEnum)[keyof typeof PropertyFeatureScalarFieldEnum]


  export const PropertyStationScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    stationId: 'stationId',
    walkMinutes: 'walkMinutes',
    busMinutes: 'busMinutes',
    busStopName: 'busStopName',
    isPrimary: 'isPrimary'
  };

  export type PropertyStationScalarFieldEnum = (typeof PropertyStationScalarFieldEnum)[keyof typeof PropertyStationScalarFieldEnum]


  export const FavoriteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    propertyId: 'propertyId',
    createdAt: 'createdAt'
  };

  export type FavoriteScalarFieldEnum = (typeof FavoriteScalarFieldEnum)[keyof typeof FavoriteScalarFieldEnum]


  export const PropertyViewScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    userId: 'userId',
    sessionId: 'sessionId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    referer: 'referer',
    viewedAt: 'viewedAt',
    viewDurationSeconds: 'viewDurationSeconds'
  };

  export type PropertyViewScalarFieldEnum = (typeof PropertyViewScalarFieldEnum)[keyof typeof PropertyViewScalarFieldEnum]


  export const PropertyViewDailyScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    viewDate: 'viewDate',
    totalViews: 'totalViews',
    uniqueUsers: 'uniqueUsers',
    avgDurationSeconds: 'avgDurationSeconds',
    createdAt: 'createdAt'
  };

  export type PropertyViewDailyScalarFieldEnum = (typeof PropertyViewDailyScalarFieldEnum)[keyof typeof PropertyViewDailyScalarFieldEnum]


  export const InquiryScalarFieldEnum: {
    id: 'id',
    inquiryNumber: 'inquiryNumber',
    targetType: 'targetType',
    targetId: 'targetId',
    name: 'name',
    furigana: 'furigana',
    email: 'email',
    phone: 'phone',
    companyName: 'companyName',
    inquiryType: 'inquiryType',
    subject: 'subject',
    message: 'message',
    status: 'status',
    priority: 'priority',
    userId: 'userId',
    assignedAgentId: 'assignedAgentId',
    assignedAt: 'assignedAt',
    responseCount: 'responseCount',
    lastRespondedAt: 'lastRespondedAt',
    closedAt: 'closedAt',
    closedReason: 'closedReason',
    source: 'source',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InquiryScalarFieldEnum = (typeof InquiryScalarFieldEnum)[keyof typeof InquiryScalarFieldEnum]


  export const InquiryMessageScalarFieldEnum: {
    id: 'id',
    inquiryId: 'inquiryId',
    senderId: 'senderId',
    senderType: 'senderType',
    message: 'message',
    attachments: 'attachments',
    isInternal: 'isInternal',
    createdAt: 'createdAt'
  };

  export type InquiryMessageScalarFieldEnum = (typeof InquiryMessageScalarFieldEnum)[keyof typeof InquiryMessageScalarFieldEnum]


  export const BulkAssessmentScalarFieldEnum: {
    id: 'id',
    assessmentNumber: 'assessmentNumber',
    propertyAddress: 'propertyAddress',
    propertyTypeId: 'propertyTypeId',
    buildingArea: 'buildingArea',
    landArea: 'landArea',
    constructionYear: 'constructionYear',
    ownerName: 'ownerName',
    email: 'email',
    phone: 'phone',
    preferredContactMethod: 'preferredContactMethod',
    preferredContactTime: 'preferredContactTime',
    status: 'status',
    agentCount: 'agentCount',
    responseCount: 'responseCount',
    userId: 'userId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    completedAt: 'completedAt'
  };

  export type BulkAssessmentScalarFieldEnum = (typeof BulkAssessmentScalarFieldEnum)[keyof typeof BulkAssessmentScalarFieldEnum]


  export const BulkAssessmentResponseScalarFieldEnum: {
    id: 'id',
    assessmentId: 'assessmentId',
    agentId: 'agentId',
    assessedPrice: 'assessedPrice',
    priceRangeMin: 'priceRangeMin',
    priceRangeMax: 'priceRangeMax',
    comments: 'comments',
    proposalDocument: 'proposalDocument',
    status: 'status',
    submittedAt: 'submittedAt',
    viewedAt: 'viewedAt',
    createdAt: 'createdAt'
  };

  export type BulkAssessmentResponseScalarFieldEnum = (typeof BulkAssessmentResponseScalarFieldEnum)[keyof typeof BulkAssessmentResponseScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    questionNumber: 'questionNumber',
    title: 'title',
    content: 'content',
    categoryId: 'categoryId',
    tags: 'tags',
    viewCount: 'viewCount',
    answerCount: 'answerCount',
    status: 'status',
    authorId: 'authorId',
    bestAnswerId: 'bestAnswerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const AnswerScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    content: 'content',
    goodCount: 'goodCount',
    isBestAnswer: 'isBestAnswer',
    authorId: 'authorId',
    agentId: 'agentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type AnswerScalarFieldEnum = (typeof AnswerScalarFieldEnum)[keyof typeof AnswerScalarFieldEnum]


  export const FeatureMasterScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    category: 'category',
    icon: 'icon',
    displayOrder: 'displayOrder',
    isActive: 'isActive'
  };

  export type FeatureMasterScalarFieldEnum = (typeof FeatureMasterScalarFieldEnum)[keyof typeof FeatureMasterScalarFieldEnum]


  export const RegionMasterScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    displayOrder: 'displayOrder',
    isActive: 'isActive'
  };

  export type RegionMasterScalarFieldEnum = (typeof RegionMasterScalarFieldEnum)[keyof typeof RegionMasterScalarFieldEnum]


  export const AreaMasterScalarFieldEnum: {
    id: 'id',
    regionId: 'regionId',
    prefectureCode: 'prefectureCode',
    prefecture: 'prefecture',
    cityCode: 'cityCode',
    city: 'city',
    displayOrder: 'displayOrder',
    isActive: 'isActive'
  };

  export type AreaMasterScalarFieldEnum = (typeof AreaMasterScalarFieldEnum)[keyof typeof AreaMasterScalarFieldEnum]


  export const PropertyTypeMasterScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    displayOrder: 'displayOrder',
    isActive: 'isActive'
  };

  export type PropertyTypeMasterScalarFieldEnum = (typeof PropertyTypeMasterScalarFieldEnum)[keyof typeof PropertyTypeMasterScalarFieldEnum]


  export const PropertyCategoryMasterScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    displayOrder: 'displayOrder',
    isActive: 'isActive'
  };

  export type PropertyCategoryMasterScalarFieldEnum = (typeof PropertyCategoryMasterScalarFieldEnum)[keyof typeof PropertyCategoryMasterScalarFieldEnum]


  export const FloorPlanMasterScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    roomCount: 'roomCount',
    displayOrder: 'displayOrder',
    isActive: 'isActive'
  };

  export type FloorPlanMasterScalarFieldEnum = (typeof FloorPlanMasterScalarFieldEnum)[keyof typeof FloorPlanMasterScalarFieldEnum]


  export const RouteMasterScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    companyName: 'companyName',
    lineColor: 'lineColor',
    displayOrder: 'displayOrder',
    isActive: 'isActive'
  };

  export type RouteMasterScalarFieldEnum = (typeof RouteMasterScalarFieldEnum)[keyof typeof RouteMasterScalarFieldEnum]


  export const StationScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    nameKana: 'nameKana',
    routeId: 'routeId',
    prefecture: 'prefecture',
    city: 'city',
    latitude: 'latitude',
    longitude: 'longitude',
    displayOrder: 'displayOrder',
    isActive: 'isActive'
  };

  export type StationScalarFieldEnum = (typeof StationScalarFieldEnum)[keyof typeof StationScalarFieldEnum]


  export const QuestionCategoryScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    displayOrder: 'displayOrder',
    isActive: 'isActive'
  };

  export type QuestionCategoryScalarFieldEnum = (typeof QuestionCategoryScalarFieldEnum)[keyof typeof QuestionCategoryScalarFieldEnum]


  export const MailScalarFieldEnum: {
    id: 'id',
    fromEmail: 'fromEmail',
    fromName: 'fromName',
    toEmail: 'toEmail',
    toName: 'toName',
    ccEmail: 'ccEmail',
    bccEmail: 'bccEmail',
    subject: 'subject',
    bodyText: 'bodyText',
    bodyHtml: 'bodyHtml',
    status: 'status',
    mailType: 'mailType',
    templateCode: 'templateCode',
    templateVariables: 'templateVariables',
    errorMessage: 'errorMessage',
    userId: 'userId',
    retryCount: 'retryCount',
    scheduledAt: 'scheduledAt',
    sentAt: 'sentAt',
    createdAt: 'createdAt'
  };

  export type MailScalarFieldEnum = (typeof MailScalarFieldEnum)[keyof typeof MailScalarFieldEnum]


  export const FileBoxScalarFieldEnum: {
    id: 'id',
    bucketName: 'bucketName',
    storagePath: 'storagePath',
    fileName: 'fileName',
    originalName: 'originalName',
    publicUrl: 'publicUrl',
    mimeType: 'mimeType',
    fileSize: 'fileSize',
    category: 'category',
    metadata: 'metadata',
    userId: 'userId',
    isPublic: 'isPublic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type FileBoxScalarFieldEnum = (typeof FileBoxScalarFieldEnum)[keyof typeof FileBoxScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    valueType: 'valueType',
    category: 'category',
    description: 'description',
    isPublic: 'isPublic',
    updatedById: 'updatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    tableName: 'tableName',
    recordId: 'recordId',
    action: 'action',
    oldData: 'oldData',
    newData: 'newData',
    changedFields: 'changedFields',
    userId: 'userId',
    userEmail: 'userEmail',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    sessionId: 'sessionId',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    linkUrl: 'linkUrl',
    isRead: 'isRead',
    readAt: 'readAt',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'CompanyStatus'
   */
  export type EnumCompanyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStatus'>
    


  /**
   * Reference to a field of type 'CompanyStatus[]'
   */
  export type ListEnumCompanyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'PropertyCondition'
   */
  export type EnumPropertyConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyCondition'>
    


  /**
   * Reference to a field of type 'PropertyCondition[]'
   */
  export type ListEnumPropertyConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyCondition[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'PublicationStatus'
   */
  export type EnumPublicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublicationStatus'>
    


  /**
   * Reference to a field of type 'PublicationStatus[]'
   */
  export type ListEnumPublicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublicationStatus[]'>
    


  /**
   * Reference to a field of type 'PublicScope'
   */
  export type EnumPublicScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublicScope'>
    


  /**
   * Reference to a field of type 'PublicScope[]'
   */
  export type ListEnumPublicScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublicScope[]'>
    


  /**
   * Reference to a field of type 'ImageType'
   */
  export type EnumImageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImageType'>
    


  /**
   * Reference to a field of type 'ImageType[]'
   */
  export type ListEnumImageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImageType[]'>
    


  /**
   * Reference to a field of type 'TargetType'
   */
  export type EnumTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TargetType'>
    


  /**
   * Reference to a field of type 'TargetType[]'
   */
  export type ListEnumTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TargetType[]'>
    


  /**
   * Reference to a field of type 'InquiryType'
   */
  export type EnumInquiryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryType'>
    


  /**
   * Reference to a field of type 'InquiryType[]'
   */
  export type ListEnumInquiryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryType[]'>
    


  /**
   * Reference to a field of type 'InquiryStatus'
   */
  export type EnumInquiryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryStatus'>
    


  /**
   * Reference to a field of type 'InquiryStatus[]'
   */
  export type ListEnumInquiryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryStatus[]'>
    


  /**
   * Reference to a field of type 'InquiryPriority'
   */
  export type EnumInquiryPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryPriority'>
    


  /**
   * Reference to a field of type 'InquiryPriority[]'
   */
  export type ListEnumInquiryPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryPriority[]'>
    


  /**
   * Reference to a field of type 'SenderType'
   */
  export type EnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType'>
    


  /**
   * Reference to a field of type 'SenderType[]'
   */
  export type ListEnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType[]'>
    


  /**
   * Reference to a field of type 'AssessmentStatus'
   */
  export type EnumAssessmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssessmentStatus'>
    


  /**
   * Reference to a field of type 'AssessmentStatus[]'
   */
  export type ListEnumAssessmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssessmentStatus[]'>
    


  /**
   * Reference to a field of type 'ResponseStatus'
   */
  export type EnumResponseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResponseStatus'>
    


  /**
   * Reference to a field of type 'ResponseStatus[]'
   */
  export type ListEnumResponseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResponseStatus[]'>
    


  /**
   * Reference to a field of type 'QuestionStatus'
   */
  export type EnumQuestionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionStatus'>
    


  /**
   * Reference to a field of type 'QuestionStatus[]'
   */
  export type ListEnumQuestionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionStatus[]'>
    


  /**
   * Reference to a field of type 'FeatureCategory'
   */
  export type EnumFeatureCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeatureCategory'>
    


  /**
   * Reference to a field of type 'FeatureCategory[]'
   */
  export type ListEnumFeatureCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeatureCategory[]'>
    


  /**
   * Reference to a field of type 'MailStatus'
   */
  export type EnumMailStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MailStatus'>
    


  /**
   * Reference to a field of type 'MailStatus[]'
   */
  export type ListEnumMailStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MailStatus[]'>
    


  /**
   * Reference to a field of type 'MailType'
   */
  export type EnumMailTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MailType'>
    


  /**
   * Reference to a field of type 'MailType[]'
   */
  export type ListEnumMailTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MailType[]'>
    


  /**
   * Reference to a field of type 'AuditAction'
   */
  export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


  /**
   * Reference to a field of type 'AuditAction[]'
   */
  export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    furigana?: StringNullableFilter<"User"> | string | null
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    phone?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    userRoles?: UserRoleListRelationFilter
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    properties?: PropertyListRelationFilter
    inquiries?: InquiryListRelationFilter
    favorites?: FavoriteListRelationFilter
    propertyViews?: PropertyViewListRelationFilter
    questions?: QuestionListRelationFilter
    answers?: AnswerListRelationFilter
    bulkAssessments?: BulkAssessmentListRelationFilter
    mails?: MailListRelationFilter
    fileBoxes?: FileBoxListRelationFilter
    notifications?: NotificationListRelationFilter
    systemSettingsUpdated?: SystemSettingListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    priceHistoryChanges?: PropertyPriceHistoryListRelationFilter
    statusHistoryChanges?: PropertyStatusHistoryListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    furigana?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    userRoles?: UserRoleOrderByRelationAggregateInput
    agent?: AgentOrderByWithRelationInput
    properties?: PropertyOrderByRelationAggregateInput
    inquiries?: InquiryOrderByRelationAggregateInput
    favorites?: FavoriteOrderByRelationAggregateInput
    propertyViews?: PropertyViewOrderByRelationAggregateInput
    questions?: QuestionOrderByRelationAggregateInput
    answers?: AnswerOrderByRelationAggregateInput
    bulkAssessments?: BulkAssessmentOrderByRelationAggregateInput
    mails?: MailOrderByRelationAggregateInput
    fileBoxes?: FileBoxOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    systemSettingsUpdated?: SystemSettingOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    priceHistoryChanges?: PropertyPriceHistoryOrderByRelationAggregateInput
    statusHistoryChanges?: PropertyStatusHistoryOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    furigana?: StringNullableFilter<"User"> | string | null
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    phone?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    userRoles?: UserRoleListRelationFilter
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    properties?: PropertyListRelationFilter
    inquiries?: InquiryListRelationFilter
    favorites?: FavoriteListRelationFilter
    propertyViews?: PropertyViewListRelationFilter
    questions?: QuestionListRelationFilter
    answers?: AnswerListRelationFilter
    bulkAssessments?: BulkAssessmentListRelationFilter
    mails?: MailListRelationFilter
    fileBoxes?: FileBoxListRelationFilter
    notifications?: NotificationListRelationFilter
    systemSettingsUpdated?: SystemSettingListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    priceHistoryChanges?: PropertyPriceHistoryListRelationFilter
    statusHistoryChanges?: PropertyStatusHistoryListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    furigana?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    furigana?: StringNullableWithAggregatesFilter<"User"> | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"User"> | $Enums.Gender | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: UuidFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    permissions?: JsonNullableFilter<"Role">
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    userRoles?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    permissions?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userRoles?: UserRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    permissions?: JsonNullableFilter<"Role">
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    userRoles?: UserRoleListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    permissions?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    permissions?: JsonNullableWithAggregatesFilter<"Role">
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: UuidFilter<"UserRole"> | string
    userId?: UuidFilter<"UserRole"> | string
    roleId?: UuidFilter<"UserRole"> | string
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: UuidFilter<"UserRole"> | string
    roleId?: UuidFilter<"UserRole"> | string
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "id" | "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserRole"> | string
    userId?: UuidWithAggregatesFilter<"UserRole"> | string
    roleId?: UuidWithAggregatesFilter<"UserRole"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: UuidFilter<"Company"> | string
    companyName?: StringFilter<"Company"> | string
    companyNameKana?: StringNullableFilter<"Company"> | string | null
    representativeName?: StringFilter<"Company"> | string
    postalCode?: StringFilter<"Company"> | string
    prefecture?: StringFilter<"Company"> | string
    city?: StringFilter<"Company"> | string
    address?: StringFilter<"Company"> | string
    latitude?: DecimalNullableFilter<"Company"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Company"> | Decimal | DecimalJsLike | number | string | null
    phone?: StringFilter<"Company"> | string
    fax?: StringNullableFilter<"Company"> | string | null
    website?: StringNullableFilter<"Company"> | string | null
    licenseNumber?: StringFilter<"Company"> | string
    associationMembership?: StringNullableFilter<"Company"> | string | null
    accountType?: EnumAccountTypeFilter<"Company"> | $Enums.AccountType
    status?: EnumCompanyStatusFilter<"Company"> | $Enums.CompanyStatus
    metadata?: JsonNullableFilter<"Company">
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Company"> | Date | string | null
    branches?: BranchListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrder
    companyNameKana?: SortOrderInput | SortOrder
    representativeName?: SortOrder
    postalCode?: SortOrder
    prefecture?: SortOrder
    city?: SortOrder
    address?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    phone?: SortOrder
    fax?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    licenseNumber?: SortOrder
    associationMembership?: SortOrderInput | SortOrder
    accountType?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    branches?: BranchOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    licenseNumber?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    companyName?: StringFilter<"Company"> | string
    companyNameKana?: StringNullableFilter<"Company"> | string | null
    representativeName?: StringFilter<"Company"> | string
    postalCode?: StringFilter<"Company"> | string
    prefecture?: StringFilter<"Company"> | string
    city?: StringFilter<"Company"> | string
    address?: StringFilter<"Company"> | string
    latitude?: DecimalNullableFilter<"Company"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Company"> | Decimal | DecimalJsLike | number | string | null
    phone?: StringFilter<"Company"> | string
    fax?: StringNullableFilter<"Company"> | string | null
    website?: StringNullableFilter<"Company"> | string | null
    associationMembership?: StringNullableFilter<"Company"> | string | null
    accountType?: EnumAccountTypeFilter<"Company"> | $Enums.AccountType
    status?: EnumCompanyStatusFilter<"Company"> | $Enums.CompanyStatus
    metadata?: JsonNullableFilter<"Company">
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Company"> | Date | string | null
    branches?: BranchListRelationFilter
  }, "id" | "licenseNumber">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrder
    companyNameKana?: SortOrderInput | SortOrder
    representativeName?: SortOrder
    postalCode?: SortOrder
    prefecture?: SortOrder
    city?: SortOrder
    address?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    phone?: SortOrder
    fax?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    licenseNumber?: SortOrder
    associationMembership?: SortOrderInput | SortOrder
    accountType?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Company"> | string
    companyName?: StringWithAggregatesFilter<"Company"> | string
    companyNameKana?: StringNullableWithAggregatesFilter<"Company"> | string | null
    representativeName?: StringWithAggregatesFilter<"Company"> | string
    postalCode?: StringWithAggregatesFilter<"Company"> | string
    prefecture?: StringWithAggregatesFilter<"Company"> | string
    city?: StringWithAggregatesFilter<"Company"> | string
    address?: StringWithAggregatesFilter<"Company"> | string
    latitude?: DecimalNullableWithAggregatesFilter<"Company"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Company"> | Decimal | DecimalJsLike | number | string | null
    phone?: StringWithAggregatesFilter<"Company"> | string
    fax?: StringNullableWithAggregatesFilter<"Company"> | string | null
    website?: StringNullableWithAggregatesFilter<"Company"> | string | null
    licenseNumber?: StringWithAggregatesFilter<"Company"> | string
    associationMembership?: StringNullableWithAggregatesFilter<"Company"> | string | null
    accountType?: EnumAccountTypeWithAggregatesFilter<"Company"> | $Enums.AccountType
    status?: EnumCompanyStatusWithAggregatesFilter<"Company"> | $Enums.CompanyStatus
    metadata?: JsonNullableWithAggregatesFilter<"Company">
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Company"> | Date | string | null
  }

  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: UuidFilter<"Branch"> | string
    branchName?: StringFilter<"Branch"> | string
    postalCode?: StringFilter<"Branch"> | string
    prefecture?: StringFilter<"Branch"> | string
    city?: StringFilter<"Branch"> | string
    address?: StringFilter<"Branch"> | string
    latitude?: DecimalNullableFilter<"Branch"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Branch"> | Decimal | DecimalJsLike | number | string | null
    phone?: StringFilter<"Branch"> | string
    fax?: StringNullableFilter<"Branch"> | string | null
    businessHours?: StringNullableFilter<"Branch"> | string | null
    isHeadquarters?: BoolFilter<"Branch"> | boolean
    companyId?: UuidFilter<"Branch"> | string
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Branch"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    agents?: AgentListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    branchName?: SortOrder
    postalCode?: SortOrder
    prefecture?: SortOrder
    city?: SortOrder
    address?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    phone?: SortOrder
    fax?: SortOrderInput | SortOrder
    businessHours?: SortOrderInput | SortOrder
    isHeadquarters?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    agents?: AgentOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    branchName?: StringFilter<"Branch"> | string
    postalCode?: StringFilter<"Branch"> | string
    prefecture?: StringFilter<"Branch"> | string
    city?: StringFilter<"Branch"> | string
    address?: StringFilter<"Branch"> | string
    latitude?: DecimalNullableFilter<"Branch"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Branch"> | Decimal | DecimalJsLike | number | string | null
    phone?: StringFilter<"Branch"> | string
    fax?: StringNullableFilter<"Branch"> | string | null
    businessHours?: StringNullableFilter<"Branch"> | string | null
    isHeadquarters?: BoolFilter<"Branch"> | boolean
    companyId?: UuidFilter<"Branch"> | string
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Branch"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    agents?: AgentListRelationFilter
  }, "id">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    branchName?: SortOrder
    postalCode?: SortOrder
    prefecture?: SortOrder
    city?: SortOrder
    address?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    phone?: SortOrder
    fax?: SortOrderInput | SortOrder
    businessHours?: SortOrderInput | SortOrder
    isHeadquarters?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: BranchCountOrderByAggregateInput
    _avg?: BranchAvgOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
    _sum?: BranchSumOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Branch"> | string
    branchName?: StringWithAggregatesFilter<"Branch"> | string
    postalCode?: StringWithAggregatesFilter<"Branch"> | string
    prefecture?: StringWithAggregatesFilter<"Branch"> | string
    city?: StringWithAggregatesFilter<"Branch"> | string
    address?: StringWithAggregatesFilter<"Branch"> | string
    latitude?: DecimalNullableWithAggregatesFilter<"Branch"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Branch"> | Decimal | DecimalJsLike | number | string | null
    phone?: StringWithAggregatesFilter<"Branch"> | string
    fax?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    businessHours?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    isHeadquarters?: BoolWithAggregatesFilter<"Branch"> | boolean
    companyId?: UuidWithAggregatesFilter<"Branch"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Branch"> | Date | string | null
  }

  export type AgentWhereInput = {
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    id?: UuidFilter<"Agent"> | string
    position?: StringNullableFilter<"Agent"> | string | null
    department?: StringNullableFilter<"Agent"> | string | null
    licenseNumber?: StringNullableFilter<"Agent"> | string | null
    licenseExpireDate?: DateTimeNullableFilter<"Agent"> | Date | string | null
    goodCount?: IntFilter<"Agent"> | number
    responseRate?: DecimalNullableFilter<"Agent"> | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: IntNullableFilter<"Agent"> | number | null
    userId?: UuidFilter<"Agent"> | string
    branchId?: UuidFilter<"Agent"> | string
    isActive?: BoolFilter<"Agent"> | boolean
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Agent"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    properties?: PropertyListRelationFilter
    assignedInquiries?: InquiryListRelationFilter
    answers?: AnswerListRelationFilter
    bulkAssessmentResponses?: BulkAssessmentResponseListRelationFilter
  }

  export type AgentOrderByWithRelationInput = {
    id?: SortOrder
    position?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    licenseExpireDate?: SortOrderInput | SortOrder
    goodCount?: SortOrder
    responseRate?: SortOrderInput | SortOrder
    avgResponseMinutes?: SortOrderInput | SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    properties?: PropertyOrderByRelationAggregateInput
    assignedInquiries?: InquiryOrderByRelationAggregateInput
    answers?: AnswerOrderByRelationAggregateInput
    bulkAssessmentResponses?: BulkAssessmentResponseOrderByRelationAggregateInput
  }

  export type AgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    position?: StringNullableFilter<"Agent"> | string | null
    department?: StringNullableFilter<"Agent"> | string | null
    licenseNumber?: StringNullableFilter<"Agent"> | string | null
    licenseExpireDate?: DateTimeNullableFilter<"Agent"> | Date | string | null
    goodCount?: IntFilter<"Agent"> | number
    responseRate?: DecimalNullableFilter<"Agent"> | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: IntNullableFilter<"Agent"> | number | null
    branchId?: UuidFilter<"Agent"> | string
    isActive?: BoolFilter<"Agent"> | boolean
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Agent"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    properties?: PropertyListRelationFilter
    assignedInquiries?: InquiryListRelationFilter
    answers?: AnswerListRelationFilter
    bulkAssessmentResponses?: BulkAssessmentResponseListRelationFilter
  }, "id" | "userId">

  export type AgentOrderByWithAggregationInput = {
    id?: SortOrder
    position?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    licenseExpireDate?: SortOrderInput | SortOrder
    goodCount?: SortOrder
    responseRate?: SortOrderInput | SortOrder
    avgResponseMinutes?: SortOrderInput | SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: AgentCountOrderByAggregateInput
    _avg?: AgentAvgOrderByAggregateInput
    _max?: AgentMaxOrderByAggregateInput
    _min?: AgentMinOrderByAggregateInput
    _sum?: AgentSumOrderByAggregateInput
  }

  export type AgentScalarWhereWithAggregatesInput = {
    AND?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    OR?: AgentScalarWhereWithAggregatesInput[]
    NOT?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Agent"> | string
    position?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    department?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    licenseNumber?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    licenseExpireDate?: DateTimeNullableWithAggregatesFilter<"Agent"> | Date | string | null
    goodCount?: IntWithAggregatesFilter<"Agent"> | number
    responseRate?: DecimalNullableWithAggregatesFilter<"Agent"> | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: IntNullableWithAggregatesFilter<"Agent"> | number | null
    userId?: UuidWithAggregatesFilter<"Agent"> | string
    branchId?: UuidWithAggregatesFilter<"Agent"> | string
    isActive?: BoolWithAggregatesFilter<"Agent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Agent"> | Date | string | null
  }

  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    id?: UuidFilter<"Property"> | string
    propertyCode?: StringFilter<"Property"> | string
    propertyName?: StringFilter<"Property"> | string
    propertyNameKana?: StringNullableFilter<"Property"> | string | null
    propertyTypeId?: UuidNullableFilter<"Property"> | string | null
    propertyCategoryId?: UuidNullableFilter<"Property"> | string | null
    areaId?: UuidNullableFilter<"Property"> | string | null
    transactionType?: EnumTransactionTypeNullableFilter<"Property"> | $Enums.TransactionType | null
    propertyCondition?: EnumPropertyConditionNullableFilter<"Property"> | $Enums.PropertyCondition | null
    postalCode?: StringNullableFilter<"Property"> | string | null
    prefecture?: StringNullableFilter<"Property"> | string | null
    city?: StringNullableFilter<"Property"> | string | null
    town?: StringNullableFilter<"Property"> | string | null
    block?: StringNullableFilter<"Property"> | string | null
    building?: StringNullableFilter<"Property"> | string | null
    roomNumber?: StringNullableFilter<"Property"> | string | null
    fullAddress?: StringNullableFilter<"Property"> | string | null
    latitude?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: IntNullableFilter<"Property"> | number | null
    layoutTypeId?: UuidNullableFilter<"Property"> | string | null
    layoutDisplay?: StringNullableFilter<"Property"> | string | null
    buildingArea?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    landArea?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    balconyArea?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: StringNullableFilter<"Property"> | string | null
    constructionDate?: DateTimeNullableFilter<"Property"> | Date | string | null
    constructionYearMonth?: StringNullableFilter<"Property"> | string | null
    totalFloors?: IntNullableFilter<"Property"> | number | null
    floor?: IntNullableFilter<"Property"> | number | null
    currentPrice?: BigIntNullableFilter<"Property"> | bigint | number | null
    pricePerTsubo?: BigIntNullableFilter<"Property"> | bigint | number | null
    managementFee?: IntNullableFilter<"Property"> | number | null
    commonServiceFee?: IntNullableFilter<"Property"> | number | null
    depositMonths?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: StringNullableFilter<"Property"> | string | null
    primaryStationName?: StringNullableFilter<"Property"> | string | null
    primaryStationWalkMinutes?: IntNullableFilter<"Property"> | number | null
    featureTags?: StringNullableListFilter<"Property">
    viewCount?: IntFilter<"Property"> | number
    inquiryCount?: IntFilter<"Property"> | number
    favoriteCount?: IntFilter<"Property"> | number
    agentId?: UuidNullableFilter<"Property"> | string | null
    remarks?: StringNullableFilter<"Property"> | string | null
    internalMemo?: StringNullableFilter<"Property"> | string | null
    metadata?: JsonNullableFilter<"Property">
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    userId?: UuidFilter<"Property"> | string
    propertyType?: XOR<PropertyTypeMasterNullableScalarRelationFilter, PropertyTypeMasterWhereInput> | null
    propertyCategory?: XOR<PropertyCategoryMasterNullableScalarRelationFilter, PropertyCategoryMasterWhereInput> | null
    area?: XOR<AreaMasterNullableScalarRelationFilter, AreaMasterWhereInput> | null
    layoutType?: XOR<FloorPlanMasterNullableScalarRelationFilter, FloorPlanMasterWhereInput> | null
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    publication?: XOR<PropertyPublicationNullableScalarRelationFilter, PropertyPublicationWhereInput> | null
    priceHistories?: PropertyPriceHistoryListRelationFilter
    statusHistories?: PropertyStatusHistoryListRelationFilter
    images?: PropertyImageListRelationFilter
    features?: PropertyFeatureListRelationFilter
    stations?: PropertyStationListRelationFilter
    inquiries?: InquiryListRelationFilter
    favorites?: FavoriteListRelationFilter
    propertyViews?: PropertyViewListRelationFilter
    propertyViewDailies?: PropertyViewDailyListRelationFilter
  }

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder
    propertyCode?: SortOrder
    propertyName?: SortOrder
    propertyNameKana?: SortOrderInput | SortOrder
    propertyTypeId?: SortOrderInput | SortOrder
    propertyCategoryId?: SortOrderInput | SortOrder
    areaId?: SortOrderInput | SortOrder
    transactionType?: SortOrderInput | SortOrder
    propertyCondition?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    prefecture?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    town?: SortOrderInput | SortOrder
    block?: SortOrderInput | SortOrder
    building?: SortOrderInput | SortOrder
    roomNumber?: SortOrderInput | SortOrder
    fullAddress?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    layoutNumber?: SortOrderInput | SortOrder
    layoutTypeId?: SortOrderInput | SortOrder
    layoutDisplay?: SortOrderInput | SortOrder
    buildingArea?: SortOrderInput | SortOrder
    landArea?: SortOrderInput | SortOrder
    balconyArea?: SortOrderInput | SortOrder
    buildingStructure?: SortOrderInput | SortOrder
    constructionDate?: SortOrderInput | SortOrder
    constructionYearMonth?: SortOrderInput | SortOrder
    totalFloors?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    currentPrice?: SortOrderInput | SortOrder
    pricePerTsubo?: SortOrderInput | SortOrder
    managementFee?: SortOrderInput | SortOrder
    commonServiceFee?: SortOrderInput | SortOrder
    depositMonths?: SortOrderInput | SortOrder
    keyMoneyMonths?: SortOrderInput | SortOrder
    mainImageUrl?: SortOrderInput | SortOrder
    primaryStationName?: SortOrderInput | SortOrder
    primaryStationWalkMinutes?: SortOrderInput | SortOrder
    featureTags?: SortOrder
    viewCount?: SortOrder
    inquiryCount?: SortOrder
    favoriteCount?: SortOrder
    agentId?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    internalMemo?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    propertyType?: PropertyTypeMasterOrderByWithRelationInput
    propertyCategory?: PropertyCategoryMasterOrderByWithRelationInput
    area?: AreaMasterOrderByWithRelationInput
    layoutType?: FloorPlanMasterOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    publication?: PropertyPublicationOrderByWithRelationInput
    priceHistories?: PropertyPriceHistoryOrderByRelationAggregateInput
    statusHistories?: PropertyStatusHistoryOrderByRelationAggregateInput
    images?: PropertyImageOrderByRelationAggregateInput
    features?: PropertyFeatureOrderByRelationAggregateInput
    stations?: PropertyStationOrderByRelationAggregateInput
    inquiries?: InquiryOrderByRelationAggregateInput
    favorites?: FavoriteOrderByRelationAggregateInput
    propertyViews?: PropertyViewOrderByRelationAggregateInput
    propertyViewDailies?: PropertyViewDailyOrderByRelationAggregateInput
  }

  export type PropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    propertyCode?: string
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    propertyName?: StringFilter<"Property"> | string
    propertyNameKana?: StringNullableFilter<"Property"> | string | null
    propertyTypeId?: UuidNullableFilter<"Property"> | string | null
    propertyCategoryId?: UuidNullableFilter<"Property"> | string | null
    areaId?: UuidNullableFilter<"Property"> | string | null
    transactionType?: EnumTransactionTypeNullableFilter<"Property"> | $Enums.TransactionType | null
    propertyCondition?: EnumPropertyConditionNullableFilter<"Property"> | $Enums.PropertyCondition | null
    postalCode?: StringNullableFilter<"Property"> | string | null
    prefecture?: StringNullableFilter<"Property"> | string | null
    city?: StringNullableFilter<"Property"> | string | null
    town?: StringNullableFilter<"Property"> | string | null
    block?: StringNullableFilter<"Property"> | string | null
    building?: StringNullableFilter<"Property"> | string | null
    roomNumber?: StringNullableFilter<"Property"> | string | null
    fullAddress?: StringNullableFilter<"Property"> | string | null
    latitude?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: IntNullableFilter<"Property"> | number | null
    layoutTypeId?: UuidNullableFilter<"Property"> | string | null
    layoutDisplay?: StringNullableFilter<"Property"> | string | null
    buildingArea?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    landArea?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    balconyArea?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: StringNullableFilter<"Property"> | string | null
    constructionDate?: DateTimeNullableFilter<"Property"> | Date | string | null
    constructionYearMonth?: StringNullableFilter<"Property"> | string | null
    totalFloors?: IntNullableFilter<"Property"> | number | null
    floor?: IntNullableFilter<"Property"> | number | null
    currentPrice?: BigIntNullableFilter<"Property"> | bigint | number | null
    pricePerTsubo?: BigIntNullableFilter<"Property"> | bigint | number | null
    managementFee?: IntNullableFilter<"Property"> | number | null
    commonServiceFee?: IntNullableFilter<"Property"> | number | null
    depositMonths?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: StringNullableFilter<"Property"> | string | null
    primaryStationName?: StringNullableFilter<"Property"> | string | null
    primaryStationWalkMinutes?: IntNullableFilter<"Property"> | number | null
    featureTags?: StringNullableListFilter<"Property">
    viewCount?: IntFilter<"Property"> | number
    inquiryCount?: IntFilter<"Property"> | number
    favoriteCount?: IntFilter<"Property"> | number
    agentId?: UuidNullableFilter<"Property"> | string | null
    remarks?: StringNullableFilter<"Property"> | string | null
    internalMemo?: StringNullableFilter<"Property"> | string | null
    metadata?: JsonNullableFilter<"Property">
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    userId?: UuidFilter<"Property"> | string
    propertyType?: XOR<PropertyTypeMasterNullableScalarRelationFilter, PropertyTypeMasterWhereInput> | null
    propertyCategory?: XOR<PropertyCategoryMasterNullableScalarRelationFilter, PropertyCategoryMasterWhereInput> | null
    area?: XOR<AreaMasterNullableScalarRelationFilter, AreaMasterWhereInput> | null
    layoutType?: XOR<FloorPlanMasterNullableScalarRelationFilter, FloorPlanMasterWhereInput> | null
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    publication?: XOR<PropertyPublicationNullableScalarRelationFilter, PropertyPublicationWhereInput> | null
    priceHistories?: PropertyPriceHistoryListRelationFilter
    statusHistories?: PropertyStatusHistoryListRelationFilter
    images?: PropertyImageListRelationFilter
    features?: PropertyFeatureListRelationFilter
    stations?: PropertyStationListRelationFilter
    inquiries?: InquiryListRelationFilter
    favorites?: FavoriteListRelationFilter
    propertyViews?: PropertyViewListRelationFilter
    propertyViewDailies?: PropertyViewDailyListRelationFilter
  }, "id" | "propertyCode">

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder
    propertyCode?: SortOrder
    propertyName?: SortOrder
    propertyNameKana?: SortOrderInput | SortOrder
    propertyTypeId?: SortOrderInput | SortOrder
    propertyCategoryId?: SortOrderInput | SortOrder
    areaId?: SortOrderInput | SortOrder
    transactionType?: SortOrderInput | SortOrder
    propertyCondition?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    prefecture?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    town?: SortOrderInput | SortOrder
    block?: SortOrderInput | SortOrder
    building?: SortOrderInput | SortOrder
    roomNumber?: SortOrderInput | SortOrder
    fullAddress?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    layoutNumber?: SortOrderInput | SortOrder
    layoutTypeId?: SortOrderInput | SortOrder
    layoutDisplay?: SortOrderInput | SortOrder
    buildingArea?: SortOrderInput | SortOrder
    landArea?: SortOrderInput | SortOrder
    balconyArea?: SortOrderInput | SortOrder
    buildingStructure?: SortOrderInput | SortOrder
    constructionDate?: SortOrderInput | SortOrder
    constructionYearMonth?: SortOrderInput | SortOrder
    totalFloors?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    currentPrice?: SortOrderInput | SortOrder
    pricePerTsubo?: SortOrderInput | SortOrder
    managementFee?: SortOrderInput | SortOrder
    commonServiceFee?: SortOrderInput | SortOrder
    depositMonths?: SortOrderInput | SortOrder
    keyMoneyMonths?: SortOrderInput | SortOrder
    mainImageUrl?: SortOrderInput | SortOrder
    primaryStationName?: SortOrderInput | SortOrder
    primaryStationWalkMinutes?: SortOrderInput | SortOrder
    featureTags?: SortOrder
    viewCount?: SortOrder
    inquiryCount?: SortOrder
    favoriteCount?: SortOrder
    agentId?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    internalMemo?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: PropertyCountOrderByAggregateInput
    _avg?: PropertyAvgOrderByAggregateInput
    _max?: PropertyMaxOrderByAggregateInput
    _min?: PropertyMinOrderByAggregateInput
    _sum?: PropertySumOrderByAggregateInput
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    OR?: PropertyScalarWhereWithAggregatesInput[]
    NOT?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Property"> | string
    propertyCode?: StringWithAggregatesFilter<"Property"> | string
    propertyName?: StringWithAggregatesFilter<"Property"> | string
    propertyNameKana?: StringNullableWithAggregatesFilter<"Property"> | string | null
    propertyTypeId?: UuidNullableWithAggregatesFilter<"Property"> | string | null
    propertyCategoryId?: UuidNullableWithAggregatesFilter<"Property"> | string | null
    areaId?: UuidNullableWithAggregatesFilter<"Property"> | string | null
    transactionType?: EnumTransactionTypeNullableWithAggregatesFilter<"Property"> | $Enums.TransactionType | null
    propertyCondition?: EnumPropertyConditionNullableWithAggregatesFilter<"Property"> | $Enums.PropertyCondition | null
    postalCode?: StringNullableWithAggregatesFilter<"Property"> | string | null
    prefecture?: StringNullableWithAggregatesFilter<"Property"> | string | null
    city?: StringNullableWithAggregatesFilter<"Property"> | string | null
    town?: StringNullableWithAggregatesFilter<"Property"> | string | null
    block?: StringNullableWithAggregatesFilter<"Property"> | string | null
    building?: StringNullableWithAggregatesFilter<"Property"> | string | null
    roomNumber?: StringNullableWithAggregatesFilter<"Property"> | string | null
    fullAddress?: StringNullableWithAggregatesFilter<"Property"> | string | null
    latitude?: DecimalNullableWithAggregatesFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: IntNullableWithAggregatesFilter<"Property"> | number | null
    layoutTypeId?: UuidNullableWithAggregatesFilter<"Property"> | string | null
    layoutDisplay?: StringNullableWithAggregatesFilter<"Property"> | string | null
    buildingArea?: DecimalNullableWithAggregatesFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    landArea?: DecimalNullableWithAggregatesFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    balconyArea?: DecimalNullableWithAggregatesFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: StringNullableWithAggregatesFilter<"Property"> | string | null
    constructionDate?: DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
    constructionYearMonth?: StringNullableWithAggregatesFilter<"Property"> | string | null
    totalFloors?: IntNullableWithAggregatesFilter<"Property"> | number | null
    floor?: IntNullableWithAggregatesFilter<"Property"> | number | null
    currentPrice?: BigIntNullableWithAggregatesFilter<"Property"> | bigint | number | null
    pricePerTsubo?: BigIntNullableWithAggregatesFilter<"Property"> | bigint | number | null
    managementFee?: IntNullableWithAggregatesFilter<"Property"> | number | null
    commonServiceFee?: IntNullableWithAggregatesFilter<"Property"> | number | null
    depositMonths?: DecimalNullableWithAggregatesFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: DecimalNullableWithAggregatesFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: StringNullableWithAggregatesFilter<"Property"> | string | null
    primaryStationName?: StringNullableWithAggregatesFilter<"Property"> | string | null
    primaryStationWalkMinutes?: IntNullableWithAggregatesFilter<"Property"> | number | null
    featureTags?: StringNullableListFilter<"Property">
    viewCount?: IntWithAggregatesFilter<"Property"> | number
    inquiryCount?: IntWithAggregatesFilter<"Property"> | number
    favoriteCount?: IntWithAggregatesFilter<"Property"> | number
    agentId?: UuidNullableWithAggregatesFilter<"Property"> | string | null
    remarks?: StringNullableWithAggregatesFilter<"Property"> | string | null
    internalMemo?: StringNullableWithAggregatesFilter<"Property"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Property">
    createdAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
    userId?: UuidWithAggregatesFilter<"Property"> | string
  }

  export type PropertyPublicationWhereInput = {
    AND?: PropertyPublicationWhereInput | PropertyPublicationWhereInput[]
    OR?: PropertyPublicationWhereInput[]
    NOT?: PropertyPublicationWhereInput | PropertyPublicationWhereInput[]
    id?: UuidFilter<"PropertyPublication"> | string
    propertyId?: UuidFilter<"PropertyPublication"> | string
    status?: EnumPublicationStatusFilter<"PropertyPublication"> | $Enums.PublicationStatus
    scope?: EnumPublicScopeFilter<"PropertyPublication"> | $Enums.PublicScope
    featured?: BoolFilter<"PropertyPublication"> | boolean
    featuredOrder?: IntNullableFilter<"PropertyPublication"> | number | null
    publishedAt?: DateTimeNullableFilter<"PropertyPublication"> | Date | string | null
    unpublishedAt?: DateTimeNullableFilter<"PropertyPublication"> | Date | string | null
    soldAt?: DateTimeNullableFilter<"PropertyPublication"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"PropertyPublication"> | Date | string | null
    createdAt?: DateTimeFilter<"PropertyPublication"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyPublication"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertyPublicationOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    status?: SortOrder
    scope?: SortOrder
    featured?: SortOrder
    featuredOrder?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    unpublishedAt?: SortOrderInput | SortOrder
    soldAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertyPublicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    propertyId?: string
    AND?: PropertyPublicationWhereInput | PropertyPublicationWhereInput[]
    OR?: PropertyPublicationWhereInput[]
    NOT?: PropertyPublicationWhereInput | PropertyPublicationWhereInput[]
    status?: EnumPublicationStatusFilter<"PropertyPublication"> | $Enums.PublicationStatus
    scope?: EnumPublicScopeFilter<"PropertyPublication"> | $Enums.PublicScope
    featured?: BoolFilter<"PropertyPublication"> | boolean
    featuredOrder?: IntNullableFilter<"PropertyPublication"> | number | null
    publishedAt?: DateTimeNullableFilter<"PropertyPublication"> | Date | string | null
    unpublishedAt?: DateTimeNullableFilter<"PropertyPublication"> | Date | string | null
    soldAt?: DateTimeNullableFilter<"PropertyPublication"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"PropertyPublication"> | Date | string | null
    createdAt?: DateTimeFilter<"PropertyPublication"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyPublication"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id" | "propertyId">

  export type PropertyPublicationOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    status?: SortOrder
    scope?: SortOrder
    featured?: SortOrder
    featuredOrder?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    unpublishedAt?: SortOrderInput | SortOrder
    soldAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyPublicationCountOrderByAggregateInput
    _avg?: PropertyPublicationAvgOrderByAggregateInput
    _max?: PropertyPublicationMaxOrderByAggregateInput
    _min?: PropertyPublicationMinOrderByAggregateInput
    _sum?: PropertyPublicationSumOrderByAggregateInput
  }

  export type PropertyPublicationScalarWhereWithAggregatesInput = {
    AND?: PropertyPublicationScalarWhereWithAggregatesInput | PropertyPublicationScalarWhereWithAggregatesInput[]
    OR?: PropertyPublicationScalarWhereWithAggregatesInput[]
    NOT?: PropertyPublicationScalarWhereWithAggregatesInput | PropertyPublicationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PropertyPublication"> | string
    propertyId?: UuidWithAggregatesFilter<"PropertyPublication"> | string
    status?: EnumPublicationStatusWithAggregatesFilter<"PropertyPublication"> | $Enums.PublicationStatus
    scope?: EnumPublicScopeWithAggregatesFilter<"PropertyPublication"> | $Enums.PublicScope
    featured?: BoolWithAggregatesFilter<"PropertyPublication"> | boolean
    featuredOrder?: IntNullableWithAggregatesFilter<"PropertyPublication"> | number | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"PropertyPublication"> | Date | string | null
    unpublishedAt?: DateTimeNullableWithAggregatesFilter<"PropertyPublication"> | Date | string | null
    soldAt?: DateTimeNullableWithAggregatesFilter<"PropertyPublication"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"PropertyPublication"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PropertyPublication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyPublication"> | Date | string
  }

  export type PropertyPriceHistoryWhereInput = {
    AND?: PropertyPriceHistoryWhereInput | PropertyPriceHistoryWhereInput[]
    OR?: PropertyPriceHistoryWhereInput[]
    NOT?: PropertyPriceHistoryWhereInput | PropertyPriceHistoryWhereInput[]
    id?: UuidFilter<"PropertyPriceHistory"> | string
    propertyId?: UuidFilter<"PropertyPriceHistory"> | string
    previousPrice?: BigIntNullableFilter<"PropertyPriceHistory"> | bigint | number | null
    newPrice?: BigIntFilter<"PropertyPriceHistory"> | bigint | number
    changePercent?: DecimalNullableFilter<"PropertyPriceHistory"> | Decimal | DecimalJsLike | number | string | null
    changeReason?: StringNullableFilter<"PropertyPriceHistory"> | string | null
    changedById?: UuidNullableFilter<"PropertyPriceHistory"> | string | null
    createdAt?: DateTimeFilter<"PropertyPriceHistory"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    changedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PropertyPriceHistoryOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    previousPrice?: SortOrderInput | SortOrder
    newPrice?: SortOrder
    changePercent?: SortOrderInput | SortOrder
    changeReason?: SortOrderInput | SortOrder
    changedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    changedBy?: UserOrderByWithRelationInput
  }

  export type PropertyPriceHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyPriceHistoryWhereInput | PropertyPriceHistoryWhereInput[]
    OR?: PropertyPriceHistoryWhereInput[]
    NOT?: PropertyPriceHistoryWhereInput | PropertyPriceHistoryWhereInput[]
    propertyId?: UuidFilter<"PropertyPriceHistory"> | string
    previousPrice?: BigIntNullableFilter<"PropertyPriceHistory"> | bigint | number | null
    newPrice?: BigIntFilter<"PropertyPriceHistory"> | bigint | number
    changePercent?: DecimalNullableFilter<"PropertyPriceHistory"> | Decimal | DecimalJsLike | number | string | null
    changeReason?: StringNullableFilter<"PropertyPriceHistory"> | string | null
    changedById?: UuidNullableFilter<"PropertyPriceHistory"> | string | null
    createdAt?: DateTimeFilter<"PropertyPriceHistory"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    changedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type PropertyPriceHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    previousPrice?: SortOrderInput | SortOrder
    newPrice?: SortOrder
    changePercent?: SortOrderInput | SortOrder
    changeReason?: SortOrderInput | SortOrder
    changedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PropertyPriceHistoryCountOrderByAggregateInput
    _avg?: PropertyPriceHistoryAvgOrderByAggregateInput
    _max?: PropertyPriceHistoryMaxOrderByAggregateInput
    _min?: PropertyPriceHistoryMinOrderByAggregateInput
    _sum?: PropertyPriceHistorySumOrderByAggregateInput
  }

  export type PropertyPriceHistoryScalarWhereWithAggregatesInput = {
    AND?: PropertyPriceHistoryScalarWhereWithAggregatesInput | PropertyPriceHistoryScalarWhereWithAggregatesInput[]
    OR?: PropertyPriceHistoryScalarWhereWithAggregatesInput[]
    NOT?: PropertyPriceHistoryScalarWhereWithAggregatesInput | PropertyPriceHistoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PropertyPriceHistory"> | string
    propertyId?: UuidWithAggregatesFilter<"PropertyPriceHistory"> | string
    previousPrice?: BigIntNullableWithAggregatesFilter<"PropertyPriceHistory"> | bigint | number | null
    newPrice?: BigIntWithAggregatesFilter<"PropertyPriceHistory"> | bigint | number
    changePercent?: DecimalNullableWithAggregatesFilter<"PropertyPriceHistory"> | Decimal | DecimalJsLike | number | string | null
    changeReason?: StringNullableWithAggregatesFilter<"PropertyPriceHistory"> | string | null
    changedById?: UuidNullableWithAggregatesFilter<"PropertyPriceHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PropertyPriceHistory"> | Date | string
  }

  export type PropertyStatusHistoryWhereInput = {
    AND?: PropertyStatusHistoryWhereInput | PropertyStatusHistoryWhereInput[]
    OR?: PropertyStatusHistoryWhereInput[]
    NOT?: PropertyStatusHistoryWhereInput | PropertyStatusHistoryWhereInput[]
    id?: UuidFilter<"PropertyStatusHistory"> | string
    propertyId?: UuidFilter<"PropertyStatusHistory"> | string
    previousStatus?: StringNullableFilter<"PropertyStatusHistory"> | string | null
    newStatus?: StringFilter<"PropertyStatusHistory"> | string
    changeReason?: StringNullableFilter<"PropertyStatusHistory"> | string | null
    changedById?: UuidNullableFilter<"PropertyStatusHistory"> | string | null
    createdAt?: DateTimeFilter<"PropertyStatusHistory"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    changedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PropertyStatusHistoryOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    previousStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrder
    changeReason?: SortOrderInput | SortOrder
    changedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    changedBy?: UserOrderByWithRelationInput
  }

  export type PropertyStatusHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyStatusHistoryWhereInput | PropertyStatusHistoryWhereInput[]
    OR?: PropertyStatusHistoryWhereInput[]
    NOT?: PropertyStatusHistoryWhereInput | PropertyStatusHistoryWhereInput[]
    propertyId?: UuidFilter<"PropertyStatusHistory"> | string
    previousStatus?: StringNullableFilter<"PropertyStatusHistory"> | string | null
    newStatus?: StringFilter<"PropertyStatusHistory"> | string
    changeReason?: StringNullableFilter<"PropertyStatusHistory"> | string | null
    changedById?: UuidNullableFilter<"PropertyStatusHistory"> | string | null
    createdAt?: DateTimeFilter<"PropertyStatusHistory"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    changedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type PropertyStatusHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    previousStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrder
    changeReason?: SortOrderInput | SortOrder
    changedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PropertyStatusHistoryCountOrderByAggregateInput
    _max?: PropertyStatusHistoryMaxOrderByAggregateInput
    _min?: PropertyStatusHistoryMinOrderByAggregateInput
  }

  export type PropertyStatusHistoryScalarWhereWithAggregatesInput = {
    AND?: PropertyStatusHistoryScalarWhereWithAggregatesInput | PropertyStatusHistoryScalarWhereWithAggregatesInput[]
    OR?: PropertyStatusHistoryScalarWhereWithAggregatesInput[]
    NOT?: PropertyStatusHistoryScalarWhereWithAggregatesInput | PropertyStatusHistoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PropertyStatusHistory"> | string
    propertyId?: UuidWithAggregatesFilter<"PropertyStatusHistory"> | string
    previousStatus?: StringNullableWithAggregatesFilter<"PropertyStatusHistory"> | string | null
    newStatus?: StringWithAggregatesFilter<"PropertyStatusHistory"> | string
    changeReason?: StringNullableWithAggregatesFilter<"PropertyStatusHistory"> | string | null
    changedById?: UuidNullableWithAggregatesFilter<"PropertyStatusHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PropertyStatusHistory"> | Date | string
  }

  export type PropertyImageWhereInput = {
    AND?: PropertyImageWhereInput | PropertyImageWhereInput[]
    OR?: PropertyImageWhereInput[]
    NOT?: PropertyImageWhereInput | PropertyImageWhereInput[]
    id?: UuidFilter<"PropertyImage"> | string
    propertyId?: UuidFilter<"PropertyImage"> | string
    fileBoxId?: UuidNullableFilter<"PropertyImage"> | string | null
    url?: StringFilter<"PropertyImage"> | string
    thumbnailUrl?: StringNullableFilter<"PropertyImage"> | string | null
    caption?: StringNullableFilter<"PropertyImage"> | string | null
    imageType?: EnumImageTypeFilter<"PropertyImage"> | $Enums.ImageType
    displayOrder?: IntFilter<"PropertyImage"> | number
    isMain?: BoolFilter<"PropertyImage"> | boolean
    width?: IntNullableFilter<"PropertyImage"> | number | null
    height?: IntNullableFilter<"PropertyImage"> | number | null
    createdAt?: DateTimeFilter<"PropertyImage"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    fileBox?: XOR<FileBoxNullableScalarRelationFilter, FileBoxWhereInput> | null
  }

  export type PropertyImageOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    fileBoxId?: SortOrderInput | SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    imageType?: SortOrder
    displayOrder?: SortOrder
    isMain?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    fileBox?: FileBoxOrderByWithRelationInput
  }

  export type PropertyImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyImageWhereInput | PropertyImageWhereInput[]
    OR?: PropertyImageWhereInput[]
    NOT?: PropertyImageWhereInput | PropertyImageWhereInput[]
    propertyId?: UuidFilter<"PropertyImage"> | string
    fileBoxId?: UuidNullableFilter<"PropertyImage"> | string | null
    url?: StringFilter<"PropertyImage"> | string
    thumbnailUrl?: StringNullableFilter<"PropertyImage"> | string | null
    caption?: StringNullableFilter<"PropertyImage"> | string | null
    imageType?: EnumImageTypeFilter<"PropertyImage"> | $Enums.ImageType
    displayOrder?: IntFilter<"PropertyImage"> | number
    isMain?: BoolFilter<"PropertyImage"> | boolean
    width?: IntNullableFilter<"PropertyImage"> | number | null
    height?: IntNullableFilter<"PropertyImage"> | number | null
    createdAt?: DateTimeFilter<"PropertyImage"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    fileBox?: XOR<FileBoxNullableScalarRelationFilter, FileBoxWhereInput> | null
  }, "id">

  export type PropertyImageOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    fileBoxId?: SortOrderInput | SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    imageType?: SortOrder
    displayOrder?: SortOrder
    isMain?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PropertyImageCountOrderByAggregateInput
    _avg?: PropertyImageAvgOrderByAggregateInput
    _max?: PropertyImageMaxOrderByAggregateInput
    _min?: PropertyImageMinOrderByAggregateInput
    _sum?: PropertyImageSumOrderByAggregateInput
  }

  export type PropertyImageScalarWhereWithAggregatesInput = {
    AND?: PropertyImageScalarWhereWithAggregatesInput | PropertyImageScalarWhereWithAggregatesInput[]
    OR?: PropertyImageScalarWhereWithAggregatesInput[]
    NOT?: PropertyImageScalarWhereWithAggregatesInput | PropertyImageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PropertyImage"> | string
    propertyId?: UuidWithAggregatesFilter<"PropertyImage"> | string
    fileBoxId?: UuidNullableWithAggregatesFilter<"PropertyImage"> | string | null
    url?: StringWithAggregatesFilter<"PropertyImage"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"PropertyImage"> | string | null
    caption?: StringNullableWithAggregatesFilter<"PropertyImage"> | string | null
    imageType?: EnumImageTypeWithAggregatesFilter<"PropertyImage"> | $Enums.ImageType
    displayOrder?: IntWithAggregatesFilter<"PropertyImage"> | number
    isMain?: BoolWithAggregatesFilter<"PropertyImage"> | boolean
    width?: IntNullableWithAggregatesFilter<"PropertyImage"> | number | null
    height?: IntNullableWithAggregatesFilter<"PropertyImage"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"PropertyImage"> | Date | string
  }

  export type PropertyFeatureWhereInput = {
    AND?: PropertyFeatureWhereInput | PropertyFeatureWhereInput[]
    OR?: PropertyFeatureWhereInput[]
    NOT?: PropertyFeatureWhereInput | PropertyFeatureWhereInput[]
    id?: UuidFilter<"PropertyFeature"> | string
    propertyId?: UuidFilter<"PropertyFeature"> | string
    featureId?: UuidFilter<"PropertyFeature"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    feature?: XOR<FeatureMasterScalarRelationFilter, FeatureMasterWhereInput>
  }

  export type PropertyFeatureOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    featureId?: SortOrder
    property?: PropertyOrderByWithRelationInput
    feature?: FeatureMasterOrderByWithRelationInput
  }

  export type PropertyFeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    propertyId_featureId?: PropertyFeaturePropertyIdFeatureIdCompoundUniqueInput
    AND?: PropertyFeatureWhereInput | PropertyFeatureWhereInput[]
    OR?: PropertyFeatureWhereInput[]
    NOT?: PropertyFeatureWhereInput | PropertyFeatureWhereInput[]
    propertyId?: UuidFilter<"PropertyFeature"> | string
    featureId?: UuidFilter<"PropertyFeature"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    feature?: XOR<FeatureMasterScalarRelationFilter, FeatureMasterWhereInput>
  }, "id" | "propertyId_featureId">

  export type PropertyFeatureOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    featureId?: SortOrder
    _count?: PropertyFeatureCountOrderByAggregateInput
    _max?: PropertyFeatureMaxOrderByAggregateInput
    _min?: PropertyFeatureMinOrderByAggregateInput
  }

  export type PropertyFeatureScalarWhereWithAggregatesInput = {
    AND?: PropertyFeatureScalarWhereWithAggregatesInput | PropertyFeatureScalarWhereWithAggregatesInput[]
    OR?: PropertyFeatureScalarWhereWithAggregatesInput[]
    NOT?: PropertyFeatureScalarWhereWithAggregatesInput | PropertyFeatureScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PropertyFeature"> | string
    propertyId?: UuidWithAggregatesFilter<"PropertyFeature"> | string
    featureId?: UuidWithAggregatesFilter<"PropertyFeature"> | string
  }

  export type PropertyStationWhereInput = {
    AND?: PropertyStationWhereInput | PropertyStationWhereInput[]
    OR?: PropertyStationWhereInput[]
    NOT?: PropertyStationWhereInput | PropertyStationWhereInput[]
    id?: UuidFilter<"PropertyStation"> | string
    propertyId?: UuidFilter<"PropertyStation"> | string
    stationId?: UuidFilter<"PropertyStation"> | string
    walkMinutes?: IntNullableFilter<"PropertyStation"> | number | null
    busMinutes?: IntNullableFilter<"PropertyStation"> | number | null
    busStopName?: StringNullableFilter<"PropertyStation"> | string | null
    isPrimary?: BoolFilter<"PropertyStation"> | boolean
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    station?: XOR<StationScalarRelationFilter, StationWhereInput>
  }

  export type PropertyStationOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    stationId?: SortOrder
    walkMinutes?: SortOrderInput | SortOrder
    busMinutes?: SortOrderInput | SortOrder
    busStopName?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    property?: PropertyOrderByWithRelationInput
    station?: StationOrderByWithRelationInput
  }

  export type PropertyStationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    propertyId_stationId?: PropertyStationPropertyIdStationIdCompoundUniqueInput
    AND?: PropertyStationWhereInput | PropertyStationWhereInput[]
    OR?: PropertyStationWhereInput[]
    NOT?: PropertyStationWhereInput | PropertyStationWhereInput[]
    propertyId?: UuidFilter<"PropertyStation"> | string
    stationId?: UuidFilter<"PropertyStation"> | string
    walkMinutes?: IntNullableFilter<"PropertyStation"> | number | null
    busMinutes?: IntNullableFilter<"PropertyStation"> | number | null
    busStopName?: StringNullableFilter<"PropertyStation"> | string | null
    isPrimary?: BoolFilter<"PropertyStation"> | boolean
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    station?: XOR<StationScalarRelationFilter, StationWhereInput>
  }, "id" | "propertyId_stationId">

  export type PropertyStationOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    stationId?: SortOrder
    walkMinutes?: SortOrderInput | SortOrder
    busMinutes?: SortOrderInput | SortOrder
    busStopName?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    _count?: PropertyStationCountOrderByAggregateInput
    _avg?: PropertyStationAvgOrderByAggregateInput
    _max?: PropertyStationMaxOrderByAggregateInput
    _min?: PropertyStationMinOrderByAggregateInput
    _sum?: PropertyStationSumOrderByAggregateInput
  }

  export type PropertyStationScalarWhereWithAggregatesInput = {
    AND?: PropertyStationScalarWhereWithAggregatesInput | PropertyStationScalarWhereWithAggregatesInput[]
    OR?: PropertyStationScalarWhereWithAggregatesInput[]
    NOT?: PropertyStationScalarWhereWithAggregatesInput | PropertyStationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PropertyStation"> | string
    propertyId?: UuidWithAggregatesFilter<"PropertyStation"> | string
    stationId?: UuidWithAggregatesFilter<"PropertyStation"> | string
    walkMinutes?: IntNullableWithAggregatesFilter<"PropertyStation"> | number | null
    busMinutes?: IntNullableWithAggregatesFilter<"PropertyStation"> | number | null
    busStopName?: StringNullableWithAggregatesFilter<"PropertyStation"> | string | null
    isPrimary?: BoolWithAggregatesFilter<"PropertyStation"> | boolean
  }

  export type FavoriteWhereInput = {
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    id?: UuidFilter<"Favorite"> | string
    userId?: UuidFilter<"Favorite"> | string
    propertyId?: UuidFilter<"Favorite"> | string
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type FavoriteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    property?: PropertyOrderByWithRelationInput
  }

  export type FavoriteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_propertyId?: FavoriteUserIdPropertyIdCompoundUniqueInput
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    userId?: UuidFilter<"Favorite"> | string
    propertyId?: UuidFilter<"Favorite"> | string
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id" | "userId_propertyId">

  export type FavoriteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    _count?: FavoriteCountOrderByAggregateInput
    _max?: FavoriteMaxOrderByAggregateInput
    _min?: FavoriteMinOrderByAggregateInput
  }

  export type FavoriteScalarWhereWithAggregatesInput = {
    AND?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    OR?: FavoriteScalarWhereWithAggregatesInput[]
    NOT?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Favorite"> | string
    userId?: UuidWithAggregatesFilter<"Favorite"> | string
    propertyId?: UuidWithAggregatesFilter<"Favorite"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Favorite"> | Date | string
  }

  export type PropertyViewWhereInput = {
    AND?: PropertyViewWhereInput | PropertyViewWhereInput[]
    OR?: PropertyViewWhereInput[]
    NOT?: PropertyViewWhereInput | PropertyViewWhereInput[]
    id?: UuidFilter<"PropertyView"> | string
    propertyId?: UuidFilter<"PropertyView"> | string
    userId?: UuidNullableFilter<"PropertyView"> | string | null
    sessionId?: StringNullableFilter<"PropertyView"> | string | null
    ipAddress?: StringNullableFilter<"PropertyView"> | string | null
    userAgent?: StringNullableFilter<"PropertyView"> | string | null
    referer?: StringNullableFilter<"PropertyView"> | string | null
    viewedAt?: DateTimeFilter<"PropertyView"> | Date | string
    viewDurationSeconds?: IntNullableFilter<"PropertyView"> | number | null
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PropertyViewOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    userId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    referer?: SortOrderInput | SortOrder
    viewedAt?: SortOrder
    viewDurationSeconds?: SortOrderInput | SortOrder
    property?: PropertyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PropertyViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyViewWhereInput | PropertyViewWhereInput[]
    OR?: PropertyViewWhereInput[]
    NOT?: PropertyViewWhereInput | PropertyViewWhereInput[]
    propertyId?: UuidFilter<"PropertyView"> | string
    userId?: UuidNullableFilter<"PropertyView"> | string | null
    sessionId?: StringNullableFilter<"PropertyView"> | string | null
    ipAddress?: StringNullableFilter<"PropertyView"> | string | null
    userAgent?: StringNullableFilter<"PropertyView"> | string | null
    referer?: StringNullableFilter<"PropertyView"> | string | null
    viewedAt?: DateTimeFilter<"PropertyView"> | Date | string
    viewDurationSeconds?: IntNullableFilter<"PropertyView"> | number | null
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type PropertyViewOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    userId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    referer?: SortOrderInput | SortOrder
    viewedAt?: SortOrder
    viewDurationSeconds?: SortOrderInput | SortOrder
    _count?: PropertyViewCountOrderByAggregateInput
    _avg?: PropertyViewAvgOrderByAggregateInput
    _max?: PropertyViewMaxOrderByAggregateInput
    _min?: PropertyViewMinOrderByAggregateInput
    _sum?: PropertyViewSumOrderByAggregateInput
  }

  export type PropertyViewScalarWhereWithAggregatesInput = {
    AND?: PropertyViewScalarWhereWithAggregatesInput | PropertyViewScalarWhereWithAggregatesInput[]
    OR?: PropertyViewScalarWhereWithAggregatesInput[]
    NOT?: PropertyViewScalarWhereWithAggregatesInput | PropertyViewScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PropertyView"> | string
    propertyId?: UuidWithAggregatesFilter<"PropertyView"> | string
    userId?: UuidNullableWithAggregatesFilter<"PropertyView"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"PropertyView"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"PropertyView"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"PropertyView"> | string | null
    referer?: StringNullableWithAggregatesFilter<"PropertyView"> | string | null
    viewedAt?: DateTimeWithAggregatesFilter<"PropertyView"> | Date | string
    viewDurationSeconds?: IntNullableWithAggregatesFilter<"PropertyView"> | number | null
  }

  export type PropertyViewDailyWhereInput = {
    AND?: PropertyViewDailyWhereInput | PropertyViewDailyWhereInput[]
    OR?: PropertyViewDailyWhereInput[]
    NOT?: PropertyViewDailyWhereInput | PropertyViewDailyWhereInput[]
    id?: UuidFilter<"PropertyViewDaily"> | string
    propertyId?: UuidFilter<"PropertyViewDaily"> | string
    viewDate?: DateTimeFilter<"PropertyViewDaily"> | Date | string
    totalViews?: IntFilter<"PropertyViewDaily"> | number
    uniqueUsers?: IntFilter<"PropertyViewDaily"> | number
    avgDurationSeconds?: DecimalNullableFilter<"PropertyViewDaily"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"PropertyViewDaily"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertyViewDailyOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    viewDate?: SortOrder
    totalViews?: SortOrder
    uniqueUsers?: SortOrder
    avgDurationSeconds?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertyViewDailyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    propertyId_viewDate?: PropertyViewDailyPropertyIdViewDateCompoundUniqueInput
    AND?: PropertyViewDailyWhereInput | PropertyViewDailyWhereInput[]
    OR?: PropertyViewDailyWhereInput[]
    NOT?: PropertyViewDailyWhereInput | PropertyViewDailyWhereInput[]
    propertyId?: UuidFilter<"PropertyViewDaily"> | string
    viewDate?: DateTimeFilter<"PropertyViewDaily"> | Date | string
    totalViews?: IntFilter<"PropertyViewDaily"> | number
    uniqueUsers?: IntFilter<"PropertyViewDaily"> | number
    avgDurationSeconds?: DecimalNullableFilter<"PropertyViewDaily"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"PropertyViewDaily"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id" | "propertyId_viewDate">

  export type PropertyViewDailyOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    viewDate?: SortOrder
    totalViews?: SortOrder
    uniqueUsers?: SortOrder
    avgDurationSeconds?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PropertyViewDailyCountOrderByAggregateInput
    _avg?: PropertyViewDailyAvgOrderByAggregateInput
    _max?: PropertyViewDailyMaxOrderByAggregateInput
    _min?: PropertyViewDailyMinOrderByAggregateInput
    _sum?: PropertyViewDailySumOrderByAggregateInput
  }

  export type PropertyViewDailyScalarWhereWithAggregatesInput = {
    AND?: PropertyViewDailyScalarWhereWithAggregatesInput | PropertyViewDailyScalarWhereWithAggregatesInput[]
    OR?: PropertyViewDailyScalarWhereWithAggregatesInput[]
    NOT?: PropertyViewDailyScalarWhereWithAggregatesInput | PropertyViewDailyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PropertyViewDaily"> | string
    propertyId?: UuidWithAggregatesFilter<"PropertyViewDaily"> | string
    viewDate?: DateTimeWithAggregatesFilter<"PropertyViewDaily"> | Date | string
    totalViews?: IntWithAggregatesFilter<"PropertyViewDaily"> | number
    uniqueUsers?: IntWithAggregatesFilter<"PropertyViewDaily"> | number
    avgDurationSeconds?: DecimalNullableWithAggregatesFilter<"PropertyViewDaily"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PropertyViewDaily"> | Date | string
  }

  export type InquiryWhereInput = {
    AND?: InquiryWhereInput | InquiryWhereInput[]
    OR?: InquiryWhereInput[]
    NOT?: InquiryWhereInput | InquiryWhereInput[]
    id?: UuidFilter<"Inquiry"> | string
    inquiryNumber?: StringFilter<"Inquiry"> | string
    targetType?: EnumTargetTypeFilter<"Inquiry"> | $Enums.TargetType
    targetId?: UuidNullableFilter<"Inquiry"> | string | null
    name?: StringFilter<"Inquiry"> | string
    furigana?: StringNullableFilter<"Inquiry"> | string | null
    email?: StringFilter<"Inquiry"> | string
    phone?: StringNullableFilter<"Inquiry"> | string | null
    companyName?: StringNullableFilter<"Inquiry"> | string | null
    inquiryType?: EnumInquiryTypeFilter<"Inquiry"> | $Enums.InquiryType
    subject?: StringNullableFilter<"Inquiry"> | string | null
    message?: StringFilter<"Inquiry"> | string
    status?: EnumInquiryStatusFilter<"Inquiry"> | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFilter<"Inquiry"> | $Enums.InquiryPriority
    userId?: UuidNullableFilter<"Inquiry"> | string | null
    assignedAgentId?: UuidNullableFilter<"Inquiry"> | string | null
    assignedAt?: DateTimeNullableFilter<"Inquiry"> | Date | string | null
    responseCount?: IntFilter<"Inquiry"> | number
    lastRespondedAt?: DateTimeNullableFilter<"Inquiry"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"Inquiry"> | Date | string | null
    closedReason?: StringNullableFilter<"Inquiry"> | string | null
    source?: StringNullableFilter<"Inquiry"> | string | null
    metadata?: JsonNullableFilter<"Inquiry">
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Inquiry"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    assignedAgent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
    messages?: InquiryMessageListRelationFilter
  }

  export type InquiryOrderByWithRelationInput = {
    id?: SortOrder
    inquiryNumber?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrderInput | SortOrder
    name?: SortOrder
    furigana?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    inquiryType?: SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    userId?: SortOrderInput | SortOrder
    assignedAgentId?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    responseCount?: SortOrder
    lastRespondedAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    closedReason?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    assignedAgent?: AgentOrderByWithRelationInput
    property?: PropertyOrderByWithRelationInput
    messages?: InquiryMessageOrderByRelationAggregateInput
  }

  export type InquiryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    inquiryNumber?: string
    AND?: InquiryWhereInput | InquiryWhereInput[]
    OR?: InquiryWhereInput[]
    NOT?: InquiryWhereInput | InquiryWhereInput[]
    targetType?: EnumTargetTypeFilter<"Inquiry"> | $Enums.TargetType
    targetId?: UuidNullableFilter<"Inquiry"> | string | null
    name?: StringFilter<"Inquiry"> | string
    furigana?: StringNullableFilter<"Inquiry"> | string | null
    email?: StringFilter<"Inquiry"> | string
    phone?: StringNullableFilter<"Inquiry"> | string | null
    companyName?: StringNullableFilter<"Inquiry"> | string | null
    inquiryType?: EnumInquiryTypeFilter<"Inquiry"> | $Enums.InquiryType
    subject?: StringNullableFilter<"Inquiry"> | string | null
    message?: StringFilter<"Inquiry"> | string
    status?: EnumInquiryStatusFilter<"Inquiry"> | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFilter<"Inquiry"> | $Enums.InquiryPriority
    userId?: UuidNullableFilter<"Inquiry"> | string | null
    assignedAgentId?: UuidNullableFilter<"Inquiry"> | string | null
    assignedAt?: DateTimeNullableFilter<"Inquiry"> | Date | string | null
    responseCount?: IntFilter<"Inquiry"> | number
    lastRespondedAt?: DateTimeNullableFilter<"Inquiry"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"Inquiry"> | Date | string | null
    closedReason?: StringNullableFilter<"Inquiry"> | string | null
    source?: StringNullableFilter<"Inquiry"> | string | null
    metadata?: JsonNullableFilter<"Inquiry">
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Inquiry"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    assignedAgent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
    messages?: InquiryMessageListRelationFilter
  }, "id" | "inquiryNumber">

  export type InquiryOrderByWithAggregationInput = {
    id?: SortOrder
    inquiryNumber?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrderInput | SortOrder
    name?: SortOrder
    furigana?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    inquiryType?: SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    userId?: SortOrderInput | SortOrder
    assignedAgentId?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    responseCount?: SortOrder
    lastRespondedAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    closedReason?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InquiryCountOrderByAggregateInput
    _avg?: InquiryAvgOrderByAggregateInput
    _max?: InquiryMaxOrderByAggregateInput
    _min?: InquiryMinOrderByAggregateInput
    _sum?: InquirySumOrderByAggregateInput
  }

  export type InquiryScalarWhereWithAggregatesInput = {
    AND?: InquiryScalarWhereWithAggregatesInput | InquiryScalarWhereWithAggregatesInput[]
    OR?: InquiryScalarWhereWithAggregatesInput[]
    NOT?: InquiryScalarWhereWithAggregatesInput | InquiryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Inquiry"> | string
    inquiryNumber?: StringWithAggregatesFilter<"Inquiry"> | string
    targetType?: EnumTargetTypeWithAggregatesFilter<"Inquiry"> | $Enums.TargetType
    targetId?: UuidNullableWithAggregatesFilter<"Inquiry"> | string | null
    name?: StringWithAggregatesFilter<"Inquiry"> | string
    furigana?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    email?: StringWithAggregatesFilter<"Inquiry"> | string
    phone?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    companyName?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    inquiryType?: EnumInquiryTypeWithAggregatesFilter<"Inquiry"> | $Enums.InquiryType
    subject?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    message?: StringWithAggregatesFilter<"Inquiry"> | string
    status?: EnumInquiryStatusWithAggregatesFilter<"Inquiry"> | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityWithAggregatesFilter<"Inquiry"> | $Enums.InquiryPriority
    userId?: UuidNullableWithAggregatesFilter<"Inquiry"> | string | null
    assignedAgentId?: UuidNullableWithAggregatesFilter<"Inquiry"> | string | null
    assignedAt?: DateTimeNullableWithAggregatesFilter<"Inquiry"> | Date | string | null
    responseCount?: IntWithAggregatesFilter<"Inquiry"> | number
    lastRespondedAt?: DateTimeNullableWithAggregatesFilter<"Inquiry"> | Date | string | null
    closedAt?: DateTimeNullableWithAggregatesFilter<"Inquiry"> | Date | string | null
    closedReason?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    source?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Inquiry">
    createdAt?: DateTimeWithAggregatesFilter<"Inquiry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inquiry"> | Date | string
  }

  export type InquiryMessageWhereInput = {
    AND?: InquiryMessageWhereInput | InquiryMessageWhereInput[]
    OR?: InquiryMessageWhereInput[]
    NOT?: InquiryMessageWhereInput | InquiryMessageWhereInput[]
    id?: UuidFilter<"InquiryMessage"> | string
    inquiryId?: UuidFilter<"InquiryMessage"> | string
    senderId?: UuidNullableFilter<"InquiryMessage"> | string | null
    senderType?: EnumSenderTypeFilter<"InquiryMessage"> | $Enums.SenderType
    message?: StringFilter<"InquiryMessage"> | string
    attachments?: JsonNullableFilter<"InquiryMessage">
    isInternal?: BoolFilter<"InquiryMessage"> | boolean
    createdAt?: DateTimeFilter<"InquiryMessage"> | Date | string
    inquiry?: XOR<InquiryScalarRelationFilter, InquiryWhereInput>
  }

  export type InquiryMessageOrderByWithRelationInput = {
    id?: SortOrder
    inquiryId?: SortOrder
    senderId?: SortOrderInput | SortOrder
    senderType?: SortOrder
    message?: SortOrder
    attachments?: SortOrderInput | SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    inquiry?: InquiryOrderByWithRelationInput
  }

  export type InquiryMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InquiryMessageWhereInput | InquiryMessageWhereInput[]
    OR?: InquiryMessageWhereInput[]
    NOT?: InquiryMessageWhereInput | InquiryMessageWhereInput[]
    inquiryId?: UuidFilter<"InquiryMessage"> | string
    senderId?: UuidNullableFilter<"InquiryMessage"> | string | null
    senderType?: EnumSenderTypeFilter<"InquiryMessage"> | $Enums.SenderType
    message?: StringFilter<"InquiryMessage"> | string
    attachments?: JsonNullableFilter<"InquiryMessage">
    isInternal?: BoolFilter<"InquiryMessage"> | boolean
    createdAt?: DateTimeFilter<"InquiryMessage"> | Date | string
    inquiry?: XOR<InquiryScalarRelationFilter, InquiryWhereInput>
  }, "id">

  export type InquiryMessageOrderByWithAggregationInput = {
    id?: SortOrder
    inquiryId?: SortOrder
    senderId?: SortOrderInput | SortOrder
    senderType?: SortOrder
    message?: SortOrder
    attachments?: SortOrderInput | SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    _count?: InquiryMessageCountOrderByAggregateInput
    _max?: InquiryMessageMaxOrderByAggregateInput
    _min?: InquiryMessageMinOrderByAggregateInput
  }

  export type InquiryMessageScalarWhereWithAggregatesInput = {
    AND?: InquiryMessageScalarWhereWithAggregatesInput | InquiryMessageScalarWhereWithAggregatesInput[]
    OR?: InquiryMessageScalarWhereWithAggregatesInput[]
    NOT?: InquiryMessageScalarWhereWithAggregatesInput | InquiryMessageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"InquiryMessage"> | string
    inquiryId?: UuidWithAggregatesFilter<"InquiryMessage"> | string
    senderId?: UuidNullableWithAggregatesFilter<"InquiryMessage"> | string | null
    senderType?: EnumSenderTypeWithAggregatesFilter<"InquiryMessage"> | $Enums.SenderType
    message?: StringWithAggregatesFilter<"InquiryMessage"> | string
    attachments?: JsonNullableWithAggregatesFilter<"InquiryMessage">
    isInternal?: BoolWithAggregatesFilter<"InquiryMessage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"InquiryMessage"> | Date | string
  }

  export type BulkAssessmentWhereInput = {
    AND?: BulkAssessmentWhereInput | BulkAssessmentWhereInput[]
    OR?: BulkAssessmentWhereInput[]
    NOT?: BulkAssessmentWhereInput | BulkAssessmentWhereInput[]
    id?: UuidFilter<"BulkAssessment"> | string
    assessmentNumber?: StringFilter<"BulkAssessment"> | string
    propertyAddress?: StringFilter<"BulkAssessment"> | string
    propertyTypeId?: UuidNullableFilter<"BulkAssessment"> | string | null
    buildingArea?: DecimalNullableFilter<"BulkAssessment"> | Decimal | DecimalJsLike | number | string | null
    landArea?: DecimalNullableFilter<"BulkAssessment"> | Decimal | DecimalJsLike | number | string | null
    constructionYear?: IntNullableFilter<"BulkAssessment"> | number | null
    ownerName?: StringFilter<"BulkAssessment"> | string
    email?: StringFilter<"BulkAssessment"> | string
    phone?: StringNullableFilter<"BulkAssessment"> | string | null
    preferredContactMethod?: StringNullableFilter<"BulkAssessment"> | string | null
    preferredContactTime?: StringNullableFilter<"BulkAssessment"> | string | null
    status?: EnumAssessmentStatusFilter<"BulkAssessment"> | $Enums.AssessmentStatus
    agentCount?: IntFilter<"BulkAssessment"> | number
    responseCount?: IntFilter<"BulkAssessment"> | number
    userId?: UuidNullableFilter<"BulkAssessment"> | string | null
    metadata?: JsonNullableFilter<"BulkAssessment">
    createdAt?: DateTimeFilter<"BulkAssessment"> | Date | string
    completedAt?: DateTimeNullableFilter<"BulkAssessment"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    propertyType?: XOR<PropertyTypeMasterNullableScalarRelationFilter, PropertyTypeMasterWhereInput> | null
    responses?: BulkAssessmentResponseListRelationFilter
  }

  export type BulkAssessmentOrderByWithRelationInput = {
    id?: SortOrder
    assessmentNumber?: SortOrder
    propertyAddress?: SortOrder
    propertyTypeId?: SortOrderInput | SortOrder
    buildingArea?: SortOrderInput | SortOrder
    landArea?: SortOrderInput | SortOrder
    constructionYear?: SortOrderInput | SortOrder
    ownerName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    preferredContactMethod?: SortOrderInput | SortOrder
    preferredContactTime?: SortOrderInput | SortOrder
    status?: SortOrder
    agentCount?: SortOrder
    responseCount?: SortOrder
    userId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    propertyType?: PropertyTypeMasterOrderByWithRelationInput
    responses?: BulkAssessmentResponseOrderByRelationAggregateInput
  }

  export type BulkAssessmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    assessmentNumber?: string
    AND?: BulkAssessmentWhereInput | BulkAssessmentWhereInput[]
    OR?: BulkAssessmentWhereInput[]
    NOT?: BulkAssessmentWhereInput | BulkAssessmentWhereInput[]
    propertyAddress?: StringFilter<"BulkAssessment"> | string
    propertyTypeId?: UuidNullableFilter<"BulkAssessment"> | string | null
    buildingArea?: DecimalNullableFilter<"BulkAssessment"> | Decimal | DecimalJsLike | number | string | null
    landArea?: DecimalNullableFilter<"BulkAssessment"> | Decimal | DecimalJsLike | number | string | null
    constructionYear?: IntNullableFilter<"BulkAssessment"> | number | null
    ownerName?: StringFilter<"BulkAssessment"> | string
    email?: StringFilter<"BulkAssessment"> | string
    phone?: StringNullableFilter<"BulkAssessment"> | string | null
    preferredContactMethod?: StringNullableFilter<"BulkAssessment"> | string | null
    preferredContactTime?: StringNullableFilter<"BulkAssessment"> | string | null
    status?: EnumAssessmentStatusFilter<"BulkAssessment"> | $Enums.AssessmentStatus
    agentCount?: IntFilter<"BulkAssessment"> | number
    responseCount?: IntFilter<"BulkAssessment"> | number
    userId?: UuidNullableFilter<"BulkAssessment"> | string | null
    metadata?: JsonNullableFilter<"BulkAssessment">
    createdAt?: DateTimeFilter<"BulkAssessment"> | Date | string
    completedAt?: DateTimeNullableFilter<"BulkAssessment"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    propertyType?: XOR<PropertyTypeMasterNullableScalarRelationFilter, PropertyTypeMasterWhereInput> | null
    responses?: BulkAssessmentResponseListRelationFilter
  }, "id" | "assessmentNumber">

  export type BulkAssessmentOrderByWithAggregationInput = {
    id?: SortOrder
    assessmentNumber?: SortOrder
    propertyAddress?: SortOrder
    propertyTypeId?: SortOrderInput | SortOrder
    buildingArea?: SortOrderInput | SortOrder
    landArea?: SortOrderInput | SortOrder
    constructionYear?: SortOrderInput | SortOrder
    ownerName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    preferredContactMethod?: SortOrderInput | SortOrder
    preferredContactTime?: SortOrderInput | SortOrder
    status?: SortOrder
    agentCount?: SortOrder
    responseCount?: SortOrder
    userId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: BulkAssessmentCountOrderByAggregateInput
    _avg?: BulkAssessmentAvgOrderByAggregateInput
    _max?: BulkAssessmentMaxOrderByAggregateInput
    _min?: BulkAssessmentMinOrderByAggregateInput
    _sum?: BulkAssessmentSumOrderByAggregateInput
  }

  export type BulkAssessmentScalarWhereWithAggregatesInput = {
    AND?: BulkAssessmentScalarWhereWithAggregatesInput | BulkAssessmentScalarWhereWithAggregatesInput[]
    OR?: BulkAssessmentScalarWhereWithAggregatesInput[]
    NOT?: BulkAssessmentScalarWhereWithAggregatesInput | BulkAssessmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BulkAssessment"> | string
    assessmentNumber?: StringWithAggregatesFilter<"BulkAssessment"> | string
    propertyAddress?: StringWithAggregatesFilter<"BulkAssessment"> | string
    propertyTypeId?: UuidNullableWithAggregatesFilter<"BulkAssessment"> | string | null
    buildingArea?: DecimalNullableWithAggregatesFilter<"BulkAssessment"> | Decimal | DecimalJsLike | number | string | null
    landArea?: DecimalNullableWithAggregatesFilter<"BulkAssessment"> | Decimal | DecimalJsLike | number | string | null
    constructionYear?: IntNullableWithAggregatesFilter<"BulkAssessment"> | number | null
    ownerName?: StringWithAggregatesFilter<"BulkAssessment"> | string
    email?: StringWithAggregatesFilter<"BulkAssessment"> | string
    phone?: StringNullableWithAggregatesFilter<"BulkAssessment"> | string | null
    preferredContactMethod?: StringNullableWithAggregatesFilter<"BulkAssessment"> | string | null
    preferredContactTime?: StringNullableWithAggregatesFilter<"BulkAssessment"> | string | null
    status?: EnumAssessmentStatusWithAggregatesFilter<"BulkAssessment"> | $Enums.AssessmentStatus
    agentCount?: IntWithAggregatesFilter<"BulkAssessment"> | number
    responseCount?: IntWithAggregatesFilter<"BulkAssessment"> | number
    userId?: UuidNullableWithAggregatesFilter<"BulkAssessment"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"BulkAssessment">
    createdAt?: DateTimeWithAggregatesFilter<"BulkAssessment"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"BulkAssessment"> | Date | string | null
  }

  export type BulkAssessmentResponseWhereInput = {
    AND?: BulkAssessmentResponseWhereInput | BulkAssessmentResponseWhereInput[]
    OR?: BulkAssessmentResponseWhereInput[]
    NOT?: BulkAssessmentResponseWhereInput | BulkAssessmentResponseWhereInput[]
    id?: UuidFilter<"BulkAssessmentResponse"> | string
    assessmentId?: UuidFilter<"BulkAssessmentResponse"> | string
    agentId?: UuidFilter<"BulkAssessmentResponse"> | string
    assessedPrice?: BigIntNullableFilter<"BulkAssessmentResponse"> | bigint | number | null
    priceRangeMin?: BigIntNullableFilter<"BulkAssessmentResponse"> | bigint | number | null
    priceRangeMax?: BigIntNullableFilter<"BulkAssessmentResponse"> | bigint | number | null
    comments?: StringNullableFilter<"BulkAssessmentResponse"> | string | null
    proposalDocument?: StringNullableFilter<"BulkAssessmentResponse"> | string | null
    status?: EnumResponseStatusFilter<"BulkAssessmentResponse"> | $Enums.ResponseStatus
    submittedAt?: DateTimeNullableFilter<"BulkAssessmentResponse"> | Date | string | null
    viewedAt?: DateTimeNullableFilter<"BulkAssessmentResponse"> | Date | string | null
    createdAt?: DateTimeFilter<"BulkAssessmentResponse"> | Date | string
    assessment?: XOR<BulkAssessmentScalarRelationFilter, BulkAssessmentWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type BulkAssessmentResponseOrderByWithRelationInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    agentId?: SortOrder
    assessedPrice?: SortOrderInput | SortOrder
    priceRangeMin?: SortOrderInput | SortOrder
    priceRangeMax?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    proposalDocument?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    viewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    assessment?: BulkAssessmentOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
  }

  export type BulkAssessmentResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BulkAssessmentResponseWhereInput | BulkAssessmentResponseWhereInput[]
    OR?: BulkAssessmentResponseWhereInput[]
    NOT?: BulkAssessmentResponseWhereInput | BulkAssessmentResponseWhereInput[]
    assessmentId?: UuidFilter<"BulkAssessmentResponse"> | string
    agentId?: UuidFilter<"BulkAssessmentResponse"> | string
    assessedPrice?: BigIntNullableFilter<"BulkAssessmentResponse"> | bigint | number | null
    priceRangeMin?: BigIntNullableFilter<"BulkAssessmentResponse"> | bigint | number | null
    priceRangeMax?: BigIntNullableFilter<"BulkAssessmentResponse"> | bigint | number | null
    comments?: StringNullableFilter<"BulkAssessmentResponse"> | string | null
    proposalDocument?: StringNullableFilter<"BulkAssessmentResponse"> | string | null
    status?: EnumResponseStatusFilter<"BulkAssessmentResponse"> | $Enums.ResponseStatus
    submittedAt?: DateTimeNullableFilter<"BulkAssessmentResponse"> | Date | string | null
    viewedAt?: DateTimeNullableFilter<"BulkAssessmentResponse"> | Date | string | null
    createdAt?: DateTimeFilter<"BulkAssessmentResponse"> | Date | string
    assessment?: XOR<BulkAssessmentScalarRelationFilter, BulkAssessmentWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id">

  export type BulkAssessmentResponseOrderByWithAggregationInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    agentId?: SortOrder
    assessedPrice?: SortOrderInput | SortOrder
    priceRangeMin?: SortOrderInput | SortOrder
    priceRangeMax?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    proposalDocument?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    viewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BulkAssessmentResponseCountOrderByAggregateInput
    _avg?: BulkAssessmentResponseAvgOrderByAggregateInput
    _max?: BulkAssessmentResponseMaxOrderByAggregateInput
    _min?: BulkAssessmentResponseMinOrderByAggregateInput
    _sum?: BulkAssessmentResponseSumOrderByAggregateInput
  }

  export type BulkAssessmentResponseScalarWhereWithAggregatesInput = {
    AND?: BulkAssessmentResponseScalarWhereWithAggregatesInput | BulkAssessmentResponseScalarWhereWithAggregatesInput[]
    OR?: BulkAssessmentResponseScalarWhereWithAggregatesInput[]
    NOT?: BulkAssessmentResponseScalarWhereWithAggregatesInput | BulkAssessmentResponseScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BulkAssessmentResponse"> | string
    assessmentId?: UuidWithAggregatesFilter<"BulkAssessmentResponse"> | string
    agentId?: UuidWithAggregatesFilter<"BulkAssessmentResponse"> | string
    assessedPrice?: BigIntNullableWithAggregatesFilter<"BulkAssessmentResponse"> | bigint | number | null
    priceRangeMin?: BigIntNullableWithAggregatesFilter<"BulkAssessmentResponse"> | bigint | number | null
    priceRangeMax?: BigIntNullableWithAggregatesFilter<"BulkAssessmentResponse"> | bigint | number | null
    comments?: StringNullableWithAggregatesFilter<"BulkAssessmentResponse"> | string | null
    proposalDocument?: StringNullableWithAggregatesFilter<"BulkAssessmentResponse"> | string | null
    status?: EnumResponseStatusWithAggregatesFilter<"BulkAssessmentResponse"> | $Enums.ResponseStatus
    submittedAt?: DateTimeNullableWithAggregatesFilter<"BulkAssessmentResponse"> | Date | string | null
    viewedAt?: DateTimeNullableWithAggregatesFilter<"BulkAssessmentResponse"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BulkAssessmentResponse"> | Date | string
  }

  export type QuestionWhereInput = {
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    id?: UuidFilter<"Question"> | string
    questionNumber?: StringFilter<"Question"> | string
    title?: StringFilter<"Question"> | string
    content?: StringFilter<"Question"> | string
    categoryId?: UuidNullableFilter<"Question"> | string | null
    tags?: StringNullableListFilter<"Question">
    viewCount?: IntFilter<"Question"> | number
    answerCount?: IntFilter<"Question"> | number
    status?: EnumQuestionStatusFilter<"Question"> | $Enums.QuestionStatus
    authorId?: UuidFilter<"Question"> | string
    bestAnswerId?: UuidNullableFilter<"Question"> | string | null
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Question"> | Date | string | null
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    category?: XOR<QuestionCategoryNullableScalarRelationFilter, QuestionCategoryWhereInput> | null
    answers?: AnswerListRelationFilter
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    questionNumber?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    tags?: SortOrder
    viewCount?: SortOrder
    answerCount?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    bestAnswerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    author?: UserOrderByWithRelationInput
    category?: QuestionCategoryOrderByWithRelationInput
    answers?: AnswerOrderByRelationAggregateInput
  }

  export type QuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    questionNumber?: string
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    title?: StringFilter<"Question"> | string
    content?: StringFilter<"Question"> | string
    categoryId?: UuidNullableFilter<"Question"> | string | null
    tags?: StringNullableListFilter<"Question">
    viewCount?: IntFilter<"Question"> | number
    answerCount?: IntFilter<"Question"> | number
    status?: EnumQuestionStatusFilter<"Question"> | $Enums.QuestionStatus
    authorId?: UuidFilter<"Question"> | string
    bestAnswerId?: UuidNullableFilter<"Question"> | string | null
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Question"> | Date | string | null
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    category?: XOR<QuestionCategoryNullableScalarRelationFilter, QuestionCategoryWhereInput> | null
    answers?: AnswerListRelationFilter
  }, "id" | "questionNumber">

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    questionNumber?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    tags?: SortOrder
    viewCount?: SortOrder
    answerCount?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    bestAnswerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _avg?: QuestionAvgOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
    _sum?: QuestionSumOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    OR?: QuestionScalarWhereWithAggregatesInput[]
    NOT?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Question"> | string
    questionNumber?: StringWithAggregatesFilter<"Question"> | string
    title?: StringWithAggregatesFilter<"Question"> | string
    content?: StringWithAggregatesFilter<"Question"> | string
    categoryId?: UuidNullableWithAggregatesFilter<"Question"> | string | null
    tags?: StringNullableListFilter<"Question">
    viewCount?: IntWithAggregatesFilter<"Question"> | number
    answerCount?: IntWithAggregatesFilter<"Question"> | number
    status?: EnumQuestionStatusWithAggregatesFilter<"Question"> | $Enums.QuestionStatus
    authorId?: UuidWithAggregatesFilter<"Question"> | string
    bestAnswerId?: UuidNullableWithAggregatesFilter<"Question"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Question"> | Date | string | null
  }

  export type AnswerWhereInput = {
    AND?: AnswerWhereInput | AnswerWhereInput[]
    OR?: AnswerWhereInput[]
    NOT?: AnswerWhereInput | AnswerWhereInput[]
    id?: UuidFilter<"Answer"> | string
    questionId?: UuidFilter<"Answer"> | string
    content?: StringFilter<"Answer"> | string
    goodCount?: IntFilter<"Answer"> | number
    isBestAnswer?: BoolFilter<"Answer"> | boolean
    authorId?: UuidNullableFilter<"Answer"> | string | null
    agentId?: UuidNullableFilter<"Answer"> | string | null
    createdAt?: DateTimeFilter<"Answer"> | Date | string
    updatedAt?: DateTimeFilter<"Answer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Answer"> | Date | string | null
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
  }

  export type AnswerOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    content?: SortOrder
    goodCount?: SortOrder
    isBestAnswer?: SortOrder
    authorId?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    question?: QuestionOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
  }

  export type AnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnswerWhereInput | AnswerWhereInput[]
    OR?: AnswerWhereInput[]
    NOT?: AnswerWhereInput | AnswerWhereInput[]
    questionId?: UuidFilter<"Answer"> | string
    content?: StringFilter<"Answer"> | string
    goodCount?: IntFilter<"Answer"> | number
    isBestAnswer?: BoolFilter<"Answer"> | boolean
    authorId?: UuidNullableFilter<"Answer"> | string | null
    agentId?: UuidNullableFilter<"Answer"> | string | null
    createdAt?: DateTimeFilter<"Answer"> | Date | string
    updatedAt?: DateTimeFilter<"Answer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Answer"> | Date | string | null
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
  }, "id">

  export type AnswerOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    content?: SortOrder
    goodCount?: SortOrder
    isBestAnswer?: SortOrder
    authorId?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: AnswerCountOrderByAggregateInput
    _avg?: AnswerAvgOrderByAggregateInput
    _max?: AnswerMaxOrderByAggregateInput
    _min?: AnswerMinOrderByAggregateInput
    _sum?: AnswerSumOrderByAggregateInput
  }

  export type AnswerScalarWhereWithAggregatesInput = {
    AND?: AnswerScalarWhereWithAggregatesInput | AnswerScalarWhereWithAggregatesInput[]
    OR?: AnswerScalarWhereWithAggregatesInput[]
    NOT?: AnswerScalarWhereWithAggregatesInput | AnswerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Answer"> | string
    questionId?: UuidWithAggregatesFilter<"Answer"> | string
    content?: StringWithAggregatesFilter<"Answer"> | string
    goodCount?: IntWithAggregatesFilter<"Answer"> | number
    isBestAnswer?: BoolWithAggregatesFilter<"Answer"> | boolean
    authorId?: UuidNullableWithAggregatesFilter<"Answer"> | string | null
    agentId?: UuidNullableWithAggregatesFilter<"Answer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Answer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Answer"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Answer"> | Date | string | null
  }

  export type FeatureMasterWhereInput = {
    AND?: FeatureMasterWhereInput | FeatureMasterWhereInput[]
    OR?: FeatureMasterWhereInput[]
    NOT?: FeatureMasterWhereInput | FeatureMasterWhereInput[]
    id?: UuidFilter<"FeatureMaster"> | string
    code?: StringFilter<"FeatureMaster"> | string
    name?: StringFilter<"FeatureMaster"> | string
    category?: EnumFeatureCategoryFilter<"FeatureMaster"> | $Enums.FeatureCategory
    icon?: StringNullableFilter<"FeatureMaster"> | string | null
    displayOrder?: IntFilter<"FeatureMaster"> | number
    isActive?: BoolFilter<"FeatureMaster"> | boolean
    properties?: PropertyFeatureListRelationFilter
  }

  export type FeatureMasterOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    icon?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    properties?: PropertyFeatureOrderByRelationAggregateInput
  }

  export type FeatureMasterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: FeatureMasterWhereInput | FeatureMasterWhereInput[]
    OR?: FeatureMasterWhereInput[]
    NOT?: FeatureMasterWhereInput | FeatureMasterWhereInput[]
    name?: StringFilter<"FeatureMaster"> | string
    category?: EnumFeatureCategoryFilter<"FeatureMaster"> | $Enums.FeatureCategory
    icon?: StringNullableFilter<"FeatureMaster"> | string | null
    displayOrder?: IntFilter<"FeatureMaster"> | number
    isActive?: BoolFilter<"FeatureMaster"> | boolean
    properties?: PropertyFeatureListRelationFilter
  }, "id" | "code">

  export type FeatureMasterOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    icon?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    _count?: FeatureMasterCountOrderByAggregateInput
    _avg?: FeatureMasterAvgOrderByAggregateInput
    _max?: FeatureMasterMaxOrderByAggregateInput
    _min?: FeatureMasterMinOrderByAggregateInput
    _sum?: FeatureMasterSumOrderByAggregateInput
  }

  export type FeatureMasterScalarWhereWithAggregatesInput = {
    AND?: FeatureMasterScalarWhereWithAggregatesInput | FeatureMasterScalarWhereWithAggregatesInput[]
    OR?: FeatureMasterScalarWhereWithAggregatesInput[]
    NOT?: FeatureMasterScalarWhereWithAggregatesInput | FeatureMasterScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FeatureMaster"> | string
    code?: StringWithAggregatesFilter<"FeatureMaster"> | string
    name?: StringWithAggregatesFilter<"FeatureMaster"> | string
    category?: EnumFeatureCategoryWithAggregatesFilter<"FeatureMaster"> | $Enums.FeatureCategory
    icon?: StringNullableWithAggregatesFilter<"FeatureMaster"> | string | null
    displayOrder?: IntWithAggregatesFilter<"FeatureMaster"> | number
    isActive?: BoolWithAggregatesFilter<"FeatureMaster"> | boolean
  }

  export type RegionMasterWhereInput = {
    AND?: RegionMasterWhereInput | RegionMasterWhereInput[]
    OR?: RegionMasterWhereInput[]
    NOT?: RegionMasterWhereInput | RegionMasterWhereInput[]
    id?: UuidFilter<"RegionMaster"> | string
    code?: StringFilter<"RegionMaster"> | string
    name?: StringFilter<"RegionMaster"> | string
    displayOrder?: IntFilter<"RegionMaster"> | number
    isActive?: BoolFilter<"RegionMaster"> | boolean
    areas?: AreaMasterListRelationFilter
  }

  export type RegionMasterOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    areas?: AreaMasterOrderByRelationAggregateInput
  }

  export type RegionMasterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: RegionMasterWhereInput | RegionMasterWhereInput[]
    OR?: RegionMasterWhereInput[]
    NOT?: RegionMasterWhereInput | RegionMasterWhereInput[]
    name?: StringFilter<"RegionMaster"> | string
    displayOrder?: IntFilter<"RegionMaster"> | number
    isActive?: BoolFilter<"RegionMaster"> | boolean
    areas?: AreaMasterListRelationFilter
  }, "id" | "code">

  export type RegionMasterOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    _count?: RegionMasterCountOrderByAggregateInput
    _avg?: RegionMasterAvgOrderByAggregateInput
    _max?: RegionMasterMaxOrderByAggregateInput
    _min?: RegionMasterMinOrderByAggregateInput
    _sum?: RegionMasterSumOrderByAggregateInput
  }

  export type RegionMasterScalarWhereWithAggregatesInput = {
    AND?: RegionMasterScalarWhereWithAggregatesInput | RegionMasterScalarWhereWithAggregatesInput[]
    OR?: RegionMasterScalarWhereWithAggregatesInput[]
    NOT?: RegionMasterScalarWhereWithAggregatesInput | RegionMasterScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RegionMaster"> | string
    code?: StringWithAggregatesFilter<"RegionMaster"> | string
    name?: StringWithAggregatesFilter<"RegionMaster"> | string
    displayOrder?: IntWithAggregatesFilter<"RegionMaster"> | number
    isActive?: BoolWithAggregatesFilter<"RegionMaster"> | boolean
  }

  export type AreaMasterWhereInput = {
    AND?: AreaMasterWhereInput | AreaMasterWhereInput[]
    OR?: AreaMasterWhereInput[]
    NOT?: AreaMasterWhereInput | AreaMasterWhereInput[]
    id?: UuidFilter<"AreaMaster"> | string
    regionId?: UuidNullableFilter<"AreaMaster"> | string | null
    prefectureCode?: StringFilter<"AreaMaster"> | string
    prefecture?: StringFilter<"AreaMaster"> | string
    cityCode?: StringNullableFilter<"AreaMaster"> | string | null
    city?: StringFilter<"AreaMaster"> | string
    displayOrder?: IntFilter<"AreaMaster"> | number
    isActive?: BoolFilter<"AreaMaster"> | boolean
    region?: XOR<RegionMasterNullableScalarRelationFilter, RegionMasterWhereInput> | null
    properties?: PropertyListRelationFilter
  }

  export type AreaMasterOrderByWithRelationInput = {
    id?: SortOrder
    regionId?: SortOrderInput | SortOrder
    prefectureCode?: SortOrder
    prefecture?: SortOrder
    cityCode?: SortOrderInput | SortOrder
    city?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    region?: RegionMasterOrderByWithRelationInput
    properties?: PropertyOrderByRelationAggregateInput
  }

  export type AreaMasterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    prefecture_city?: AreaMasterPrefectureCityCompoundUniqueInput
    AND?: AreaMasterWhereInput | AreaMasterWhereInput[]
    OR?: AreaMasterWhereInput[]
    NOT?: AreaMasterWhereInput | AreaMasterWhereInput[]
    regionId?: UuidNullableFilter<"AreaMaster"> | string | null
    prefectureCode?: StringFilter<"AreaMaster"> | string
    prefecture?: StringFilter<"AreaMaster"> | string
    cityCode?: StringNullableFilter<"AreaMaster"> | string | null
    city?: StringFilter<"AreaMaster"> | string
    displayOrder?: IntFilter<"AreaMaster"> | number
    isActive?: BoolFilter<"AreaMaster"> | boolean
    region?: XOR<RegionMasterNullableScalarRelationFilter, RegionMasterWhereInput> | null
    properties?: PropertyListRelationFilter
  }, "id" | "prefecture_city">

  export type AreaMasterOrderByWithAggregationInput = {
    id?: SortOrder
    regionId?: SortOrderInput | SortOrder
    prefectureCode?: SortOrder
    prefecture?: SortOrder
    cityCode?: SortOrderInput | SortOrder
    city?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    _count?: AreaMasterCountOrderByAggregateInput
    _avg?: AreaMasterAvgOrderByAggregateInput
    _max?: AreaMasterMaxOrderByAggregateInput
    _min?: AreaMasterMinOrderByAggregateInput
    _sum?: AreaMasterSumOrderByAggregateInput
  }

  export type AreaMasterScalarWhereWithAggregatesInput = {
    AND?: AreaMasterScalarWhereWithAggregatesInput | AreaMasterScalarWhereWithAggregatesInput[]
    OR?: AreaMasterScalarWhereWithAggregatesInput[]
    NOT?: AreaMasterScalarWhereWithAggregatesInput | AreaMasterScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AreaMaster"> | string
    regionId?: UuidNullableWithAggregatesFilter<"AreaMaster"> | string | null
    prefectureCode?: StringWithAggregatesFilter<"AreaMaster"> | string
    prefecture?: StringWithAggregatesFilter<"AreaMaster"> | string
    cityCode?: StringNullableWithAggregatesFilter<"AreaMaster"> | string | null
    city?: StringWithAggregatesFilter<"AreaMaster"> | string
    displayOrder?: IntWithAggregatesFilter<"AreaMaster"> | number
    isActive?: BoolWithAggregatesFilter<"AreaMaster"> | boolean
  }

  export type PropertyTypeMasterWhereInput = {
    AND?: PropertyTypeMasterWhereInput | PropertyTypeMasterWhereInput[]
    OR?: PropertyTypeMasterWhereInput[]
    NOT?: PropertyTypeMasterWhereInput | PropertyTypeMasterWhereInput[]
    id?: UuidFilter<"PropertyTypeMaster"> | string
    code?: StringFilter<"PropertyTypeMaster"> | string
    name?: StringFilter<"PropertyTypeMaster"> | string
    description?: StringNullableFilter<"PropertyTypeMaster"> | string | null
    displayOrder?: IntFilter<"PropertyTypeMaster"> | number
    isActive?: BoolFilter<"PropertyTypeMaster"> | boolean
    properties?: PropertyListRelationFilter
    bulkAssessments?: BulkAssessmentListRelationFilter
  }

  export type PropertyTypeMasterOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    properties?: PropertyOrderByRelationAggregateInput
    bulkAssessments?: BulkAssessmentOrderByRelationAggregateInput
  }

  export type PropertyTypeMasterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PropertyTypeMasterWhereInput | PropertyTypeMasterWhereInput[]
    OR?: PropertyTypeMasterWhereInput[]
    NOT?: PropertyTypeMasterWhereInput | PropertyTypeMasterWhereInput[]
    name?: StringFilter<"PropertyTypeMaster"> | string
    description?: StringNullableFilter<"PropertyTypeMaster"> | string | null
    displayOrder?: IntFilter<"PropertyTypeMaster"> | number
    isActive?: BoolFilter<"PropertyTypeMaster"> | boolean
    properties?: PropertyListRelationFilter
    bulkAssessments?: BulkAssessmentListRelationFilter
  }, "id" | "code">

  export type PropertyTypeMasterOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    _count?: PropertyTypeMasterCountOrderByAggregateInput
    _avg?: PropertyTypeMasterAvgOrderByAggregateInput
    _max?: PropertyTypeMasterMaxOrderByAggregateInput
    _min?: PropertyTypeMasterMinOrderByAggregateInput
    _sum?: PropertyTypeMasterSumOrderByAggregateInput
  }

  export type PropertyTypeMasterScalarWhereWithAggregatesInput = {
    AND?: PropertyTypeMasterScalarWhereWithAggregatesInput | PropertyTypeMasterScalarWhereWithAggregatesInput[]
    OR?: PropertyTypeMasterScalarWhereWithAggregatesInput[]
    NOT?: PropertyTypeMasterScalarWhereWithAggregatesInput | PropertyTypeMasterScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PropertyTypeMaster"> | string
    code?: StringWithAggregatesFilter<"PropertyTypeMaster"> | string
    name?: StringWithAggregatesFilter<"PropertyTypeMaster"> | string
    description?: StringNullableWithAggregatesFilter<"PropertyTypeMaster"> | string | null
    displayOrder?: IntWithAggregatesFilter<"PropertyTypeMaster"> | number
    isActive?: BoolWithAggregatesFilter<"PropertyTypeMaster"> | boolean
  }

  export type PropertyCategoryMasterWhereInput = {
    AND?: PropertyCategoryMasterWhereInput | PropertyCategoryMasterWhereInput[]
    OR?: PropertyCategoryMasterWhereInput[]
    NOT?: PropertyCategoryMasterWhereInput | PropertyCategoryMasterWhereInput[]
    id?: UuidFilter<"PropertyCategoryMaster"> | string
    code?: StringFilter<"PropertyCategoryMaster"> | string
    name?: StringFilter<"PropertyCategoryMaster"> | string
    displayOrder?: IntFilter<"PropertyCategoryMaster"> | number
    isActive?: BoolFilter<"PropertyCategoryMaster"> | boolean
    properties?: PropertyListRelationFilter
  }

  export type PropertyCategoryMasterOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    properties?: PropertyOrderByRelationAggregateInput
  }

  export type PropertyCategoryMasterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PropertyCategoryMasterWhereInput | PropertyCategoryMasterWhereInput[]
    OR?: PropertyCategoryMasterWhereInput[]
    NOT?: PropertyCategoryMasterWhereInput | PropertyCategoryMasterWhereInput[]
    name?: StringFilter<"PropertyCategoryMaster"> | string
    displayOrder?: IntFilter<"PropertyCategoryMaster"> | number
    isActive?: BoolFilter<"PropertyCategoryMaster"> | boolean
    properties?: PropertyListRelationFilter
  }, "id" | "code">

  export type PropertyCategoryMasterOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    _count?: PropertyCategoryMasterCountOrderByAggregateInput
    _avg?: PropertyCategoryMasterAvgOrderByAggregateInput
    _max?: PropertyCategoryMasterMaxOrderByAggregateInput
    _min?: PropertyCategoryMasterMinOrderByAggregateInput
    _sum?: PropertyCategoryMasterSumOrderByAggregateInput
  }

  export type PropertyCategoryMasterScalarWhereWithAggregatesInput = {
    AND?: PropertyCategoryMasterScalarWhereWithAggregatesInput | PropertyCategoryMasterScalarWhereWithAggregatesInput[]
    OR?: PropertyCategoryMasterScalarWhereWithAggregatesInput[]
    NOT?: PropertyCategoryMasterScalarWhereWithAggregatesInput | PropertyCategoryMasterScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PropertyCategoryMaster"> | string
    code?: StringWithAggregatesFilter<"PropertyCategoryMaster"> | string
    name?: StringWithAggregatesFilter<"PropertyCategoryMaster"> | string
    displayOrder?: IntWithAggregatesFilter<"PropertyCategoryMaster"> | number
    isActive?: BoolWithAggregatesFilter<"PropertyCategoryMaster"> | boolean
  }

  export type FloorPlanMasterWhereInput = {
    AND?: FloorPlanMasterWhereInput | FloorPlanMasterWhereInput[]
    OR?: FloorPlanMasterWhereInput[]
    NOT?: FloorPlanMasterWhereInput | FloorPlanMasterWhereInput[]
    id?: UuidFilter<"FloorPlanMaster"> | string
    code?: StringFilter<"FloorPlanMaster"> | string
    name?: StringFilter<"FloorPlanMaster"> | string
    roomCount?: IntNullableFilter<"FloorPlanMaster"> | number | null
    displayOrder?: IntFilter<"FloorPlanMaster"> | number
    isActive?: BoolFilter<"FloorPlanMaster"> | boolean
    properties?: PropertyListRelationFilter
  }

  export type FloorPlanMasterOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    roomCount?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    properties?: PropertyOrderByRelationAggregateInput
  }

  export type FloorPlanMasterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: FloorPlanMasterWhereInput | FloorPlanMasterWhereInput[]
    OR?: FloorPlanMasterWhereInput[]
    NOT?: FloorPlanMasterWhereInput | FloorPlanMasterWhereInput[]
    name?: StringFilter<"FloorPlanMaster"> | string
    roomCount?: IntNullableFilter<"FloorPlanMaster"> | number | null
    displayOrder?: IntFilter<"FloorPlanMaster"> | number
    isActive?: BoolFilter<"FloorPlanMaster"> | boolean
    properties?: PropertyListRelationFilter
  }, "id" | "code">

  export type FloorPlanMasterOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    roomCount?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    _count?: FloorPlanMasterCountOrderByAggregateInput
    _avg?: FloorPlanMasterAvgOrderByAggregateInput
    _max?: FloorPlanMasterMaxOrderByAggregateInput
    _min?: FloorPlanMasterMinOrderByAggregateInput
    _sum?: FloorPlanMasterSumOrderByAggregateInput
  }

  export type FloorPlanMasterScalarWhereWithAggregatesInput = {
    AND?: FloorPlanMasterScalarWhereWithAggregatesInput | FloorPlanMasterScalarWhereWithAggregatesInput[]
    OR?: FloorPlanMasterScalarWhereWithAggregatesInput[]
    NOT?: FloorPlanMasterScalarWhereWithAggregatesInput | FloorPlanMasterScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FloorPlanMaster"> | string
    code?: StringWithAggregatesFilter<"FloorPlanMaster"> | string
    name?: StringWithAggregatesFilter<"FloorPlanMaster"> | string
    roomCount?: IntNullableWithAggregatesFilter<"FloorPlanMaster"> | number | null
    displayOrder?: IntWithAggregatesFilter<"FloorPlanMaster"> | number
    isActive?: BoolWithAggregatesFilter<"FloorPlanMaster"> | boolean
  }

  export type RouteMasterWhereInput = {
    AND?: RouteMasterWhereInput | RouteMasterWhereInput[]
    OR?: RouteMasterWhereInput[]
    NOT?: RouteMasterWhereInput | RouteMasterWhereInput[]
    id?: UuidFilter<"RouteMaster"> | string
    code?: StringFilter<"RouteMaster"> | string
    name?: StringFilter<"RouteMaster"> | string
    companyName?: StringNullableFilter<"RouteMaster"> | string | null
    lineColor?: StringNullableFilter<"RouteMaster"> | string | null
    displayOrder?: IntFilter<"RouteMaster"> | number
    isActive?: BoolFilter<"RouteMaster"> | boolean
    stations?: StationListRelationFilter
  }

  export type RouteMasterOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    companyName?: SortOrderInput | SortOrder
    lineColor?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    stations?: StationOrderByRelationAggregateInput
  }

  export type RouteMasterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: RouteMasterWhereInput | RouteMasterWhereInput[]
    OR?: RouteMasterWhereInput[]
    NOT?: RouteMasterWhereInput | RouteMasterWhereInput[]
    name?: StringFilter<"RouteMaster"> | string
    companyName?: StringNullableFilter<"RouteMaster"> | string | null
    lineColor?: StringNullableFilter<"RouteMaster"> | string | null
    displayOrder?: IntFilter<"RouteMaster"> | number
    isActive?: BoolFilter<"RouteMaster"> | boolean
    stations?: StationListRelationFilter
  }, "id" | "code">

  export type RouteMasterOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    companyName?: SortOrderInput | SortOrder
    lineColor?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    _count?: RouteMasterCountOrderByAggregateInput
    _avg?: RouteMasterAvgOrderByAggregateInput
    _max?: RouteMasterMaxOrderByAggregateInput
    _min?: RouteMasterMinOrderByAggregateInput
    _sum?: RouteMasterSumOrderByAggregateInput
  }

  export type RouteMasterScalarWhereWithAggregatesInput = {
    AND?: RouteMasterScalarWhereWithAggregatesInput | RouteMasterScalarWhereWithAggregatesInput[]
    OR?: RouteMasterScalarWhereWithAggregatesInput[]
    NOT?: RouteMasterScalarWhereWithAggregatesInput | RouteMasterScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RouteMaster"> | string
    code?: StringWithAggregatesFilter<"RouteMaster"> | string
    name?: StringWithAggregatesFilter<"RouteMaster"> | string
    companyName?: StringNullableWithAggregatesFilter<"RouteMaster"> | string | null
    lineColor?: StringNullableWithAggregatesFilter<"RouteMaster"> | string | null
    displayOrder?: IntWithAggregatesFilter<"RouteMaster"> | number
    isActive?: BoolWithAggregatesFilter<"RouteMaster"> | boolean
  }

  export type StationWhereInput = {
    AND?: StationWhereInput | StationWhereInput[]
    OR?: StationWhereInput[]
    NOT?: StationWhereInput | StationWhereInput[]
    id?: UuidFilter<"Station"> | string
    code?: StringFilter<"Station"> | string
    name?: StringFilter<"Station"> | string
    nameKana?: StringNullableFilter<"Station"> | string | null
    routeId?: UuidNullableFilter<"Station"> | string | null
    prefecture?: StringNullableFilter<"Station"> | string | null
    city?: StringNullableFilter<"Station"> | string | null
    latitude?: DecimalNullableFilter<"Station"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Station"> | Decimal | DecimalJsLike | number | string | null
    displayOrder?: IntFilter<"Station"> | number
    isActive?: BoolFilter<"Station"> | boolean
    route?: XOR<RouteMasterNullableScalarRelationFilter, RouteMasterWhereInput> | null
    propertyStations?: PropertyStationListRelationFilter
  }

  export type StationOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameKana?: SortOrderInput | SortOrder
    routeId?: SortOrderInput | SortOrder
    prefecture?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    route?: RouteMasterOrderByWithRelationInput
    propertyStations?: PropertyStationOrderByRelationAggregateInput
  }

  export type StationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    name_routeId?: StationNameRouteIdCompoundUniqueInput
    AND?: StationWhereInput | StationWhereInput[]
    OR?: StationWhereInput[]
    NOT?: StationWhereInput | StationWhereInput[]
    name?: StringFilter<"Station"> | string
    nameKana?: StringNullableFilter<"Station"> | string | null
    routeId?: UuidNullableFilter<"Station"> | string | null
    prefecture?: StringNullableFilter<"Station"> | string | null
    city?: StringNullableFilter<"Station"> | string | null
    latitude?: DecimalNullableFilter<"Station"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Station"> | Decimal | DecimalJsLike | number | string | null
    displayOrder?: IntFilter<"Station"> | number
    isActive?: BoolFilter<"Station"> | boolean
    route?: XOR<RouteMasterNullableScalarRelationFilter, RouteMasterWhereInput> | null
    propertyStations?: PropertyStationListRelationFilter
  }, "id" | "code" | "name_routeId">

  export type StationOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameKana?: SortOrderInput | SortOrder
    routeId?: SortOrderInput | SortOrder
    prefecture?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    _count?: StationCountOrderByAggregateInput
    _avg?: StationAvgOrderByAggregateInput
    _max?: StationMaxOrderByAggregateInput
    _min?: StationMinOrderByAggregateInput
    _sum?: StationSumOrderByAggregateInput
  }

  export type StationScalarWhereWithAggregatesInput = {
    AND?: StationScalarWhereWithAggregatesInput | StationScalarWhereWithAggregatesInput[]
    OR?: StationScalarWhereWithAggregatesInput[]
    NOT?: StationScalarWhereWithAggregatesInput | StationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Station"> | string
    code?: StringWithAggregatesFilter<"Station"> | string
    name?: StringWithAggregatesFilter<"Station"> | string
    nameKana?: StringNullableWithAggregatesFilter<"Station"> | string | null
    routeId?: UuidNullableWithAggregatesFilter<"Station"> | string | null
    prefecture?: StringNullableWithAggregatesFilter<"Station"> | string | null
    city?: StringNullableWithAggregatesFilter<"Station"> | string | null
    latitude?: DecimalNullableWithAggregatesFilter<"Station"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Station"> | Decimal | DecimalJsLike | number | string | null
    displayOrder?: IntWithAggregatesFilter<"Station"> | number
    isActive?: BoolWithAggregatesFilter<"Station"> | boolean
  }

  export type QuestionCategoryWhereInput = {
    AND?: QuestionCategoryWhereInput | QuestionCategoryWhereInput[]
    OR?: QuestionCategoryWhereInput[]
    NOT?: QuestionCategoryWhereInput | QuestionCategoryWhereInput[]
    id?: UuidFilter<"QuestionCategory"> | string
    code?: StringFilter<"QuestionCategory"> | string
    name?: StringFilter<"QuestionCategory"> | string
    description?: StringNullableFilter<"QuestionCategory"> | string | null
    displayOrder?: IntFilter<"QuestionCategory"> | number
    isActive?: BoolFilter<"QuestionCategory"> | boolean
    questions?: QuestionListRelationFilter
  }

  export type QuestionCategoryOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    questions?: QuestionOrderByRelationAggregateInput
  }

  export type QuestionCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: QuestionCategoryWhereInput | QuestionCategoryWhereInput[]
    OR?: QuestionCategoryWhereInput[]
    NOT?: QuestionCategoryWhereInput | QuestionCategoryWhereInput[]
    name?: StringFilter<"QuestionCategory"> | string
    description?: StringNullableFilter<"QuestionCategory"> | string | null
    displayOrder?: IntFilter<"QuestionCategory"> | number
    isActive?: BoolFilter<"QuestionCategory"> | boolean
    questions?: QuestionListRelationFilter
  }, "id" | "code">

  export type QuestionCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    _count?: QuestionCategoryCountOrderByAggregateInput
    _avg?: QuestionCategoryAvgOrderByAggregateInput
    _max?: QuestionCategoryMaxOrderByAggregateInput
    _min?: QuestionCategoryMinOrderByAggregateInput
    _sum?: QuestionCategorySumOrderByAggregateInput
  }

  export type QuestionCategoryScalarWhereWithAggregatesInput = {
    AND?: QuestionCategoryScalarWhereWithAggregatesInput | QuestionCategoryScalarWhereWithAggregatesInput[]
    OR?: QuestionCategoryScalarWhereWithAggregatesInput[]
    NOT?: QuestionCategoryScalarWhereWithAggregatesInput | QuestionCategoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"QuestionCategory"> | string
    code?: StringWithAggregatesFilter<"QuestionCategory"> | string
    name?: StringWithAggregatesFilter<"QuestionCategory"> | string
    description?: StringNullableWithAggregatesFilter<"QuestionCategory"> | string | null
    displayOrder?: IntWithAggregatesFilter<"QuestionCategory"> | number
    isActive?: BoolWithAggregatesFilter<"QuestionCategory"> | boolean
  }

  export type MailWhereInput = {
    AND?: MailWhereInput | MailWhereInput[]
    OR?: MailWhereInput[]
    NOT?: MailWhereInput | MailWhereInput[]
    id?: UuidFilter<"Mail"> | string
    fromEmail?: StringFilter<"Mail"> | string
    fromName?: StringNullableFilter<"Mail"> | string | null
    toEmail?: StringFilter<"Mail"> | string
    toName?: StringNullableFilter<"Mail"> | string | null
    ccEmail?: StringNullableListFilter<"Mail">
    bccEmail?: StringNullableListFilter<"Mail">
    subject?: StringFilter<"Mail"> | string
    bodyText?: StringFilter<"Mail"> | string
    bodyHtml?: StringNullableFilter<"Mail"> | string | null
    status?: EnumMailStatusFilter<"Mail"> | $Enums.MailStatus
    mailType?: EnumMailTypeFilter<"Mail"> | $Enums.MailType
    templateCode?: StringNullableFilter<"Mail"> | string | null
    templateVariables?: JsonNullableFilter<"Mail">
    errorMessage?: StringNullableFilter<"Mail"> | string | null
    userId?: UuidNullableFilter<"Mail"> | string | null
    retryCount?: IntFilter<"Mail"> | number
    scheduledAt?: DateTimeNullableFilter<"Mail"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Mail"> | Date | string | null
    createdAt?: DateTimeFilter<"Mail"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type MailOrderByWithRelationInput = {
    id?: SortOrder
    fromEmail?: SortOrder
    fromName?: SortOrderInput | SortOrder
    toEmail?: SortOrder
    toName?: SortOrderInput | SortOrder
    ccEmail?: SortOrder
    bccEmail?: SortOrder
    subject?: SortOrder
    bodyText?: SortOrder
    bodyHtml?: SortOrderInput | SortOrder
    status?: SortOrder
    mailType?: SortOrder
    templateCode?: SortOrderInput | SortOrder
    templateVariables?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MailWhereInput | MailWhereInput[]
    OR?: MailWhereInput[]
    NOT?: MailWhereInput | MailWhereInput[]
    fromEmail?: StringFilter<"Mail"> | string
    fromName?: StringNullableFilter<"Mail"> | string | null
    toEmail?: StringFilter<"Mail"> | string
    toName?: StringNullableFilter<"Mail"> | string | null
    ccEmail?: StringNullableListFilter<"Mail">
    bccEmail?: StringNullableListFilter<"Mail">
    subject?: StringFilter<"Mail"> | string
    bodyText?: StringFilter<"Mail"> | string
    bodyHtml?: StringNullableFilter<"Mail"> | string | null
    status?: EnumMailStatusFilter<"Mail"> | $Enums.MailStatus
    mailType?: EnumMailTypeFilter<"Mail"> | $Enums.MailType
    templateCode?: StringNullableFilter<"Mail"> | string | null
    templateVariables?: JsonNullableFilter<"Mail">
    errorMessage?: StringNullableFilter<"Mail"> | string | null
    userId?: UuidNullableFilter<"Mail"> | string | null
    retryCount?: IntFilter<"Mail"> | number
    scheduledAt?: DateTimeNullableFilter<"Mail"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Mail"> | Date | string | null
    createdAt?: DateTimeFilter<"Mail"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type MailOrderByWithAggregationInput = {
    id?: SortOrder
    fromEmail?: SortOrder
    fromName?: SortOrderInput | SortOrder
    toEmail?: SortOrder
    toName?: SortOrderInput | SortOrder
    ccEmail?: SortOrder
    bccEmail?: SortOrder
    subject?: SortOrder
    bodyText?: SortOrder
    bodyHtml?: SortOrderInput | SortOrder
    status?: SortOrder
    mailType?: SortOrder
    templateCode?: SortOrderInput | SortOrder
    templateVariables?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MailCountOrderByAggregateInput
    _avg?: MailAvgOrderByAggregateInput
    _max?: MailMaxOrderByAggregateInput
    _min?: MailMinOrderByAggregateInput
    _sum?: MailSumOrderByAggregateInput
  }

  export type MailScalarWhereWithAggregatesInput = {
    AND?: MailScalarWhereWithAggregatesInput | MailScalarWhereWithAggregatesInput[]
    OR?: MailScalarWhereWithAggregatesInput[]
    NOT?: MailScalarWhereWithAggregatesInput | MailScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Mail"> | string
    fromEmail?: StringWithAggregatesFilter<"Mail"> | string
    fromName?: StringNullableWithAggregatesFilter<"Mail"> | string | null
    toEmail?: StringWithAggregatesFilter<"Mail"> | string
    toName?: StringNullableWithAggregatesFilter<"Mail"> | string | null
    ccEmail?: StringNullableListFilter<"Mail">
    bccEmail?: StringNullableListFilter<"Mail">
    subject?: StringWithAggregatesFilter<"Mail"> | string
    bodyText?: StringWithAggregatesFilter<"Mail"> | string
    bodyHtml?: StringNullableWithAggregatesFilter<"Mail"> | string | null
    status?: EnumMailStatusWithAggregatesFilter<"Mail"> | $Enums.MailStatus
    mailType?: EnumMailTypeWithAggregatesFilter<"Mail"> | $Enums.MailType
    templateCode?: StringNullableWithAggregatesFilter<"Mail"> | string | null
    templateVariables?: JsonNullableWithAggregatesFilter<"Mail">
    errorMessage?: StringNullableWithAggregatesFilter<"Mail"> | string | null
    userId?: UuidNullableWithAggregatesFilter<"Mail"> | string | null
    retryCount?: IntWithAggregatesFilter<"Mail"> | number
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"Mail"> | Date | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"Mail"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Mail"> | Date | string
  }

  export type FileBoxWhereInput = {
    AND?: FileBoxWhereInput | FileBoxWhereInput[]
    OR?: FileBoxWhereInput[]
    NOT?: FileBoxWhereInput | FileBoxWhereInput[]
    id?: UuidFilter<"FileBox"> | string
    bucketName?: StringFilter<"FileBox"> | string
    storagePath?: StringFilter<"FileBox"> | string
    fileName?: StringFilter<"FileBox"> | string
    originalName?: StringFilter<"FileBox"> | string
    publicUrl?: StringNullableFilter<"FileBox"> | string | null
    mimeType?: StringFilter<"FileBox"> | string
    fileSize?: BigIntFilter<"FileBox"> | bigint | number
    category?: StringNullableFilter<"FileBox"> | string | null
    metadata?: JsonNullableFilter<"FileBox">
    userId?: UuidNullableFilter<"FileBox"> | string | null
    isPublic?: BoolFilter<"FileBox"> | boolean
    createdAt?: DateTimeFilter<"FileBox"> | Date | string
    updatedAt?: DateTimeFilter<"FileBox"> | Date | string
    deletedAt?: DateTimeNullableFilter<"FileBox"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    propertyImages?: PropertyImageListRelationFilter
  }

  export type FileBoxOrderByWithRelationInput = {
    id?: SortOrder
    bucketName?: SortOrder
    storagePath?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    publicUrl?: SortOrderInput | SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    category?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    propertyImages?: PropertyImageOrderByRelationAggregateInput
  }

  export type FileBoxWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileBoxWhereInput | FileBoxWhereInput[]
    OR?: FileBoxWhereInput[]
    NOT?: FileBoxWhereInput | FileBoxWhereInput[]
    bucketName?: StringFilter<"FileBox"> | string
    storagePath?: StringFilter<"FileBox"> | string
    fileName?: StringFilter<"FileBox"> | string
    originalName?: StringFilter<"FileBox"> | string
    publicUrl?: StringNullableFilter<"FileBox"> | string | null
    mimeType?: StringFilter<"FileBox"> | string
    fileSize?: BigIntFilter<"FileBox"> | bigint | number
    category?: StringNullableFilter<"FileBox"> | string | null
    metadata?: JsonNullableFilter<"FileBox">
    userId?: UuidNullableFilter<"FileBox"> | string | null
    isPublic?: BoolFilter<"FileBox"> | boolean
    createdAt?: DateTimeFilter<"FileBox"> | Date | string
    updatedAt?: DateTimeFilter<"FileBox"> | Date | string
    deletedAt?: DateTimeNullableFilter<"FileBox"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    propertyImages?: PropertyImageListRelationFilter
  }, "id">

  export type FileBoxOrderByWithAggregationInput = {
    id?: SortOrder
    bucketName?: SortOrder
    storagePath?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    publicUrl?: SortOrderInput | SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    category?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: FileBoxCountOrderByAggregateInput
    _avg?: FileBoxAvgOrderByAggregateInput
    _max?: FileBoxMaxOrderByAggregateInput
    _min?: FileBoxMinOrderByAggregateInput
    _sum?: FileBoxSumOrderByAggregateInput
  }

  export type FileBoxScalarWhereWithAggregatesInput = {
    AND?: FileBoxScalarWhereWithAggregatesInput | FileBoxScalarWhereWithAggregatesInput[]
    OR?: FileBoxScalarWhereWithAggregatesInput[]
    NOT?: FileBoxScalarWhereWithAggregatesInput | FileBoxScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FileBox"> | string
    bucketName?: StringWithAggregatesFilter<"FileBox"> | string
    storagePath?: StringWithAggregatesFilter<"FileBox"> | string
    fileName?: StringWithAggregatesFilter<"FileBox"> | string
    originalName?: StringWithAggregatesFilter<"FileBox"> | string
    publicUrl?: StringNullableWithAggregatesFilter<"FileBox"> | string | null
    mimeType?: StringWithAggregatesFilter<"FileBox"> | string
    fileSize?: BigIntWithAggregatesFilter<"FileBox"> | bigint | number
    category?: StringNullableWithAggregatesFilter<"FileBox"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"FileBox">
    userId?: UuidNullableWithAggregatesFilter<"FileBox"> | string | null
    isPublic?: BoolWithAggregatesFilter<"FileBox"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FileBox"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FileBox"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"FileBox"> | Date | string | null
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    id?: UuidFilter<"SystemSetting"> | string
    key?: StringFilter<"SystemSetting"> | string
    value?: JsonFilter<"SystemSetting">
    valueType?: StringFilter<"SystemSetting"> | string
    category?: StringNullableFilter<"SystemSetting"> | string | null
    description?: StringNullableFilter<"SystemSetting"> | string | null
    isPublic?: BoolFilter<"SystemSetting"> | boolean
    updatedById?: UuidNullableFilter<"SystemSetting"> | string | null
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SystemSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    valueType?: SortOrder
    category?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: UserOrderByWithRelationInput
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    value?: JsonFilter<"SystemSetting">
    valueType?: StringFilter<"SystemSetting"> | string
    category?: StringNullableFilter<"SystemSetting"> | string | null
    description?: StringNullableFilter<"SystemSetting"> | string | null
    isPublic?: BoolFilter<"SystemSetting"> | boolean
    updatedById?: UuidNullableFilter<"SystemSetting"> | string | null
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "key">

  export type SystemSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    valueType?: SortOrder
    category?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SystemSetting"> | string
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: JsonWithAggregatesFilter<"SystemSetting">
    valueType?: StringWithAggregatesFilter<"SystemSetting"> | string
    category?: StringNullableWithAggregatesFilter<"SystemSetting"> | string | null
    description?: StringNullableWithAggregatesFilter<"SystemSetting"> | string | null
    isPublic?: BoolWithAggregatesFilter<"SystemSetting"> | boolean
    updatedById?: UuidNullableWithAggregatesFilter<"SystemSetting"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: UuidFilter<"AuditLog"> | string
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    changedFields?: StringNullableListFilter<"AuditLog">
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    userEmail?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    sessionId?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    changedFields?: SortOrder
    userId?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: UuidFilter<"AuditLog"> | string
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    changedFields?: StringNullableListFilter<"AuditLog">
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    userEmail?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    sessionId?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    changedFields?: SortOrder
    userId?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AuditLog"> | string
    tableName?: StringWithAggregatesFilter<"AuditLog"> | string
    recordId?: UuidWithAggregatesFilter<"AuditLog"> | string
    action?: EnumAuditActionWithAggregatesFilter<"AuditLog"> | $Enums.AuditAction
    oldData?: JsonNullableWithAggregatesFilter<"AuditLog">
    newData?: JsonNullableWithAggregatesFilter<"AuditLog">
    changedFields?: StringNullableListFilter<"AuditLog">
    userId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    userEmail?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: UuidFilter<"Notification"> | string
    userId?: UuidFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    linkUrl?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    linkUrl?: SortOrderInput | SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: UuidFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    linkUrl?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    linkUrl?: SortOrderInput | SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Notification"> | string
    userId?: UuidWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    linkUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutAuthorInput
    answers?: AnswerCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentCreateNestedManyWithoutUserInput
    mails?: MailCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutAuthorInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentUncheckedCreateNestedManyWithoutUserInput
    mails?: MailUncheckedCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUpdateManyWithoutUserNestedInput
    mails?: MailUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUncheckedUpdateManyWithoutUserNestedInput
    mails?: MailUncheckedUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    createdAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    createdAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    createdAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserRolesInput
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    id?: string
    userId: string
    roleId: string
    createdAt?: Date | string
  }

  export type UserRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyInput = {
    id?: string
    userId: string
    roleId: string
    createdAt?: Date | string
  }

  export type UserRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    companyName: string
    companyNameKana?: string | null
    representativeName: string
    postalCode: string
    prefecture: string
    city: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    phone: string
    fax?: string | null
    website?: string | null
    licenseNumber: string
    associationMembership?: string | null
    accountType?: $Enums.AccountType
    status?: $Enums.CompanyStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    branches?: BranchCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    companyName: string
    companyNameKana?: string | null
    representativeName: string
    postalCode: string
    prefecture: string
    city: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    phone: string
    fax?: string | null
    website?: string | null
    licenseNumber: string
    associationMembership?: string | null
    accountType?: $Enums.AccountType
    status?: $Enums.CompanyStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    representativeName?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    phone?: StringFieldUpdateOperationsInput | string
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    associationMembership?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: BranchUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    representativeName?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    phone?: StringFieldUpdateOperationsInput | string
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    associationMembership?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    companyName: string
    companyNameKana?: string | null
    representativeName: string
    postalCode: string
    prefecture: string
    city: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    phone: string
    fax?: string | null
    website?: string | null
    licenseNumber: string
    associationMembership?: string | null
    accountType?: $Enums.AccountType
    status?: $Enums.CompanyStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    representativeName?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    phone?: StringFieldUpdateOperationsInput | string
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    associationMembership?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    representativeName?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    phone?: StringFieldUpdateOperationsInput | string
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    associationMembership?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BranchCreateInput = {
    id?: string
    branchName: string
    postalCode: string
    prefecture: string
    city: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    phone: string
    fax?: string | null
    businessHours?: string | null
    isHeadquarters?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutBranchesInput
    agents?: AgentCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateInput = {
    id?: string
    branchName: string
    postalCode: string
    prefecture: string
    city: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    phone: string
    fax?: string | null
    businessHours?: string | null
    isHeadquarters?: boolean
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    agents?: AgentUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    phone?: StringFieldUpdateOperationsInput | string
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    businessHours?: NullableStringFieldUpdateOperationsInput | string | null
    isHeadquarters?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
    agents?: AgentUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    phone?: StringFieldUpdateOperationsInput | string
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    businessHours?: NullableStringFieldUpdateOperationsInput | string | null
    isHeadquarters?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agents?: AgentUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateManyInput = {
    id?: string
    branchName: string
    postalCode: string
    prefecture: string
    city: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    phone: string
    fax?: string | null
    businessHours?: string | null
    isHeadquarters?: boolean
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BranchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    phone?: StringFieldUpdateOperationsInput | string
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    businessHours?: NullableStringFieldUpdateOperationsInput | string | null
    isHeadquarters?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    phone?: StringFieldUpdateOperationsInput | string
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    businessHours?: NullableStringFieldUpdateOperationsInput | string | null
    isHeadquarters?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgentCreateInput = {
    id?: string
    position?: string | null
    department?: string | null
    licenseNumber?: string | null
    licenseExpireDate?: Date | string | null
    goodCount?: number
    responseRate?: Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAgentInput
    branch: BranchCreateNestedOneWithoutAgentsInput
    properties?: PropertyCreateNestedManyWithoutAgentInput
    assignedInquiries?: InquiryCreateNestedManyWithoutAssignedAgentInput
    answers?: AnswerCreateNestedManyWithoutAgentInput
    bulkAssessmentResponses?: BulkAssessmentResponseCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateInput = {
    id?: string
    position?: string | null
    department?: string | null
    licenseNumber?: string | null
    licenseExpireDate?: Date | string | null
    goodCount?: number
    responseRate?: Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: number | null
    userId: string
    branchId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    properties?: PropertyUncheckedCreateNestedManyWithoutAgentInput
    assignedInquiries?: InquiryUncheckedCreateNestedManyWithoutAssignedAgentInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAgentInput
    bulkAssessmentResponses?: BulkAssessmentResponseUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goodCount?: IntFieldUpdateOperationsInput | number
    responseRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    branch?: BranchUpdateOneRequiredWithoutAgentsNestedInput
    properties?: PropertyUpdateManyWithoutAgentNestedInput
    assignedInquiries?: InquiryUpdateManyWithoutAssignedAgentNestedInput
    answers?: AnswerUpdateManyWithoutAgentNestedInput
    bulkAssessmentResponses?: BulkAssessmentResponseUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goodCount?: IntFieldUpdateOperationsInput | number
    responseRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    properties?: PropertyUncheckedUpdateManyWithoutAgentNestedInput
    assignedInquiries?: InquiryUncheckedUpdateManyWithoutAssignedAgentNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAgentNestedInput
    bulkAssessmentResponses?: BulkAssessmentResponseUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateManyInput = {
    id?: string
    position?: string | null
    department?: string | null
    licenseNumber?: string | null
    licenseExpireDate?: Date | string | null
    goodCount?: number
    responseRate?: Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: number | null
    userId: string
    branchId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goodCount?: IntFieldUpdateOperationsInput | number
    responseRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goodCount?: IntFieldUpdateOperationsInput | number
    responseRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyCreateInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutPropertiesInput
    propertyCategory?: PropertyCategoryMasterCreateNestedOneWithoutPropertiesInput
    area?: AreaMasterCreateNestedOneWithoutPropertiesInput
    layoutType?: FloorPlanMasterCreateNestedOneWithoutPropertiesInput
    agent?: AgentCreateNestedOneWithoutPropertiesInput
    user: UserCreateNestedOneWithoutPropertiesInput
    publication?: PropertyPublicationCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryCreateNestedManyWithoutPropertyInput
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
    publication?: PropertyPublicationUncheckedCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutPropertyInput
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyType?: PropertyTypeMasterUpdateOneWithoutPropertiesNestedInput
    propertyCategory?: PropertyCategoryMasterUpdateOneWithoutPropertiesNestedInput
    area?: AreaMasterUpdateOneWithoutPropertiesNestedInput
    layoutType?: FloorPlanMasterUpdateOneWithoutPropertiesNestedInput
    agent?: AgentUpdateOneWithoutPropertiesNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    publication?: PropertyPublicationUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    publication?: PropertyPublicationUncheckedUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateManyInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
  }

  export type PropertyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyPublicationCreateInput = {
    id?: string
    status?: $Enums.PublicationStatus
    scope?: $Enums.PublicScope
    featured?: boolean
    featuredOrder?: number | null
    publishedAt?: Date | string | null
    unpublishedAt?: Date | string | null
    soldAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutPublicationInput
  }

  export type PropertyPublicationUncheckedCreateInput = {
    id?: string
    propertyId: string
    status?: $Enums.PublicationStatus
    scope?: $Enums.PublicScope
    featured?: boolean
    featuredOrder?: number | null
    publishedAt?: Date | string | null
    unpublishedAt?: Date | string | null
    soldAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyPublicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    scope?: EnumPublicScopeFieldUpdateOperationsInput | $Enums.PublicScope
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredOrder?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unpublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soldAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutPublicationNestedInput
  }

  export type PropertyPublicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    scope?: EnumPublicScopeFieldUpdateOperationsInput | $Enums.PublicScope
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredOrder?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unpublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soldAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPublicationCreateManyInput = {
    id?: string
    propertyId: string
    status?: $Enums.PublicationStatus
    scope?: $Enums.PublicScope
    featured?: boolean
    featuredOrder?: number | null
    publishedAt?: Date | string | null
    unpublishedAt?: Date | string | null
    soldAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyPublicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    scope?: EnumPublicScopeFieldUpdateOperationsInput | $Enums.PublicScope
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredOrder?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unpublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soldAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPublicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    scope?: EnumPublicScopeFieldUpdateOperationsInput | $Enums.PublicScope
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredOrder?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unpublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soldAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPriceHistoryCreateInput = {
    id?: string
    previousPrice?: bigint | number | null
    newPrice: bigint | number
    changePercent?: Decimal | DecimalJsLike | number | string | null
    changeReason?: string | null
    createdAt?: Date | string
    property: PropertyCreateNestedOneWithoutPriceHistoriesInput
    changedBy?: UserCreateNestedOneWithoutPriceHistoryChangesInput
  }

  export type PropertyPriceHistoryUncheckedCreateInput = {
    id?: string
    propertyId: string
    previousPrice?: bigint | number | null
    newPrice: bigint | number
    changePercent?: Decimal | DecimalJsLike | number | string | null
    changeReason?: string | null
    changedById?: string | null
    createdAt?: Date | string
  }

  export type PropertyPriceHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    changePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutPriceHistoriesNestedInput
    changedBy?: UserUpdateOneWithoutPriceHistoryChangesNestedInput
  }

  export type PropertyPriceHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    previousPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    changePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPriceHistoryCreateManyInput = {
    id?: string
    propertyId: string
    previousPrice?: bigint | number | null
    newPrice: bigint | number
    changePercent?: Decimal | DecimalJsLike | number | string | null
    changeReason?: string | null
    changedById?: string | null
    createdAt?: Date | string
  }

  export type PropertyPriceHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    changePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPriceHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    previousPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    changePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyStatusHistoryCreateInput = {
    id?: string
    previousStatus?: string | null
    newStatus: string
    changeReason?: string | null
    createdAt?: Date | string
    property: PropertyCreateNestedOneWithoutStatusHistoriesInput
    changedBy?: UserCreateNestedOneWithoutStatusHistoryChangesInput
  }

  export type PropertyStatusHistoryUncheckedCreateInput = {
    id?: string
    propertyId: string
    previousStatus?: string | null
    newStatus: string
    changeReason?: string | null
    changedById?: string | null
    createdAt?: Date | string
  }

  export type PropertyStatusHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutStatusHistoriesNestedInput
    changedBy?: UserUpdateOneWithoutStatusHistoryChangesNestedInput
  }

  export type PropertyStatusHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyStatusHistoryCreateManyInput = {
    id?: string
    propertyId: string
    previousStatus?: string | null
    newStatus: string
    changeReason?: string | null
    changedById?: string | null
    createdAt?: Date | string
  }

  export type PropertyStatusHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyStatusHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyImageCreateInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    imageType?: $Enums.ImageType
    displayOrder?: number
    isMain?: boolean
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    property: PropertyCreateNestedOneWithoutImagesInput
    fileBox?: FileBoxCreateNestedOneWithoutPropertyImagesInput
  }

  export type PropertyImageUncheckedCreateInput = {
    id?: string
    propertyId: string
    fileBoxId?: string | null
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    imageType?: $Enums.ImageType
    displayOrder?: number
    isMain?: boolean
    width?: number | null
    height?: number | null
    createdAt?: Date | string
  }

  export type PropertyImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: EnumImageTypeFieldUpdateOperationsInput | $Enums.ImageType
    displayOrder?: IntFieldUpdateOperationsInput | number
    isMain?: BoolFieldUpdateOperationsInput | boolean
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutImagesNestedInput
    fileBox?: FileBoxUpdateOneWithoutPropertyImagesNestedInput
  }

  export type PropertyImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    fileBoxId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: EnumImageTypeFieldUpdateOperationsInput | $Enums.ImageType
    displayOrder?: IntFieldUpdateOperationsInput | number
    isMain?: BoolFieldUpdateOperationsInput | boolean
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyImageCreateManyInput = {
    id?: string
    propertyId: string
    fileBoxId?: string | null
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    imageType?: $Enums.ImageType
    displayOrder?: number
    isMain?: boolean
    width?: number | null
    height?: number | null
    createdAt?: Date | string
  }

  export type PropertyImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: EnumImageTypeFieldUpdateOperationsInput | $Enums.ImageType
    displayOrder?: IntFieldUpdateOperationsInput | number
    isMain?: BoolFieldUpdateOperationsInput | boolean
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    fileBoxId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: EnumImageTypeFieldUpdateOperationsInput | $Enums.ImageType
    displayOrder?: IntFieldUpdateOperationsInput | number
    isMain?: BoolFieldUpdateOperationsInput | boolean
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyFeatureCreateInput = {
    id?: string
    property: PropertyCreateNestedOneWithoutFeaturesInput
    feature: FeatureMasterCreateNestedOneWithoutPropertiesInput
  }

  export type PropertyFeatureUncheckedCreateInput = {
    id?: string
    propertyId: string
    featureId: string
  }

  export type PropertyFeatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    property?: PropertyUpdateOneRequiredWithoutFeaturesNestedInput
    feature?: FeatureMasterUpdateOneRequiredWithoutPropertiesNestedInput
  }

  export type PropertyFeatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    featureId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyFeatureCreateManyInput = {
    id?: string
    propertyId: string
    featureId: string
  }

  export type PropertyFeatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyFeatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    featureId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyStationCreateInput = {
    id?: string
    walkMinutes?: number | null
    busMinutes?: number | null
    busStopName?: string | null
    isPrimary?: boolean
    property: PropertyCreateNestedOneWithoutStationsInput
    station: StationCreateNestedOneWithoutPropertyStationsInput
  }

  export type PropertyStationUncheckedCreateInput = {
    id?: string
    propertyId: string
    stationId: string
    walkMinutes?: number | null
    busMinutes?: number | null
    busStopName?: string | null
    isPrimary?: boolean
  }

  export type PropertyStationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busStopName?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    property?: PropertyUpdateOneRequiredWithoutStationsNestedInput
    station?: StationUpdateOneRequiredWithoutPropertyStationsNestedInput
  }

  export type PropertyStationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    stationId?: StringFieldUpdateOperationsInput | string
    walkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busStopName?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertyStationCreateManyInput = {
    id?: string
    propertyId: string
    stationId: string
    walkMinutes?: number | null
    busMinutes?: number | null
    busStopName?: string | null
    isPrimary?: boolean
  }

  export type PropertyStationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    walkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busStopName?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertyStationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    stationId?: StringFieldUpdateOperationsInput | string
    walkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busStopName?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FavoriteCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavoritesInput
    property: PropertyCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateInput = {
    id?: string
    userId: string
    propertyId: string
    createdAt?: Date | string
  }

  export type FavoriteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
    property?: PropertyUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCreateManyInput = {
    id?: string
    userId: string
    propertyId: string
    createdAt?: Date | string
  }

  export type FavoriteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewCreateInput = {
    id?: string
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    referer?: string | null
    viewedAt?: Date | string
    viewDurationSeconds?: number | null
    property: PropertyCreateNestedOneWithoutPropertyViewsInput
    user?: UserCreateNestedOneWithoutPropertyViewsInput
  }

  export type PropertyViewUncheckedCreateInput = {
    id?: string
    propertyId: string
    userId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    referer?: string | null
    viewedAt?: Date | string
    viewDurationSeconds?: number | null
  }

  export type PropertyViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    property?: PropertyUpdateOneRequiredWithoutPropertyViewsNestedInput
    user?: UserUpdateOneWithoutPropertyViewsNestedInput
  }

  export type PropertyViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyViewCreateManyInput = {
    id?: string
    propertyId: string
    userId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    referer?: string | null
    viewedAt?: Date | string
    viewDurationSeconds?: number | null
  }

  export type PropertyViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyViewDailyCreateInput = {
    id?: string
    viewDate: Date | string
    totalViews?: number
    uniqueUsers?: number
    avgDurationSeconds?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    property: PropertyCreateNestedOneWithoutPropertyViewDailiesInput
  }

  export type PropertyViewDailyUncheckedCreateInput = {
    id?: string
    propertyId: string
    viewDate: Date | string
    totalViews?: number
    uniqueUsers?: number
    avgDurationSeconds?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PropertyViewDailyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    uniqueUsers?: IntFieldUpdateOperationsInput | number
    avgDurationSeconds?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutPropertyViewDailiesNestedInput
  }

  export type PropertyViewDailyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    uniqueUsers?: IntFieldUpdateOperationsInput | number
    avgDurationSeconds?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewDailyCreateManyInput = {
    id?: string
    propertyId: string
    viewDate: Date | string
    totalViews?: number
    uniqueUsers?: number
    avgDurationSeconds?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PropertyViewDailyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    uniqueUsers?: IntFieldUpdateOperationsInput | number
    avgDurationSeconds?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewDailyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    uniqueUsers?: IntFieldUpdateOperationsInput | number
    avgDurationSeconds?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryCreateInput = {
    id?: string
    inquiryNumber: string
    targetType: $Enums.TargetType
    name: string
    furigana?: string | null
    email: string
    phone?: string | null
    companyName?: string | null
    inquiryType?: $Enums.InquiryType
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    assignedAt?: Date | string | null
    responseCount?: number
    lastRespondedAt?: Date | string | null
    closedAt?: Date | string | null
    closedReason?: string | null
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutInquiriesInput
    assignedAgent?: AgentCreateNestedOneWithoutAssignedInquiriesInput
    property?: PropertyCreateNestedOneWithoutInquiriesInput
    messages?: InquiryMessageCreateNestedManyWithoutInquiryInput
  }

  export type InquiryUncheckedCreateInput = {
    id?: string
    inquiryNumber: string
    targetType: $Enums.TargetType
    targetId?: string | null
    name: string
    furigana?: string | null
    email: string
    phone?: string | null
    companyName?: string | null
    inquiryType?: $Enums.InquiryType
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    userId?: string | null
    assignedAgentId?: string | null
    assignedAt?: Date | string | null
    responseCount?: number
    lastRespondedAt?: Date | string | null
    closedAt?: Date | string | null
    closedReason?: string | null
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: InquiryMessageUncheckedCreateNestedManyWithoutInquiryInput
  }

  export type InquiryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryNumber?: StringFieldUpdateOperationsInput | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    name?: StringFieldUpdateOperationsInput | string
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    inquiryType?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCount?: IntFieldUpdateOperationsInput | number
    lastRespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutInquiriesNestedInput
    assignedAgent?: AgentUpdateOneWithoutAssignedInquiriesNestedInput
    property?: PropertyUpdateOneWithoutInquiriesNestedInput
    messages?: InquiryMessageUpdateManyWithoutInquiryNestedInput
  }

  export type InquiryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryNumber?: StringFieldUpdateOperationsInput | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    inquiryType?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCount?: IntFieldUpdateOperationsInput | number
    lastRespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: InquiryMessageUncheckedUpdateManyWithoutInquiryNestedInput
  }

  export type InquiryCreateManyInput = {
    id?: string
    inquiryNumber: string
    targetType: $Enums.TargetType
    targetId?: string | null
    name: string
    furigana?: string | null
    email: string
    phone?: string | null
    companyName?: string | null
    inquiryType?: $Enums.InquiryType
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    userId?: string | null
    assignedAgentId?: string | null
    assignedAt?: Date | string | null
    responseCount?: number
    lastRespondedAt?: Date | string | null
    closedAt?: Date | string | null
    closedReason?: string | null
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InquiryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryNumber?: StringFieldUpdateOperationsInput | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    name?: StringFieldUpdateOperationsInput | string
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    inquiryType?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCount?: IntFieldUpdateOperationsInput | number
    lastRespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryNumber?: StringFieldUpdateOperationsInput | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    inquiryType?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCount?: IntFieldUpdateOperationsInput | number
    lastRespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryMessageCreateInput = {
    id?: string
    senderId?: string | null
    senderType: $Enums.SenderType
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isInternal?: boolean
    createdAt?: Date | string
    inquiry: InquiryCreateNestedOneWithoutMessagesInput
  }

  export type InquiryMessageUncheckedCreateInput = {
    id?: string
    inquiryId: string
    senderId?: string | null
    senderType: $Enums.SenderType
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type InquiryMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inquiry?: InquiryUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type InquiryMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryMessageCreateManyInput = {
    id?: string
    inquiryId: string
    senderId?: string | null
    senderType: $Enums.SenderType
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type InquiryMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulkAssessmentCreateInput = {
    id?: string
    assessmentNumber: string
    propertyAddress: string
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    constructionYear?: number | null
    ownerName: string
    email: string
    phone?: string | null
    preferredContactMethod?: string | null
    preferredContactTime?: string | null
    status?: $Enums.AssessmentStatus
    agentCount?: number
    responseCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    completedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutBulkAssessmentsInput
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutBulkAssessmentsInput
    responses?: BulkAssessmentResponseCreateNestedManyWithoutAssessmentInput
  }

  export type BulkAssessmentUncheckedCreateInput = {
    id?: string
    assessmentNumber: string
    propertyAddress: string
    propertyTypeId?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    constructionYear?: number | null
    ownerName: string
    email: string
    phone?: string | null
    preferredContactMethod?: string | null
    preferredContactTime?: string | null
    status?: $Enums.AssessmentStatus
    agentCount?: number
    responseCount?: number
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    completedAt?: Date | string | null
    responses?: BulkAssessmentResponseUncheckedCreateNestedManyWithoutAssessmentInput
  }

  export type BulkAssessmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentNumber?: StringFieldUpdateOperationsInput | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    constructionYear?: NullableIntFieldUpdateOperationsInput | number | null
    ownerName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    agentCount?: IntFieldUpdateOperationsInput | number
    responseCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutBulkAssessmentsNestedInput
    propertyType?: PropertyTypeMasterUpdateOneWithoutBulkAssessmentsNestedInput
    responses?: BulkAssessmentResponseUpdateManyWithoutAssessmentNestedInput
  }

  export type BulkAssessmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentNumber?: StringFieldUpdateOperationsInput | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    constructionYear?: NullableIntFieldUpdateOperationsInput | number | null
    ownerName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    agentCount?: IntFieldUpdateOperationsInput | number
    responseCount?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responses?: BulkAssessmentResponseUncheckedUpdateManyWithoutAssessmentNestedInput
  }

  export type BulkAssessmentCreateManyInput = {
    id?: string
    assessmentNumber: string
    propertyAddress: string
    propertyTypeId?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    constructionYear?: number | null
    ownerName: string
    email: string
    phone?: string | null
    preferredContactMethod?: string | null
    preferredContactTime?: string | null
    status?: $Enums.AssessmentStatus
    agentCount?: number
    responseCount?: number
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type BulkAssessmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentNumber?: StringFieldUpdateOperationsInput | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    constructionYear?: NullableIntFieldUpdateOperationsInput | number | null
    ownerName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    agentCount?: IntFieldUpdateOperationsInput | number
    responseCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BulkAssessmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentNumber?: StringFieldUpdateOperationsInput | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    constructionYear?: NullableIntFieldUpdateOperationsInput | number | null
    ownerName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    agentCount?: IntFieldUpdateOperationsInput | number
    responseCount?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BulkAssessmentResponseCreateInput = {
    id?: string
    assessedPrice?: bigint | number | null
    priceRangeMin?: bigint | number | null
    priceRangeMax?: bigint | number | null
    comments?: string | null
    proposalDocument?: string | null
    status?: $Enums.ResponseStatus
    submittedAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    assessment: BulkAssessmentCreateNestedOneWithoutResponsesInput
    agent: AgentCreateNestedOneWithoutBulkAssessmentResponsesInput
  }

  export type BulkAssessmentResponseUncheckedCreateInput = {
    id?: string
    assessmentId: string
    agentId: string
    assessedPrice?: bigint | number | null
    priceRangeMin?: bigint | number | null
    priceRangeMax?: bigint | number | null
    comments?: string | null
    proposalDocument?: string | null
    status?: $Enums.ResponseStatus
    submittedAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BulkAssessmentResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessedPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    proposalDocument?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumResponseStatusFieldUpdateOperationsInput | $Enums.ResponseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assessment?: BulkAssessmentUpdateOneRequiredWithoutResponsesNestedInput
    agent?: AgentUpdateOneRequiredWithoutBulkAssessmentResponsesNestedInput
  }

  export type BulkAssessmentResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    assessedPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    proposalDocument?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumResponseStatusFieldUpdateOperationsInput | $Enums.ResponseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulkAssessmentResponseCreateManyInput = {
    id?: string
    assessmentId: string
    agentId: string
    assessedPrice?: bigint | number | null
    priceRangeMin?: bigint | number | null
    priceRangeMax?: bigint | number | null
    comments?: string | null
    proposalDocument?: string | null
    status?: $Enums.ResponseStatus
    submittedAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BulkAssessmentResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessedPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    proposalDocument?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumResponseStatusFieldUpdateOperationsInput | $Enums.ResponseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulkAssessmentResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    assessedPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    proposalDocument?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumResponseStatusFieldUpdateOperationsInput | $Enums.ResponseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateInput = {
    id?: string
    questionNumber: string
    title: string
    content: string
    tags?: QuestionCreatetagsInput | string[]
    viewCount?: number
    answerCount?: number
    status?: $Enums.QuestionStatus
    bestAnswerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    author: UserCreateNestedOneWithoutQuestionsInput
    category?: QuestionCategoryCreateNestedOneWithoutQuestionsInput
    answers?: AnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateInput = {
    id?: string
    questionNumber: string
    title: string
    content: string
    categoryId?: string | null
    tags?: QuestionCreatetagsInput | string[]
    viewCount?: number
    answerCount?: number
    status?: $Enums.QuestionStatus
    authorId: string
    bestAnswerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tags?: QuestionUpdatetagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    answerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    bestAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: UserUpdateOneRequiredWithoutQuestionsNestedInput
    category?: QuestionCategoryUpdateOneWithoutQuestionsNestedInput
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: QuestionUpdatetagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    answerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    authorId?: StringFieldUpdateOperationsInput | string
    bestAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionCreateManyInput = {
    id?: string
    questionNumber: string
    title: string
    content: string
    categoryId?: string | null
    tags?: QuestionCreatetagsInput | string[]
    viewCount?: number
    answerCount?: number
    status?: $Enums.QuestionStatus
    authorId: string
    bestAnswerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type QuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tags?: QuestionUpdatetagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    answerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    bestAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: QuestionUpdatetagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    answerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    authorId?: StringFieldUpdateOperationsInput | string
    bestAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnswerCreateInput = {
    id?: string
    content: string
    goodCount?: number
    isBestAnswer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    question: QuestionCreateNestedOneWithoutAnswersInput
    author?: UserCreateNestedOneWithoutAnswersInput
    agent?: AgentCreateNestedOneWithoutAnswersInput
  }

  export type AnswerUncheckedCreateInput = {
    id?: string
    questionId: string
    content: string
    goodCount?: number
    isBestAnswer?: boolean
    authorId?: string | null
    agentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goodCount?: IntFieldUpdateOperationsInput | number
    isBestAnswer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question?: QuestionUpdateOneRequiredWithoutAnswersNestedInput
    author?: UserUpdateOneWithoutAnswersNestedInput
    agent?: AgentUpdateOneWithoutAnswersNestedInput
  }

  export type AnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goodCount?: IntFieldUpdateOperationsInput | number
    isBestAnswer?: BoolFieldUpdateOperationsInput | boolean
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnswerCreateManyInput = {
    id?: string
    questionId: string
    content: string
    goodCount?: number
    isBestAnswer?: boolean
    authorId?: string | null
    agentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goodCount?: IntFieldUpdateOperationsInput | number
    isBestAnswer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goodCount?: IntFieldUpdateOperationsInput | number
    isBestAnswer?: BoolFieldUpdateOperationsInput | boolean
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeatureMasterCreateInput = {
    id?: string
    code: string
    name: string
    category: $Enums.FeatureCategory
    icon?: string | null
    displayOrder?: number
    isActive?: boolean
    properties?: PropertyFeatureCreateNestedManyWithoutFeatureInput
  }

  export type FeatureMasterUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    category: $Enums.FeatureCategory
    icon?: string | null
    displayOrder?: number
    isActive?: boolean
    properties?: PropertyFeatureUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureMasterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFeatureCategoryFieldUpdateOperationsInput | $Enums.FeatureCategory
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    properties?: PropertyFeatureUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureMasterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFeatureCategoryFieldUpdateOperationsInput | $Enums.FeatureCategory
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    properties?: PropertyFeatureUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureMasterCreateManyInput = {
    id?: string
    code: string
    name: string
    category: $Enums.FeatureCategory
    icon?: string | null
    displayOrder?: number
    isActive?: boolean
  }

  export type FeatureMasterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFeatureCategoryFieldUpdateOperationsInput | $Enums.FeatureCategory
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeatureMasterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFeatureCategoryFieldUpdateOperationsInput | $Enums.FeatureCategory
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RegionMasterCreateInput = {
    id?: string
    code: string
    name: string
    displayOrder?: number
    isActive?: boolean
    areas?: AreaMasterCreateNestedManyWithoutRegionInput
  }

  export type RegionMasterUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    displayOrder?: number
    isActive?: boolean
    areas?: AreaMasterUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionMasterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    areas?: AreaMasterUpdateManyWithoutRegionNestedInput
  }

  export type RegionMasterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    areas?: AreaMasterUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type RegionMasterCreateManyInput = {
    id?: string
    code: string
    name: string
    displayOrder?: number
    isActive?: boolean
  }

  export type RegionMasterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RegionMasterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AreaMasterCreateInput = {
    id?: string
    prefectureCode: string
    prefecture: string
    cityCode?: string | null
    city: string
    displayOrder?: number
    isActive?: boolean
    region?: RegionMasterCreateNestedOneWithoutAreasInput
    properties?: PropertyCreateNestedManyWithoutAreaInput
  }

  export type AreaMasterUncheckedCreateInput = {
    id?: string
    regionId?: string | null
    prefectureCode: string
    prefecture: string
    cityCode?: string | null
    city: string
    displayOrder?: number
    isActive?: boolean
    properties?: PropertyUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaMasterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prefectureCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    region?: RegionMasterUpdateOneWithoutAreasNestedInput
    properties?: PropertyUpdateManyWithoutAreaNestedInput
  }

  export type AreaMasterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    prefectureCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    properties?: PropertyUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type AreaMasterCreateManyInput = {
    id?: string
    regionId?: string | null
    prefectureCode: string
    prefecture: string
    cityCode?: string | null
    city: string
    displayOrder?: number
    isActive?: boolean
  }

  export type AreaMasterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    prefectureCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AreaMasterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    prefectureCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertyTypeMasterCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    displayOrder?: number
    isActive?: boolean
    properties?: PropertyCreateNestedManyWithoutPropertyTypeInput
    bulkAssessments?: BulkAssessmentCreateNestedManyWithoutPropertyTypeInput
  }

  export type PropertyTypeMasterUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    displayOrder?: number
    isActive?: boolean
    properties?: PropertyUncheckedCreateNestedManyWithoutPropertyTypeInput
    bulkAssessments?: BulkAssessmentUncheckedCreateNestedManyWithoutPropertyTypeInput
  }

  export type PropertyTypeMasterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    properties?: PropertyUpdateManyWithoutPropertyTypeNestedInput
    bulkAssessments?: BulkAssessmentUpdateManyWithoutPropertyTypeNestedInput
  }

  export type PropertyTypeMasterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    properties?: PropertyUncheckedUpdateManyWithoutPropertyTypeNestedInput
    bulkAssessments?: BulkAssessmentUncheckedUpdateManyWithoutPropertyTypeNestedInput
  }

  export type PropertyTypeMasterCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    displayOrder?: number
    isActive?: boolean
  }

  export type PropertyTypeMasterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertyTypeMasterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertyCategoryMasterCreateInput = {
    id?: string
    code: string
    name: string
    displayOrder?: number
    isActive?: boolean
    properties?: PropertyCreateNestedManyWithoutPropertyCategoryInput
  }

  export type PropertyCategoryMasterUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    displayOrder?: number
    isActive?: boolean
    properties?: PropertyUncheckedCreateNestedManyWithoutPropertyCategoryInput
  }

  export type PropertyCategoryMasterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    properties?: PropertyUpdateManyWithoutPropertyCategoryNestedInput
  }

  export type PropertyCategoryMasterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    properties?: PropertyUncheckedUpdateManyWithoutPropertyCategoryNestedInput
  }

  export type PropertyCategoryMasterCreateManyInput = {
    id?: string
    code: string
    name: string
    displayOrder?: number
    isActive?: boolean
  }

  export type PropertyCategoryMasterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertyCategoryMasterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FloorPlanMasterCreateInput = {
    id?: string
    code: string
    name: string
    roomCount?: number | null
    displayOrder?: number
    isActive?: boolean
    properties?: PropertyCreateNestedManyWithoutLayoutTypeInput
  }

  export type FloorPlanMasterUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    roomCount?: number | null
    displayOrder?: number
    isActive?: boolean
    properties?: PropertyUncheckedCreateNestedManyWithoutLayoutTypeInput
  }

  export type FloorPlanMasterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roomCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    properties?: PropertyUpdateManyWithoutLayoutTypeNestedInput
  }

  export type FloorPlanMasterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roomCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    properties?: PropertyUncheckedUpdateManyWithoutLayoutTypeNestedInput
  }

  export type FloorPlanMasterCreateManyInput = {
    id?: string
    code: string
    name: string
    roomCount?: number | null
    displayOrder?: number
    isActive?: boolean
  }

  export type FloorPlanMasterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roomCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FloorPlanMasterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roomCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RouteMasterCreateInput = {
    id?: string
    code: string
    name: string
    companyName?: string | null
    lineColor?: string | null
    displayOrder?: number
    isActive?: boolean
    stations?: StationCreateNestedManyWithoutRouteInput
  }

  export type RouteMasterUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    companyName?: string | null
    lineColor?: string | null
    displayOrder?: number
    isActive?: boolean
    stations?: StationUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteMasterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    lineColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    stations?: StationUpdateManyWithoutRouteNestedInput
  }

  export type RouteMasterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    lineColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    stations?: StationUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type RouteMasterCreateManyInput = {
    id?: string
    code: string
    name: string
    companyName?: string | null
    lineColor?: string | null
    displayOrder?: number
    isActive?: boolean
  }

  export type RouteMasterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    lineColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RouteMasterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    lineColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StationCreateInput = {
    id?: string
    code: string
    name: string
    nameKana?: string | null
    prefecture?: string | null
    city?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    displayOrder?: number
    isActive?: boolean
    route?: RouteMasterCreateNestedOneWithoutStationsInput
    propertyStations?: PropertyStationCreateNestedManyWithoutStationInput
  }

  export type StationUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    nameKana?: string | null
    routeId?: string | null
    prefecture?: string | null
    city?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    displayOrder?: number
    isActive?: boolean
    propertyStations?: PropertyStationUncheckedCreateNestedManyWithoutStationInput
  }

  export type StationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKana?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    route?: RouteMasterUpdateOneWithoutStationsNestedInput
    propertyStations?: PropertyStationUpdateManyWithoutStationNestedInput
  }

  export type StationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKana?: NullableStringFieldUpdateOperationsInput | string | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    propertyStations?: PropertyStationUncheckedUpdateManyWithoutStationNestedInput
  }

  export type StationCreateManyInput = {
    id?: string
    code: string
    name: string
    nameKana?: string | null
    routeId?: string | null
    prefecture?: string | null
    city?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    displayOrder?: number
    isActive?: boolean
  }

  export type StationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKana?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKana?: NullableStringFieldUpdateOperationsInput | string | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuestionCategoryCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    displayOrder?: number
    isActive?: boolean
    questions?: QuestionCreateNestedManyWithoutCategoryInput
  }

  export type QuestionCategoryUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    displayOrder?: number
    isActive?: boolean
    questions?: QuestionUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type QuestionCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    questions?: QuestionUpdateManyWithoutCategoryNestedInput
  }

  export type QuestionCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    questions?: QuestionUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type QuestionCategoryCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    displayOrder?: number
    isActive?: boolean
  }

  export type QuestionCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuestionCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MailCreateInput = {
    id?: string
    fromEmail: string
    fromName?: string | null
    toEmail: string
    toName?: string | null
    ccEmail?: MailCreateccEmailInput | string[]
    bccEmail?: MailCreatebccEmailInput | string[]
    subject: string
    bodyText: string
    bodyHtml?: string | null
    status?: $Enums.MailStatus
    mailType?: $Enums.MailType
    templateCode?: string | null
    templateVariables?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutMailsInput
  }

  export type MailUncheckedCreateInput = {
    id?: string
    fromEmail: string
    fromName?: string | null
    toEmail: string
    toName?: string | null
    ccEmail?: MailCreateccEmailInput | string[]
    bccEmail?: MailCreatebccEmailInput | string[]
    subject: string
    bodyText: string
    bodyHtml?: string | null
    status?: $Enums.MailStatus
    mailType?: $Enums.MailType
    templateCode?: string | null
    templateVariables?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    userId?: string | null
    retryCount?: number
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: StringFieldUpdateOperationsInput | string
    toName?: NullableStringFieldUpdateOperationsInput | string | null
    ccEmail?: MailUpdateccEmailInput | string[]
    bccEmail?: MailUpdatebccEmailInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    bodyText?: StringFieldUpdateOperationsInput | string
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMailStatusFieldUpdateOperationsInput | $Enums.MailStatus
    mailType?: EnumMailTypeFieldUpdateOperationsInput | $Enums.MailType
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    templateVariables?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutMailsNestedInput
  }

  export type MailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: StringFieldUpdateOperationsInput | string
    toName?: NullableStringFieldUpdateOperationsInput | string | null
    ccEmail?: MailUpdateccEmailInput | string[]
    bccEmail?: MailUpdatebccEmailInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    bodyText?: StringFieldUpdateOperationsInput | string
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMailStatusFieldUpdateOperationsInput | $Enums.MailStatus
    mailType?: EnumMailTypeFieldUpdateOperationsInput | $Enums.MailType
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    templateVariables?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailCreateManyInput = {
    id?: string
    fromEmail: string
    fromName?: string | null
    toEmail: string
    toName?: string | null
    ccEmail?: MailCreateccEmailInput | string[]
    bccEmail?: MailCreatebccEmailInput | string[]
    subject: string
    bodyText: string
    bodyHtml?: string | null
    status?: $Enums.MailStatus
    mailType?: $Enums.MailType
    templateCode?: string | null
    templateVariables?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    userId?: string | null
    retryCount?: number
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: StringFieldUpdateOperationsInput | string
    toName?: NullableStringFieldUpdateOperationsInput | string | null
    ccEmail?: MailUpdateccEmailInput | string[]
    bccEmail?: MailUpdatebccEmailInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    bodyText?: StringFieldUpdateOperationsInput | string
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMailStatusFieldUpdateOperationsInput | $Enums.MailStatus
    mailType?: EnumMailTypeFieldUpdateOperationsInput | $Enums.MailType
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    templateVariables?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: StringFieldUpdateOperationsInput | string
    toName?: NullableStringFieldUpdateOperationsInput | string | null
    ccEmail?: MailUpdateccEmailInput | string[]
    bccEmail?: MailUpdatebccEmailInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    bodyText?: StringFieldUpdateOperationsInput | string
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMailStatusFieldUpdateOperationsInput | $Enums.MailStatus
    mailType?: EnumMailTypeFieldUpdateOperationsInput | $Enums.MailType
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    templateVariables?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileBoxCreateInput = {
    id?: string
    bucketName: string
    storagePath: string
    fileName: string
    originalName: string
    publicUrl?: string | null
    mimeType: string
    fileSize: bigint | number
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutFileBoxesInput
    propertyImages?: PropertyImageCreateNestedManyWithoutFileBoxInput
  }

  export type FileBoxUncheckedCreateInput = {
    id?: string
    bucketName: string
    storagePath: string
    fileName: string
    originalName: string
    publicUrl?: string | null
    mimeType: string
    fileSize: bigint | number
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyImages?: PropertyImageUncheckedCreateNestedManyWithoutFileBoxInput
  }

  export type FileBoxUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutFileBoxesNestedInput
    propertyImages?: PropertyImageUpdateManyWithoutFileBoxNestedInput
  }

  export type FileBoxUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyImages?: PropertyImageUncheckedUpdateManyWithoutFileBoxNestedInput
  }

  export type FileBoxCreateManyInput = {
    id?: string
    bucketName: string
    storagePath: string
    fileName: string
    originalName: string
    publicUrl?: string | null
    mimeType: string
    fileSize: bigint | number
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type FileBoxUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileBoxUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemSettingCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    valueType: string
    category?: string | null
    description?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: UserCreateNestedOneWithoutSystemSettingsUpdatedInput
  }

  export type SystemSettingUncheckedCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    valueType: string
    category?: string | null
    description?: string | null
    isPublic?: boolean
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    valueType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: UserUpdateOneWithoutSystemSettingsUpdatedNestedInput
  }

  export type SystemSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    valueType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateManyInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    valueType: string
    category?: string | null
    description?: string | null
    isPublic?: boolean
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    valueType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    valueType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    tableName: string
    recordId: string
    action: $Enums.AuditAction
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: AuditLogCreatechangedFieldsInput | string[]
    userEmail?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    tableName: string
    recordId: string
    action: $Enums.AuditAction
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: AuditLogCreatechangedFieldsInput | string[]
    userId?: string | null
    userEmail?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: AuditLogUpdatechangedFieldsInput | string[]
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: AuditLogUpdatechangedFieldsInput | string[]
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    tableName: string
    recordId: string
    action: $Enums.AuditAction
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: AuditLogCreatechangedFieldsInput | string[]
    userId?: string | null
    userEmail?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: AuditLogUpdatechangedFieldsInput | string[]
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: AuditLogUpdatechangedFieldsInput | string[]
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    linkUrl?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    linkUrl?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    linkUrl?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type AgentNullableScalarRelationFilter = {
    is?: AgentWhereInput | null
    isNot?: AgentWhereInput | null
  }

  export type PropertyListRelationFilter = {
    every?: PropertyWhereInput
    some?: PropertyWhereInput
    none?: PropertyWhereInput
  }

  export type InquiryListRelationFilter = {
    every?: InquiryWhereInput
    some?: InquiryWhereInput
    none?: InquiryWhereInput
  }

  export type FavoriteListRelationFilter = {
    every?: FavoriteWhereInput
    some?: FavoriteWhereInput
    none?: FavoriteWhereInput
  }

  export type PropertyViewListRelationFilter = {
    every?: PropertyViewWhereInput
    some?: PropertyViewWhereInput
    none?: PropertyViewWhereInput
  }

  export type QuestionListRelationFilter = {
    every?: QuestionWhereInput
    some?: QuestionWhereInput
    none?: QuestionWhereInput
  }

  export type AnswerListRelationFilter = {
    every?: AnswerWhereInput
    some?: AnswerWhereInput
    none?: AnswerWhereInput
  }

  export type BulkAssessmentListRelationFilter = {
    every?: BulkAssessmentWhereInput
    some?: BulkAssessmentWhereInput
    none?: BulkAssessmentWhereInput
  }

  export type MailListRelationFilter = {
    every?: MailWhereInput
    some?: MailWhereInput
    none?: MailWhereInput
  }

  export type FileBoxListRelationFilter = {
    every?: FileBoxWhereInput
    some?: FileBoxWhereInput
    none?: FileBoxWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SystemSettingListRelationFilter = {
    every?: SystemSettingWhereInput
    some?: SystemSettingWhereInput
    none?: SystemSettingWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type PropertyPriceHistoryListRelationFilter = {
    every?: PropertyPriceHistoryWhereInput
    some?: PropertyPriceHistoryWhereInput
    none?: PropertyPriceHistoryWhereInput
  }

  export type PropertyStatusHistoryListRelationFilter = {
    every?: PropertyStatusHistoryWhereInput
    some?: PropertyStatusHistoryWhereInput
    none?: PropertyStatusHistoryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InquiryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BulkAssessmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileBoxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemSettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyPriceHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyStatusHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    furigana?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    phone?: SortOrder
    avatarUrl?: SortOrder
    status?: SortOrder
    emailVerifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    furigana?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    phone?: SortOrder
    avatarUrl?: SortOrder
    status?: SortOrder
    emailVerifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    furigana?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    phone?: SortOrder
    avatarUrl?: SortOrder
    status?: SortOrder
    emailVerifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: string
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type EnumCompanyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatus | EnumCompanyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatus[] | ListEnumCompanyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyStatus[] | ListEnumCompanyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyStatusFilter<$PrismaModel> | $Enums.CompanyStatus
  }

  export type BranchListRelationFilter = {
    every?: BranchWhereInput
    some?: BranchWhereInput
    none?: BranchWhereInput
  }

  export type BranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    companyNameKana?: SortOrder
    representativeName?: SortOrder
    postalCode?: SortOrder
    prefecture?: SortOrder
    city?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrder
    fax?: SortOrder
    website?: SortOrder
    licenseNumber?: SortOrder
    associationMembership?: SortOrder
    accountType?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    companyNameKana?: SortOrder
    representativeName?: SortOrder
    postalCode?: SortOrder
    prefecture?: SortOrder
    city?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrder
    fax?: SortOrder
    website?: SortOrder
    licenseNumber?: SortOrder
    associationMembership?: SortOrder
    accountType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    companyNameKana?: SortOrder
    representativeName?: SortOrder
    postalCode?: SortOrder
    prefecture?: SortOrder
    city?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrder
    fax?: SortOrder
    website?: SortOrder
    licenseNumber?: SortOrder
    associationMembership?: SortOrder
    accountType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type EnumCompanyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatus | EnumCompanyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatus[] | ListEnumCompanyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyStatus[] | ListEnumCompanyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyStatusWithAggregatesFilter<$PrismaModel> | $Enums.CompanyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyStatusFilter<$PrismaModel>
    _max?: NestedEnumCompanyStatusFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type AgentListRelationFilter = {
    every?: AgentWhereInput
    some?: AgentWhereInput
    none?: AgentWhereInput
  }

  export type AgentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    branchName?: SortOrder
    postalCode?: SortOrder
    prefecture?: SortOrder
    city?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrder
    fax?: SortOrder
    businessHours?: SortOrder
    isHeadquarters?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BranchAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    branchName?: SortOrder
    postalCode?: SortOrder
    prefecture?: SortOrder
    city?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrder
    fax?: SortOrder
    businessHours?: SortOrder
    isHeadquarters?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    branchName?: SortOrder
    postalCode?: SortOrder
    prefecture?: SortOrder
    city?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrder
    fax?: SortOrder
    businessHours?: SortOrder
    isHeadquarters?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BranchSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BranchScalarRelationFilter = {
    is?: BranchWhereInput
    isNot?: BranchWhereInput
  }

  export type BulkAssessmentResponseListRelationFilter = {
    every?: BulkAssessmentResponseWhereInput
    some?: BulkAssessmentResponseWhereInput
    none?: BulkAssessmentResponseWhereInput
  }

  export type BulkAssessmentResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentCountOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    department?: SortOrder
    licenseNumber?: SortOrder
    licenseExpireDate?: SortOrder
    goodCount?: SortOrder
    responseRate?: SortOrder
    avgResponseMinutes?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AgentAvgOrderByAggregateInput = {
    goodCount?: SortOrder
    responseRate?: SortOrder
    avgResponseMinutes?: SortOrder
  }

  export type AgentMaxOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    department?: SortOrder
    licenseNumber?: SortOrder
    licenseExpireDate?: SortOrder
    goodCount?: SortOrder
    responseRate?: SortOrder
    avgResponseMinutes?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AgentMinOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    department?: SortOrder
    licenseNumber?: SortOrder
    licenseExpireDate?: SortOrder
    goodCount?: SortOrder
    responseRate?: SortOrder
    avgResponseMinutes?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AgentSumOrderByAggregateInput = {
    goodCount?: SortOrder
    responseRate?: SortOrder
    avgResponseMinutes?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type EnumTransactionTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTransactionTypeNullableFilter<$PrismaModel> | $Enums.TransactionType | null
  }

  export type EnumPropertyConditionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyCondition | EnumPropertyConditionFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyCondition[] | ListEnumPropertyConditionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyCondition[] | ListEnumPropertyConditionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyConditionNullableFilter<$PrismaModel> | $Enums.PropertyCondition | null
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type PropertyTypeMasterNullableScalarRelationFilter = {
    is?: PropertyTypeMasterWhereInput | null
    isNot?: PropertyTypeMasterWhereInput | null
  }

  export type PropertyCategoryMasterNullableScalarRelationFilter = {
    is?: PropertyCategoryMasterWhereInput | null
    isNot?: PropertyCategoryMasterWhereInput | null
  }

  export type AreaMasterNullableScalarRelationFilter = {
    is?: AreaMasterWhereInput | null
    isNot?: AreaMasterWhereInput | null
  }

  export type FloorPlanMasterNullableScalarRelationFilter = {
    is?: FloorPlanMasterWhereInput | null
    isNot?: FloorPlanMasterWhereInput | null
  }

  export type PropertyPublicationNullableScalarRelationFilter = {
    is?: PropertyPublicationWhereInput | null
    isNot?: PropertyPublicationWhereInput | null
  }

  export type PropertyImageListRelationFilter = {
    every?: PropertyImageWhereInput
    some?: PropertyImageWhereInput
    none?: PropertyImageWhereInput
  }

  export type PropertyFeatureListRelationFilter = {
    every?: PropertyFeatureWhereInput
    some?: PropertyFeatureWhereInput
    none?: PropertyFeatureWhereInput
  }

  export type PropertyStationListRelationFilter = {
    every?: PropertyStationWhereInput
    some?: PropertyStationWhereInput
    none?: PropertyStationWhereInput
  }

  export type PropertyViewDailyListRelationFilter = {
    every?: PropertyViewDailyWhereInput
    some?: PropertyViewDailyWhereInput
    none?: PropertyViewDailyWhereInput
  }

  export type PropertyImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyStationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyViewDailyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder
    propertyCode?: SortOrder
    propertyName?: SortOrder
    propertyNameKana?: SortOrder
    propertyTypeId?: SortOrder
    propertyCategoryId?: SortOrder
    areaId?: SortOrder
    transactionType?: SortOrder
    propertyCondition?: SortOrder
    postalCode?: SortOrder
    prefecture?: SortOrder
    city?: SortOrder
    town?: SortOrder
    block?: SortOrder
    building?: SortOrder
    roomNumber?: SortOrder
    fullAddress?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    layoutNumber?: SortOrder
    layoutTypeId?: SortOrder
    layoutDisplay?: SortOrder
    buildingArea?: SortOrder
    landArea?: SortOrder
    balconyArea?: SortOrder
    buildingStructure?: SortOrder
    constructionDate?: SortOrder
    constructionYearMonth?: SortOrder
    totalFloors?: SortOrder
    floor?: SortOrder
    currentPrice?: SortOrder
    pricePerTsubo?: SortOrder
    managementFee?: SortOrder
    commonServiceFee?: SortOrder
    depositMonths?: SortOrder
    keyMoneyMonths?: SortOrder
    mainImageUrl?: SortOrder
    primaryStationName?: SortOrder
    primaryStationWalkMinutes?: SortOrder
    featureTags?: SortOrder
    viewCount?: SortOrder
    inquiryCount?: SortOrder
    favoriteCount?: SortOrder
    agentId?: SortOrder
    remarks?: SortOrder
    internalMemo?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    userId?: SortOrder
  }

  export type PropertyAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    layoutNumber?: SortOrder
    buildingArea?: SortOrder
    landArea?: SortOrder
    balconyArea?: SortOrder
    totalFloors?: SortOrder
    floor?: SortOrder
    currentPrice?: SortOrder
    pricePerTsubo?: SortOrder
    managementFee?: SortOrder
    commonServiceFee?: SortOrder
    depositMonths?: SortOrder
    keyMoneyMonths?: SortOrder
    primaryStationWalkMinutes?: SortOrder
    viewCount?: SortOrder
    inquiryCount?: SortOrder
    favoriteCount?: SortOrder
  }

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyCode?: SortOrder
    propertyName?: SortOrder
    propertyNameKana?: SortOrder
    propertyTypeId?: SortOrder
    propertyCategoryId?: SortOrder
    areaId?: SortOrder
    transactionType?: SortOrder
    propertyCondition?: SortOrder
    postalCode?: SortOrder
    prefecture?: SortOrder
    city?: SortOrder
    town?: SortOrder
    block?: SortOrder
    building?: SortOrder
    roomNumber?: SortOrder
    fullAddress?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    layoutNumber?: SortOrder
    layoutTypeId?: SortOrder
    layoutDisplay?: SortOrder
    buildingArea?: SortOrder
    landArea?: SortOrder
    balconyArea?: SortOrder
    buildingStructure?: SortOrder
    constructionDate?: SortOrder
    constructionYearMonth?: SortOrder
    totalFloors?: SortOrder
    floor?: SortOrder
    currentPrice?: SortOrder
    pricePerTsubo?: SortOrder
    managementFee?: SortOrder
    commonServiceFee?: SortOrder
    depositMonths?: SortOrder
    keyMoneyMonths?: SortOrder
    mainImageUrl?: SortOrder
    primaryStationName?: SortOrder
    primaryStationWalkMinutes?: SortOrder
    viewCount?: SortOrder
    inquiryCount?: SortOrder
    favoriteCount?: SortOrder
    agentId?: SortOrder
    remarks?: SortOrder
    internalMemo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    userId?: SortOrder
  }

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder
    propertyCode?: SortOrder
    propertyName?: SortOrder
    propertyNameKana?: SortOrder
    propertyTypeId?: SortOrder
    propertyCategoryId?: SortOrder
    areaId?: SortOrder
    transactionType?: SortOrder
    propertyCondition?: SortOrder
    postalCode?: SortOrder
    prefecture?: SortOrder
    city?: SortOrder
    town?: SortOrder
    block?: SortOrder
    building?: SortOrder
    roomNumber?: SortOrder
    fullAddress?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    layoutNumber?: SortOrder
    layoutTypeId?: SortOrder
    layoutDisplay?: SortOrder
    buildingArea?: SortOrder
    landArea?: SortOrder
    balconyArea?: SortOrder
    buildingStructure?: SortOrder
    constructionDate?: SortOrder
    constructionYearMonth?: SortOrder
    totalFloors?: SortOrder
    floor?: SortOrder
    currentPrice?: SortOrder
    pricePerTsubo?: SortOrder
    managementFee?: SortOrder
    commonServiceFee?: SortOrder
    depositMonths?: SortOrder
    keyMoneyMonths?: SortOrder
    mainImageUrl?: SortOrder
    primaryStationName?: SortOrder
    primaryStationWalkMinutes?: SortOrder
    viewCount?: SortOrder
    inquiryCount?: SortOrder
    favoriteCount?: SortOrder
    agentId?: SortOrder
    remarks?: SortOrder
    internalMemo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    userId?: SortOrder
  }

  export type PropertySumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    layoutNumber?: SortOrder
    buildingArea?: SortOrder
    landArea?: SortOrder
    balconyArea?: SortOrder
    totalFloors?: SortOrder
    floor?: SortOrder
    currentPrice?: SortOrder
    pricePerTsubo?: SortOrder
    managementFee?: SortOrder
    commonServiceFee?: SortOrder
    depositMonths?: SortOrder
    keyMoneyMonths?: SortOrder
    primaryStationWalkMinutes?: SortOrder
    viewCount?: SortOrder
    inquiryCount?: SortOrder
    favoriteCount?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumTransactionTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTransactionTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeNullableFilter<$PrismaModel>
  }

  export type EnumPropertyConditionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyCondition | EnumPropertyConditionFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyCondition[] | ListEnumPropertyConditionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyCondition[] | ListEnumPropertyConditionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyConditionNullableWithAggregatesFilter<$PrismaModel> | $Enums.PropertyCondition | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPropertyConditionNullableFilter<$PrismaModel>
    _max?: NestedEnumPropertyConditionNullableFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type EnumPublicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicationStatus | EnumPublicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicationStatusFilter<$PrismaModel> | $Enums.PublicationStatus
  }

  export type EnumPublicScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicScope | EnumPublicScopeFieldRefInput<$PrismaModel>
    in?: $Enums.PublicScope[] | ListEnumPublicScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicScope[] | ListEnumPublicScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicScopeFilter<$PrismaModel> | $Enums.PublicScope
  }

  export type PropertyScalarRelationFilter = {
    is?: PropertyWhereInput
    isNot?: PropertyWhereInput
  }

  export type PropertyPublicationCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    status?: SortOrder
    scope?: SortOrder
    featured?: SortOrder
    featuredOrder?: SortOrder
    publishedAt?: SortOrder
    unpublishedAt?: SortOrder
    soldAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyPublicationAvgOrderByAggregateInput = {
    featuredOrder?: SortOrder
  }

  export type PropertyPublicationMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    status?: SortOrder
    scope?: SortOrder
    featured?: SortOrder
    featuredOrder?: SortOrder
    publishedAt?: SortOrder
    unpublishedAt?: SortOrder
    soldAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyPublicationMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    status?: SortOrder
    scope?: SortOrder
    featured?: SortOrder
    featuredOrder?: SortOrder
    publishedAt?: SortOrder
    unpublishedAt?: SortOrder
    soldAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyPublicationSumOrderByAggregateInput = {
    featuredOrder?: SortOrder
  }

  export type EnumPublicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicationStatus | EnumPublicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.PublicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublicationStatusFilter<$PrismaModel>
    _max?: NestedEnumPublicationStatusFilter<$PrismaModel>
  }

  export type EnumPublicScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicScope | EnumPublicScopeFieldRefInput<$PrismaModel>
    in?: $Enums.PublicScope[] | ListEnumPublicScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicScope[] | ListEnumPublicScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicScopeWithAggregatesFilter<$PrismaModel> | $Enums.PublicScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublicScopeFilter<$PrismaModel>
    _max?: NestedEnumPublicScopeFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PropertyPriceHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    previousPrice?: SortOrder
    newPrice?: SortOrder
    changePercent?: SortOrder
    changeReason?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyPriceHistoryAvgOrderByAggregateInput = {
    previousPrice?: SortOrder
    newPrice?: SortOrder
    changePercent?: SortOrder
  }

  export type PropertyPriceHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    previousPrice?: SortOrder
    newPrice?: SortOrder
    changePercent?: SortOrder
    changeReason?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyPriceHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    previousPrice?: SortOrder
    newPrice?: SortOrder
    changePercent?: SortOrder
    changeReason?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyPriceHistorySumOrderByAggregateInput = {
    previousPrice?: SortOrder
    newPrice?: SortOrder
    changePercent?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type PropertyStatusHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    previousStatus?: SortOrder
    newStatus?: SortOrder
    changeReason?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyStatusHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    previousStatus?: SortOrder
    newStatus?: SortOrder
    changeReason?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyStatusHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    previousStatus?: SortOrder
    newStatus?: SortOrder
    changeReason?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumImageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageType | EnumImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImageType[] | ListEnumImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageType[] | ListEnumImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImageTypeFilter<$PrismaModel> | $Enums.ImageType
  }

  export type FileBoxNullableScalarRelationFilter = {
    is?: FileBoxWhereInput | null
    isNot?: FileBoxWhereInput | null
  }

  export type PropertyImageCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    fileBoxId?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    caption?: SortOrder
    imageType?: SortOrder
    displayOrder?: SortOrder
    isMain?: SortOrder
    width?: SortOrder
    height?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyImageAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type PropertyImageMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    fileBoxId?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    caption?: SortOrder
    imageType?: SortOrder
    displayOrder?: SortOrder
    isMain?: SortOrder
    width?: SortOrder
    height?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyImageMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    fileBoxId?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    caption?: SortOrder
    imageType?: SortOrder
    displayOrder?: SortOrder
    isMain?: SortOrder
    width?: SortOrder
    height?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyImageSumOrderByAggregateInput = {
    displayOrder?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type EnumImageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageType | EnumImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImageType[] | ListEnumImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageType[] | ListEnumImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImageTypeWithAggregatesFilter<$PrismaModel> | $Enums.ImageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImageTypeFilter<$PrismaModel>
    _max?: NestedEnumImageTypeFilter<$PrismaModel>
  }

  export type FeatureMasterScalarRelationFilter = {
    is?: FeatureMasterWhereInput
    isNot?: FeatureMasterWhereInput
  }

  export type PropertyFeaturePropertyIdFeatureIdCompoundUniqueInput = {
    propertyId: string
    featureId: string
  }

  export type PropertyFeatureCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    featureId?: SortOrder
  }

  export type PropertyFeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    featureId?: SortOrder
  }

  export type PropertyFeatureMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    featureId?: SortOrder
  }

  export type StationScalarRelationFilter = {
    is?: StationWhereInput
    isNot?: StationWhereInput
  }

  export type PropertyStationPropertyIdStationIdCompoundUniqueInput = {
    propertyId: string
    stationId: string
  }

  export type PropertyStationCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    stationId?: SortOrder
    walkMinutes?: SortOrder
    busMinutes?: SortOrder
    busStopName?: SortOrder
    isPrimary?: SortOrder
  }

  export type PropertyStationAvgOrderByAggregateInput = {
    walkMinutes?: SortOrder
    busMinutes?: SortOrder
  }

  export type PropertyStationMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    stationId?: SortOrder
    walkMinutes?: SortOrder
    busMinutes?: SortOrder
    busStopName?: SortOrder
    isPrimary?: SortOrder
  }

  export type PropertyStationMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    stationId?: SortOrder
    walkMinutes?: SortOrder
    busMinutes?: SortOrder
    busStopName?: SortOrder
    isPrimary?: SortOrder
  }

  export type PropertyStationSumOrderByAggregateInput = {
    walkMinutes?: SortOrder
    busMinutes?: SortOrder
  }

  export type FavoriteUserIdPropertyIdCompoundUniqueInput = {
    userId: string
    propertyId: string
  }

  export type FavoriteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyViewCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referer?: SortOrder
    viewedAt?: SortOrder
    viewDurationSeconds?: SortOrder
  }

  export type PropertyViewAvgOrderByAggregateInput = {
    viewDurationSeconds?: SortOrder
  }

  export type PropertyViewMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referer?: SortOrder
    viewedAt?: SortOrder
    viewDurationSeconds?: SortOrder
  }

  export type PropertyViewMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referer?: SortOrder
    viewedAt?: SortOrder
    viewDurationSeconds?: SortOrder
  }

  export type PropertyViewSumOrderByAggregateInput = {
    viewDurationSeconds?: SortOrder
  }

  export type PropertyViewDailyPropertyIdViewDateCompoundUniqueInput = {
    propertyId: string
    viewDate: Date | string
  }

  export type PropertyViewDailyCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    viewDate?: SortOrder
    totalViews?: SortOrder
    uniqueUsers?: SortOrder
    avgDurationSeconds?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyViewDailyAvgOrderByAggregateInput = {
    totalViews?: SortOrder
    uniqueUsers?: SortOrder
    avgDurationSeconds?: SortOrder
  }

  export type PropertyViewDailyMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    viewDate?: SortOrder
    totalViews?: SortOrder
    uniqueUsers?: SortOrder
    avgDurationSeconds?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyViewDailyMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    viewDate?: SortOrder
    totalViews?: SortOrder
    uniqueUsers?: SortOrder
    avgDurationSeconds?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyViewDailySumOrderByAggregateInput = {
    totalViews?: SortOrder
    uniqueUsers?: SortOrder
    avgDurationSeconds?: SortOrder
  }

  export type EnumTargetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TargetType | EnumTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TargetType[] | ListEnumTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TargetType[] | ListEnumTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTargetTypeFilter<$PrismaModel> | $Enums.TargetType
  }

  export type EnumInquiryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryType | EnumInquiryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryType[] | ListEnumInquiryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryType[] | ListEnumInquiryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryTypeFilter<$PrismaModel> | $Enums.InquiryType
  }

  export type EnumInquiryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryStatus | EnumInquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryStatusFilter<$PrismaModel> | $Enums.InquiryStatus
  }

  export type EnumInquiryPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryPriority | EnumInquiryPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryPriority[] | ListEnumInquiryPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryPriority[] | ListEnumInquiryPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryPriorityFilter<$PrismaModel> | $Enums.InquiryPriority
  }

  export type PropertyNullableScalarRelationFilter = {
    is?: PropertyWhereInput | null
    isNot?: PropertyWhereInput | null
  }

  export type InquiryMessageListRelationFilter = {
    every?: InquiryMessageWhereInput
    some?: InquiryMessageWhereInput
    none?: InquiryMessageWhereInput
  }

  export type InquiryMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InquiryCountOrderByAggregateInput = {
    id?: SortOrder
    inquiryNumber?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    name?: SortOrder
    furigana?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    companyName?: SortOrder
    inquiryType?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    userId?: SortOrder
    assignedAgentId?: SortOrder
    assignedAt?: SortOrder
    responseCount?: SortOrder
    lastRespondedAt?: SortOrder
    closedAt?: SortOrder
    closedReason?: SortOrder
    source?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InquiryAvgOrderByAggregateInput = {
    responseCount?: SortOrder
  }

  export type InquiryMaxOrderByAggregateInput = {
    id?: SortOrder
    inquiryNumber?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    name?: SortOrder
    furigana?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    companyName?: SortOrder
    inquiryType?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    userId?: SortOrder
    assignedAgentId?: SortOrder
    assignedAt?: SortOrder
    responseCount?: SortOrder
    lastRespondedAt?: SortOrder
    closedAt?: SortOrder
    closedReason?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InquiryMinOrderByAggregateInput = {
    id?: SortOrder
    inquiryNumber?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    name?: SortOrder
    furigana?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    companyName?: SortOrder
    inquiryType?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    userId?: SortOrder
    assignedAgentId?: SortOrder
    assignedAt?: SortOrder
    responseCount?: SortOrder
    lastRespondedAt?: SortOrder
    closedAt?: SortOrder
    closedReason?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InquirySumOrderByAggregateInput = {
    responseCount?: SortOrder
  }

  export type EnumTargetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TargetType | EnumTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TargetType[] | ListEnumTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TargetType[] | ListEnumTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTargetTypeWithAggregatesFilter<$PrismaModel> | $Enums.TargetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTargetTypeFilter<$PrismaModel>
    _max?: NestedEnumTargetTypeFilter<$PrismaModel>
  }

  export type EnumInquiryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryType | EnumInquiryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryType[] | ListEnumInquiryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryType[] | ListEnumInquiryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryTypeWithAggregatesFilter<$PrismaModel> | $Enums.InquiryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInquiryTypeFilter<$PrismaModel>
    _max?: NestedEnumInquiryTypeFilter<$PrismaModel>
  }

  export type EnumInquiryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryStatus | EnumInquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InquiryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInquiryStatusFilter<$PrismaModel>
    _max?: NestedEnumInquiryStatusFilter<$PrismaModel>
  }

  export type EnumInquiryPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryPriority | EnumInquiryPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryPriority[] | ListEnumInquiryPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryPriority[] | ListEnumInquiryPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryPriorityWithAggregatesFilter<$PrismaModel> | $Enums.InquiryPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInquiryPriorityFilter<$PrismaModel>
    _max?: NestedEnumInquiryPriorityFilter<$PrismaModel>
  }

  export type EnumSenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeFilter<$PrismaModel> | $Enums.SenderType
  }

  export type InquiryScalarRelationFilter = {
    is?: InquiryWhereInput
    isNot?: InquiryWhereInput
  }

  export type InquiryMessageCountOrderByAggregateInput = {
    id?: SortOrder
    inquiryId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    message?: SortOrder
    attachments?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
  }

  export type InquiryMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    inquiryId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    message?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
  }

  export type InquiryMessageMinOrderByAggregateInput = {
    id?: SortOrder
    inquiryId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    message?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.SenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSenderTypeFilter<$PrismaModel>
    _max?: NestedEnumSenderTypeFilter<$PrismaModel>
  }

  export type EnumAssessmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentStatus | EnumAssessmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssessmentStatus[] | ListEnumAssessmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssessmentStatus[] | ListEnumAssessmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssessmentStatusFilter<$PrismaModel> | $Enums.AssessmentStatus
  }

  export type BulkAssessmentCountOrderByAggregateInput = {
    id?: SortOrder
    assessmentNumber?: SortOrder
    propertyAddress?: SortOrder
    propertyTypeId?: SortOrder
    buildingArea?: SortOrder
    landArea?: SortOrder
    constructionYear?: SortOrder
    ownerName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    preferredContactMethod?: SortOrder
    preferredContactTime?: SortOrder
    status?: SortOrder
    agentCount?: SortOrder
    responseCount?: SortOrder
    userId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type BulkAssessmentAvgOrderByAggregateInput = {
    buildingArea?: SortOrder
    landArea?: SortOrder
    constructionYear?: SortOrder
    agentCount?: SortOrder
    responseCount?: SortOrder
  }

  export type BulkAssessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    assessmentNumber?: SortOrder
    propertyAddress?: SortOrder
    propertyTypeId?: SortOrder
    buildingArea?: SortOrder
    landArea?: SortOrder
    constructionYear?: SortOrder
    ownerName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    preferredContactMethod?: SortOrder
    preferredContactTime?: SortOrder
    status?: SortOrder
    agentCount?: SortOrder
    responseCount?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type BulkAssessmentMinOrderByAggregateInput = {
    id?: SortOrder
    assessmentNumber?: SortOrder
    propertyAddress?: SortOrder
    propertyTypeId?: SortOrder
    buildingArea?: SortOrder
    landArea?: SortOrder
    constructionYear?: SortOrder
    ownerName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    preferredContactMethod?: SortOrder
    preferredContactTime?: SortOrder
    status?: SortOrder
    agentCount?: SortOrder
    responseCount?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type BulkAssessmentSumOrderByAggregateInput = {
    buildingArea?: SortOrder
    landArea?: SortOrder
    constructionYear?: SortOrder
    agentCount?: SortOrder
    responseCount?: SortOrder
  }

  export type EnumAssessmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentStatus | EnumAssessmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssessmentStatus[] | ListEnumAssessmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssessmentStatus[] | ListEnumAssessmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssessmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssessmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssessmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAssessmentStatusFilter<$PrismaModel>
  }

  export type EnumResponseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ResponseStatus | EnumResponseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ResponseStatus[] | ListEnumResponseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResponseStatus[] | ListEnumResponseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumResponseStatusFilter<$PrismaModel> | $Enums.ResponseStatus
  }

  export type BulkAssessmentScalarRelationFilter = {
    is?: BulkAssessmentWhereInput
    isNot?: BulkAssessmentWhereInput
  }

  export type AgentScalarRelationFilter = {
    is?: AgentWhereInput
    isNot?: AgentWhereInput
  }

  export type BulkAssessmentResponseCountOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    agentId?: SortOrder
    assessedPrice?: SortOrder
    priceRangeMin?: SortOrder
    priceRangeMax?: SortOrder
    comments?: SortOrder
    proposalDocument?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    viewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BulkAssessmentResponseAvgOrderByAggregateInput = {
    assessedPrice?: SortOrder
    priceRangeMin?: SortOrder
    priceRangeMax?: SortOrder
  }

  export type BulkAssessmentResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    agentId?: SortOrder
    assessedPrice?: SortOrder
    priceRangeMin?: SortOrder
    priceRangeMax?: SortOrder
    comments?: SortOrder
    proposalDocument?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    viewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BulkAssessmentResponseMinOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    agentId?: SortOrder
    assessedPrice?: SortOrder
    priceRangeMin?: SortOrder
    priceRangeMax?: SortOrder
    comments?: SortOrder
    proposalDocument?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    viewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BulkAssessmentResponseSumOrderByAggregateInput = {
    assessedPrice?: SortOrder
    priceRangeMin?: SortOrder
    priceRangeMax?: SortOrder
  }

  export type EnumResponseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResponseStatus | EnumResponseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ResponseStatus[] | ListEnumResponseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResponseStatus[] | ListEnumResponseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumResponseStatusWithAggregatesFilter<$PrismaModel> | $Enums.ResponseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResponseStatusFilter<$PrismaModel>
    _max?: NestedEnumResponseStatusFilter<$PrismaModel>
  }

  export type EnumQuestionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionStatus | EnumQuestionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionStatusFilter<$PrismaModel> | $Enums.QuestionStatus
  }

  export type QuestionCategoryNullableScalarRelationFilter = {
    is?: QuestionCategoryWhereInput | null
    isNot?: QuestionCategoryWhereInput | null
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    questionNumber?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    tags?: SortOrder
    viewCount?: SortOrder
    answerCount?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    bestAnswerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuestionAvgOrderByAggregateInput = {
    viewCount?: SortOrder
    answerCount?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    questionNumber?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    viewCount?: SortOrder
    answerCount?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    bestAnswerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    questionNumber?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    viewCount?: SortOrder
    answerCount?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    bestAnswerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuestionSumOrderByAggregateInput = {
    viewCount?: SortOrder
    answerCount?: SortOrder
  }

  export type EnumQuestionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionStatus | EnumQuestionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuestionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionStatusFilter<$PrismaModel>
    _max?: NestedEnumQuestionStatusFilter<$PrismaModel>
  }

  export type QuestionScalarRelationFilter = {
    is?: QuestionWhereInput
    isNot?: QuestionWhereInput
  }

  export type AnswerCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    content?: SortOrder
    goodCount?: SortOrder
    isBestAnswer?: SortOrder
    authorId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AnswerAvgOrderByAggregateInput = {
    goodCount?: SortOrder
  }

  export type AnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    content?: SortOrder
    goodCount?: SortOrder
    isBestAnswer?: SortOrder
    authorId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AnswerMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    content?: SortOrder
    goodCount?: SortOrder
    isBestAnswer?: SortOrder
    authorId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AnswerSumOrderByAggregateInput = {
    goodCount?: SortOrder
  }

  export type EnumFeatureCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatureCategory | EnumFeatureCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeatureCategory[] | ListEnumFeatureCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatureCategory[] | ListEnumFeatureCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatureCategoryFilter<$PrismaModel> | $Enums.FeatureCategory
  }

  export type FeatureMasterCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type FeatureMasterAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type FeatureMasterMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type FeatureMasterMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type FeatureMasterSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type EnumFeatureCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatureCategory | EnumFeatureCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeatureCategory[] | ListEnumFeatureCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatureCategory[] | ListEnumFeatureCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatureCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FeatureCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeatureCategoryFilter<$PrismaModel>
    _max?: NestedEnumFeatureCategoryFilter<$PrismaModel>
  }

  export type AreaMasterListRelationFilter = {
    every?: AreaMasterWhereInput
    some?: AreaMasterWhereInput
    none?: AreaMasterWhereInput
  }

  export type AreaMasterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionMasterCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type RegionMasterAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type RegionMasterMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type RegionMasterMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type RegionMasterSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type RegionMasterNullableScalarRelationFilter = {
    is?: RegionMasterWhereInput | null
    isNot?: RegionMasterWhereInput | null
  }

  export type AreaMasterPrefectureCityCompoundUniqueInput = {
    prefecture: string
    city: string
  }

  export type AreaMasterCountOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    prefectureCode?: SortOrder
    prefecture?: SortOrder
    cityCode?: SortOrder
    city?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type AreaMasterAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type AreaMasterMaxOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    prefectureCode?: SortOrder
    prefecture?: SortOrder
    cityCode?: SortOrder
    city?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type AreaMasterMinOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    prefectureCode?: SortOrder
    prefecture?: SortOrder
    cityCode?: SortOrder
    city?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type AreaMasterSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type PropertyTypeMasterCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type PropertyTypeMasterAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type PropertyTypeMasterMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type PropertyTypeMasterMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type PropertyTypeMasterSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type PropertyCategoryMasterCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type PropertyCategoryMasterAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type PropertyCategoryMasterMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type PropertyCategoryMasterMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type PropertyCategoryMasterSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type FloorPlanMasterCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    roomCount?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type FloorPlanMasterAvgOrderByAggregateInput = {
    roomCount?: SortOrder
    displayOrder?: SortOrder
  }

  export type FloorPlanMasterMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    roomCount?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type FloorPlanMasterMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    roomCount?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type FloorPlanMasterSumOrderByAggregateInput = {
    roomCount?: SortOrder
    displayOrder?: SortOrder
  }

  export type StationListRelationFilter = {
    every?: StationWhereInput
    some?: StationWhereInput
    none?: StationWhereInput
  }

  export type StationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RouteMasterCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    companyName?: SortOrder
    lineColor?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type RouteMasterAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type RouteMasterMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    companyName?: SortOrder
    lineColor?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type RouteMasterMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    companyName?: SortOrder
    lineColor?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type RouteMasterSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type RouteMasterNullableScalarRelationFilter = {
    is?: RouteMasterWhereInput | null
    isNot?: RouteMasterWhereInput | null
  }

  export type StationNameRouteIdCompoundUniqueInput = {
    name: string
    routeId: string
  }

  export type StationCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameKana?: SortOrder
    routeId?: SortOrder
    prefecture?: SortOrder
    city?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type StationAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    displayOrder?: SortOrder
  }

  export type StationMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameKana?: SortOrder
    routeId?: SortOrder
    prefecture?: SortOrder
    city?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type StationMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameKana?: SortOrder
    routeId?: SortOrder
    prefecture?: SortOrder
    city?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type StationSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    displayOrder?: SortOrder
  }

  export type QuestionCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type QuestionCategoryAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type QuestionCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type QuestionCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type QuestionCategorySumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type EnumMailStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MailStatus | EnumMailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MailStatus[] | ListEnumMailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailStatus[] | ListEnumMailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMailStatusFilter<$PrismaModel> | $Enums.MailStatus
  }

  export type EnumMailTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MailType | EnumMailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MailType[] | ListEnumMailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailType[] | ListEnumMailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMailTypeFilter<$PrismaModel> | $Enums.MailType
  }

  export type MailCountOrderByAggregateInput = {
    id?: SortOrder
    fromEmail?: SortOrder
    fromName?: SortOrder
    toEmail?: SortOrder
    toName?: SortOrder
    ccEmail?: SortOrder
    bccEmail?: SortOrder
    subject?: SortOrder
    bodyText?: SortOrder
    bodyHtml?: SortOrder
    status?: SortOrder
    mailType?: SortOrder
    templateCode?: SortOrder
    templateVariables?: SortOrder
    errorMessage?: SortOrder
    userId?: SortOrder
    retryCount?: SortOrder
    scheduledAt?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MailAvgOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type MailMaxOrderByAggregateInput = {
    id?: SortOrder
    fromEmail?: SortOrder
    fromName?: SortOrder
    toEmail?: SortOrder
    toName?: SortOrder
    subject?: SortOrder
    bodyText?: SortOrder
    bodyHtml?: SortOrder
    status?: SortOrder
    mailType?: SortOrder
    templateCode?: SortOrder
    errorMessage?: SortOrder
    userId?: SortOrder
    retryCount?: SortOrder
    scheduledAt?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MailMinOrderByAggregateInput = {
    id?: SortOrder
    fromEmail?: SortOrder
    fromName?: SortOrder
    toEmail?: SortOrder
    toName?: SortOrder
    subject?: SortOrder
    bodyText?: SortOrder
    bodyHtml?: SortOrder
    status?: SortOrder
    mailType?: SortOrder
    templateCode?: SortOrder
    errorMessage?: SortOrder
    userId?: SortOrder
    retryCount?: SortOrder
    scheduledAt?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MailSumOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type EnumMailStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MailStatus | EnumMailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MailStatus[] | ListEnumMailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailStatus[] | ListEnumMailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMailStatusWithAggregatesFilter<$PrismaModel> | $Enums.MailStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMailStatusFilter<$PrismaModel>
    _max?: NestedEnumMailStatusFilter<$PrismaModel>
  }

  export type EnumMailTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MailType | EnumMailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MailType[] | ListEnumMailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailType[] | ListEnumMailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMailTypeWithAggregatesFilter<$PrismaModel> | $Enums.MailType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMailTypeFilter<$PrismaModel>
    _max?: NestedEnumMailTypeFilter<$PrismaModel>
  }

  export type FileBoxCountOrderByAggregateInput = {
    id?: SortOrder
    bucketName?: SortOrder
    storagePath?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    publicUrl?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    category?: SortOrder
    metadata?: SortOrder
    userId?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FileBoxAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type FileBoxMaxOrderByAggregateInput = {
    id?: SortOrder
    bucketName?: SortOrder
    storagePath?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    publicUrl?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    category?: SortOrder
    userId?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FileBoxMinOrderByAggregateInput = {
    id?: SortOrder
    bucketName?: SortOrder
    storagePath?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    publicUrl?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    category?: SortOrder
    userId?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FileBoxSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SystemSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    valueType?: SortOrder
    category?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    valueType?: SortOrder
    category?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    valueType?: SortOrder
    category?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    oldData?: SortOrder
    newData?: SortOrder
    changedFields?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    linkUrl?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    linkUrl?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    linkUrl?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type AgentCreateNestedOneWithoutUserInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    connect?: AgentWhereUniqueInput
  }

  export type PropertyCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type InquiryCreateNestedManyWithoutUserInput = {
    create?: XOR<InquiryCreateWithoutUserInput, InquiryUncheckedCreateWithoutUserInput> | InquiryCreateWithoutUserInput[] | InquiryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutUserInput | InquiryCreateOrConnectWithoutUserInput[]
    createMany?: InquiryCreateManyUserInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type FavoriteCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type PropertyViewCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyViewCreateWithoutUserInput, PropertyViewUncheckedCreateWithoutUserInput> | PropertyViewCreateWithoutUserInput[] | PropertyViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutUserInput | PropertyViewCreateOrConnectWithoutUserInput[]
    createMany?: PropertyViewCreateManyUserInputEnvelope
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
  }

  export type QuestionCreateNestedManyWithoutAuthorInput = {
    create?: XOR<QuestionCreateWithoutAuthorInput, QuestionUncheckedCreateWithoutAuthorInput> | QuestionCreateWithoutAuthorInput[] | QuestionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutAuthorInput | QuestionCreateOrConnectWithoutAuthorInput[]
    createMany?: QuestionCreateManyAuthorInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type AnswerCreateNestedManyWithoutAuthorInput = {
    create?: XOR<AnswerCreateWithoutAuthorInput, AnswerUncheckedCreateWithoutAuthorInput> | AnswerCreateWithoutAuthorInput[] | AnswerUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutAuthorInput | AnswerCreateOrConnectWithoutAuthorInput[]
    createMany?: AnswerCreateManyAuthorInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type BulkAssessmentCreateNestedManyWithoutUserInput = {
    create?: XOR<BulkAssessmentCreateWithoutUserInput, BulkAssessmentUncheckedCreateWithoutUserInput> | BulkAssessmentCreateWithoutUserInput[] | BulkAssessmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BulkAssessmentCreateOrConnectWithoutUserInput | BulkAssessmentCreateOrConnectWithoutUserInput[]
    createMany?: BulkAssessmentCreateManyUserInputEnvelope
    connect?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
  }

  export type MailCreateNestedManyWithoutUserInput = {
    create?: XOR<MailCreateWithoutUserInput, MailUncheckedCreateWithoutUserInput> | MailCreateWithoutUserInput[] | MailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MailCreateOrConnectWithoutUserInput | MailCreateOrConnectWithoutUserInput[]
    createMany?: MailCreateManyUserInputEnvelope
    connect?: MailWhereUniqueInput | MailWhereUniqueInput[]
  }

  export type FileBoxCreateNestedManyWithoutUserInput = {
    create?: XOR<FileBoxCreateWithoutUserInput, FileBoxUncheckedCreateWithoutUserInput> | FileBoxCreateWithoutUserInput[] | FileBoxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileBoxCreateOrConnectWithoutUserInput | FileBoxCreateOrConnectWithoutUserInput[]
    createMany?: FileBoxCreateManyUserInputEnvelope
    connect?: FileBoxWhereUniqueInput | FileBoxWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SystemSettingCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<SystemSettingCreateWithoutUpdatedByInput, SystemSettingUncheckedCreateWithoutUpdatedByInput> | SystemSettingCreateWithoutUpdatedByInput[] | SystemSettingUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SystemSettingCreateOrConnectWithoutUpdatedByInput | SystemSettingCreateOrConnectWithoutUpdatedByInput[]
    createMany?: SystemSettingCreateManyUpdatedByInputEnvelope
    connect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type PropertyPriceHistoryCreateNestedManyWithoutChangedByInput = {
    create?: XOR<PropertyPriceHistoryCreateWithoutChangedByInput, PropertyPriceHistoryUncheckedCreateWithoutChangedByInput> | PropertyPriceHistoryCreateWithoutChangedByInput[] | PropertyPriceHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: PropertyPriceHistoryCreateOrConnectWithoutChangedByInput | PropertyPriceHistoryCreateOrConnectWithoutChangedByInput[]
    createMany?: PropertyPriceHistoryCreateManyChangedByInputEnvelope
    connect?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
  }

  export type PropertyStatusHistoryCreateNestedManyWithoutChangedByInput = {
    create?: XOR<PropertyStatusHistoryCreateWithoutChangedByInput, PropertyStatusHistoryUncheckedCreateWithoutChangedByInput> | PropertyStatusHistoryCreateWithoutChangedByInput[] | PropertyStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: PropertyStatusHistoryCreateOrConnectWithoutChangedByInput | PropertyStatusHistoryCreateOrConnectWithoutChangedByInput[]
    createMany?: PropertyStatusHistoryCreateManyChangedByInputEnvelope
    connect?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    connect?: AgentWhereUniqueInput
  }

  export type PropertyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type InquiryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InquiryCreateWithoutUserInput, InquiryUncheckedCreateWithoutUserInput> | InquiryCreateWithoutUserInput[] | InquiryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutUserInput | InquiryCreateOrConnectWithoutUserInput[]
    createMany?: InquiryCreateManyUserInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type PropertyViewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyViewCreateWithoutUserInput, PropertyViewUncheckedCreateWithoutUserInput> | PropertyViewCreateWithoutUserInput[] | PropertyViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutUserInput | PropertyViewCreateOrConnectWithoutUserInput[]
    createMany?: PropertyViewCreateManyUserInputEnvelope
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<QuestionCreateWithoutAuthorInput, QuestionUncheckedCreateWithoutAuthorInput> | QuestionCreateWithoutAuthorInput[] | QuestionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutAuthorInput | QuestionCreateOrConnectWithoutAuthorInput[]
    createMany?: QuestionCreateManyAuthorInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type AnswerUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<AnswerCreateWithoutAuthorInput, AnswerUncheckedCreateWithoutAuthorInput> | AnswerCreateWithoutAuthorInput[] | AnswerUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutAuthorInput | AnswerCreateOrConnectWithoutAuthorInput[]
    createMany?: AnswerCreateManyAuthorInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type BulkAssessmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BulkAssessmentCreateWithoutUserInput, BulkAssessmentUncheckedCreateWithoutUserInput> | BulkAssessmentCreateWithoutUserInput[] | BulkAssessmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BulkAssessmentCreateOrConnectWithoutUserInput | BulkAssessmentCreateOrConnectWithoutUserInput[]
    createMany?: BulkAssessmentCreateManyUserInputEnvelope
    connect?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
  }

  export type MailUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MailCreateWithoutUserInput, MailUncheckedCreateWithoutUserInput> | MailCreateWithoutUserInput[] | MailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MailCreateOrConnectWithoutUserInput | MailCreateOrConnectWithoutUserInput[]
    createMany?: MailCreateManyUserInputEnvelope
    connect?: MailWhereUniqueInput | MailWhereUniqueInput[]
  }

  export type FileBoxUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FileBoxCreateWithoutUserInput, FileBoxUncheckedCreateWithoutUserInput> | FileBoxCreateWithoutUserInput[] | FileBoxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileBoxCreateOrConnectWithoutUserInput | FileBoxCreateOrConnectWithoutUserInput[]
    createMany?: FileBoxCreateManyUserInputEnvelope
    connect?: FileBoxWhereUniqueInput | FileBoxWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SystemSettingUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<SystemSettingCreateWithoutUpdatedByInput, SystemSettingUncheckedCreateWithoutUpdatedByInput> | SystemSettingCreateWithoutUpdatedByInput[] | SystemSettingUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SystemSettingCreateOrConnectWithoutUpdatedByInput | SystemSettingCreateOrConnectWithoutUpdatedByInput[]
    createMany?: SystemSettingCreateManyUpdatedByInputEnvelope
    connect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type PropertyPriceHistoryUncheckedCreateNestedManyWithoutChangedByInput = {
    create?: XOR<PropertyPriceHistoryCreateWithoutChangedByInput, PropertyPriceHistoryUncheckedCreateWithoutChangedByInput> | PropertyPriceHistoryCreateWithoutChangedByInput[] | PropertyPriceHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: PropertyPriceHistoryCreateOrConnectWithoutChangedByInput | PropertyPriceHistoryCreateOrConnectWithoutChangedByInput[]
    createMany?: PropertyPriceHistoryCreateManyChangedByInputEnvelope
    connect?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
  }

  export type PropertyStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput = {
    create?: XOR<PropertyStatusHistoryCreateWithoutChangedByInput, PropertyStatusHistoryUncheckedCreateWithoutChangedByInput> | PropertyStatusHistoryCreateWithoutChangedByInput[] | PropertyStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: PropertyStatusHistoryCreateOrConnectWithoutChangedByInput | PropertyStatusHistoryCreateOrConnectWithoutChangedByInput[]
    createMany?: PropertyStatusHistoryCreateManyChangedByInputEnvelope
    connect?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type AgentUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    upsert?: AgentUpsertWithoutUserInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutUserInput, AgentUpdateWithoutUserInput>, AgentUncheckedUpdateWithoutUserInput>
  }

  export type PropertyUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutUserInput | PropertyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutUserInput | PropertyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutUserInput | PropertyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type InquiryUpdateManyWithoutUserNestedInput = {
    create?: XOR<InquiryCreateWithoutUserInput, InquiryUncheckedCreateWithoutUserInput> | InquiryCreateWithoutUserInput[] | InquiryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutUserInput | InquiryCreateOrConnectWithoutUserInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutUserInput | InquiryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InquiryCreateManyUserInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutUserInput | InquiryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutUserInput | InquiryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type FavoriteUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUserInput | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUserInput | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUserInput | FavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type PropertyViewUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyViewCreateWithoutUserInput, PropertyViewUncheckedCreateWithoutUserInput> | PropertyViewCreateWithoutUserInput[] | PropertyViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutUserInput | PropertyViewCreateOrConnectWithoutUserInput[]
    upsert?: PropertyViewUpsertWithWhereUniqueWithoutUserInput | PropertyViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyViewCreateManyUserInputEnvelope
    set?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    disconnect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    delete?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    update?: PropertyViewUpdateWithWhereUniqueWithoutUserInput | PropertyViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyViewUpdateManyWithWhereWithoutUserInput | PropertyViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
  }

  export type QuestionUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<QuestionCreateWithoutAuthorInput, QuestionUncheckedCreateWithoutAuthorInput> | QuestionCreateWithoutAuthorInput[] | QuestionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutAuthorInput | QuestionCreateOrConnectWithoutAuthorInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutAuthorInput | QuestionUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: QuestionCreateManyAuthorInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutAuthorInput | QuestionUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutAuthorInput | QuestionUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type AnswerUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<AnswerCreateWithoutAuthorInput, AnswerUncheckedCreateWithoutAuthorInput> | AnswerCreateWithoutAuthorInput[] | AnswerUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutAuthorInput | AnswerCreateOrConnectWithoutAuthorInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutAuthorInput | AnswerUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: AnswerCreateManyAuthorInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutAuthorInput | AnswerUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutAuthorInput | AnswerUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type BulkAssessmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<BulkAssessmentCreateWithoutUserInput, BulkAssessmentUncheckedCreateWithoutUserInput> | BulkAssessmentCreateWithoutUserInput[] | BulkAssessmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BulkAssessmentCreateOrConnectWithoutUserInput | BulkAssessmentCreateOrConnectWithoutUserInput[]
    upsert?: BulkAssessmentUpsertWithWhereUniqueWithoutUserInput | BulkAssessmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BulkAssessmentCreateManyUserInputEnvelope
    set?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
    disconnect?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
    delete?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
    connect?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
    update?: BulkAssessmentUpdateWithWhereUniqueWithoutUserInput | BulkAssessmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BulkAssessmentUpdateManyWithWhereWithoutUserInput | BulkAssessmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BulkAssessmentScalarWhereInput | BulkAssessmentScalarWhereInput[]
  }

  export type MailUpdateManyWithoutUserNestedInput = {
    create?: XOR<MailCreateWithoutUserInput, MailUncheckedCreateWithoutUserInput> | MailCreateWithoutUserInput[] | MailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MailCreateOrConnectWithoutUserInput | MailCreateOrConnectWithoutUserInput[]
    upsert?: MailUpsertWithWhereUniqueWithoutUserInput | MailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MailCreateManyUserInputEnvelope
    set?: MailWhereUniqueInput | MailWhereUniqueInput[]
    disconnect?: MailWhereUniqueInput | MailWhereUniqueInput[]
    delete?: MailWhereUniqueInput | MailWhereUniqueInput[]
    connect?: MailWhereUniqueInput | MailWhereUniqueInput[]
    update?: MailUpdateWithWhereUniqueWithoutUserInput | MailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MailUpdateManyWithWhereWithoutUserInput | MailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MailScalarWhereInput | MailScalarWhereInput[]
  }

  export type FileBoxUpdateManyWithoutUserNestedInput = {
    create?: XOR<FileBoxCreateWithoutUserInput, FileBoxUncheckedCreateWithoutUserInput> | FileBoxCreateWithoutUserInput[] | FileBoxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileBoxCreateOrConnectWithoutUserInput | FileBoxCreateOrConnectWithoutUserInput[]
    upsert?: FileBoxUpsertWithWhereUniqueWithoutUserInput | FileBoxUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FileBoxCreateManyUserInputEnvelope
    set?: FileBoxWhereUniqueInput | FileBoxWhereUniqueInput[]
    disconnect?: FileBoxWhereUniqueInput | FileBoxWhereUniqueInput[]
    delete?: FileBoxWhereUniqueInput | FileBoxWhereUniqueInput[]
    connect?: FileBoxWhereUniqueInput | FileBoxWhereUniqueInput[]
    update?: FileBoxUpdateWithWhereUniqueWithoutUserInput | FileBoxUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FileBoxUpdateManyWithWhereWithoutUserInput | FileBoxUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FileBoxScalarWhereInput | FileBoxScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SystemSettingUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<SystemSettingCreateWithoutUpdatedByInput, SystemSettingUncheckedCreateWithoutUpdatedByInput> | SystemSettingCreateWithoutUpdatedByInput[] | SystemSettingUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SystemSettingCreateOrConnectWithoutUpdatedByInput | SystemSettingCreateOrConnectWithoutUpdatedByInput[]
    upsert?: SystemSettingUpsertWithWhereUniqueWithoutUpdatedByInput | SystemSettingUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: SystemSettingCreateManyUpdatedByInputEnvelope
    set?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    disconnect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    delete?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    connect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    update?: SystemSettingUpdateWithWhereUniqueWithoutUpdatedByInput | SystemSettingUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: SystemSettingUpdateManyWithWhereWithoutUpdatedByInput | SystemSettingUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: SystemSettingScalarWhereInput | SystemSettingScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type PropertyPriceHistoryUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<PropertyPriceHistoryCreateWithoutChangedByInput, PropertyPriceHistoryUncheckedCreateWithoutChangedByInput> | PropertyPriceHistoryCreateWithoutChangedByInput[] | PropertyPriceHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: PropertyPriceHistoryCreateOrConnectWithoutChangedByInput | PropertyPriceHistoryCreateOrConnectWithoutChangedByInput[]
    upsert?: PropertyPriceHistoryUpsertWithWhereUniqueWithoutChangedByInput | PropertyPriceHistoryUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: PropertyPriceHistoryCreateManyChangedByInputEnvelope
    set?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
    disconnect?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
    delete?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
    connect?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
    update?: PropertyPriceHistoryUpdateWithWhereUniqueWithoutChangedByInput | PropertyPriceHistoryUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: PropertyPriceHistoryUpdateManyWithWhereWithoutChangedByInput | PropertyPriceHistoryUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: PropertyPriceHistoryScalarWhereInput | PropertyPriceHistoryScalarWhereInput[]
  }

  export type PropertyStatusHistoryUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<PropertyStatusHistoryCreateWithoutChangedByInput, PropertyStatusHistoryUncheckedCreateWithoutChangedByInput> | PropertyStatusHistoryCreateWithoutChangedByInput[] | PropertyStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: PropertyStatusHistoryCreateOrConnectWithoutChangedByInput | PropertyStatusHistoryCreateOrConnectWithoutChangedByInput[]
    upsert?: PropertyStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput | PropertyStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: PropertyStatusHistoryCreateManyChangedByInputEnvelope
    set?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
    disconnect?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
    delete?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
    connect?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
    update?: PropertyStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput | PropertyStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: PropertyStatusHistoryUpdateManyWithWhereWithoutChangedByInput | PropertyStatusHistoryUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: PropertyStatusHistoryScalarWhereInput | PropertyStatusHistoryScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type AgentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    upsert?: AgentUpsertWithoutUserInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutUserInput, AgentUpdateWithoutUserInput>, AgentUncheckedUpdateWithoutUserInput>
  }

  export type PropertyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutUserInput | PropertyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutUserInput | PropertyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutUserInput | PropertyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type InquiryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InquiryCreateWithoutUserInput, InquiryUncheckedCreateWithoutUserInput> | InquiryCreateWithoutUserInput[] | InquiryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutUserInput | InquiryCreateOrConnectWithoutUserInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutUserInput | InquiryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InquiryCreateManyUserInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutUserInput | InquiryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutUserInput | InquiryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUserInput | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUserInput | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUserInput | FavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type PropertyViewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyViewCreateWithoutUserInput, PropertyViewUncheckedCreateWithoutUserInput> | PropertyViewCreateWithoutUserInput[] | PropertyViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutUserInput | PropertyViewCreateOrConnectWithoutUserInput[]
    upsert?: PropertyViewUpsertWithWhereUniqueWithoutUserInput | PropertyViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyViewCreateManyUserInputEnvelope
    set?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    disconnect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    delete?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    update?: PropertyViewUpdateWithWhereUniqueWithoutUserInput | PropertyViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyViewUpdateManyWithWhereWithoutUserInput | PropertyViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<QuestionCreateWithoutAuthorInput, QuestionUncheckedCreateWithoutAuthorInput> | QuestionCreateWithoutAuthorInput[] | QuestionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutAuthorInput | QuestionCreateOrConnectWithoutAuthorInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutAuthorInput | QuestionUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: QuestionCreateManyAuthorInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutAuthorInput | QuestionUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutAuthorInput | QuestionUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type AnswerUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<AnswerCreateWithoutAuthorInput, AnswerUncheckedCreateWithoutAuthorInput> | AnswerCreateWithoutAuthorInput[] | AnswerUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutAuthorInput | AnswerCreateOrConnectWithoutAuthorInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutAuthorInput | AnswerUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: AnswerCreateManyAuthorInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutAuthorInput | AnswerUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutAuthorInput | AnswerUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type BulkAssessmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BulkAssessmentCreateWithoutUserInput, BulkAssessmentUncheckedCreateWithoutUserInput> | BulkAssessmentCreateWithoutUserInput[] | BulkAssessmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BulkAssessmentCreateOrConnectWithoutUserInput | BulkAssessmentCreateOrConnectWithoutUserInput[]
    upsert?: BulkAssessmentUpsertWithWhereUniqueWithoutUserInput | BulkAssessmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BulkAssessmentCreateManyUserInputEnvelope
    set?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
    disconnect?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
    delete?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
    connect?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
    update?: BulkAssessmentUpdateWithWhereUniqueWithoutUserInput | BulkAssessmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BulkAssessmentUpdateManyWithWhereWithoutUserInput | BulkAssessmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BulkAssessmentScalarWhereInput | BulkAssessmentScalarWhereInput[]
  }

  export type MailUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MailCreateWithoutUserInput, MailUncheckedCreateWithoutUserInput> | MailCreateWithoutUserInput[] | MailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MailCreateOrConnectWithoutUserInput | MailCreateOrConnectWithoutUserInput[]
    upsert?: MailUpsertWithWhereUniqueWithoutUserInput | MailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MailCreateManyUserInputEnvelope
    set?: MailWhereUniqueInput | MailWhereUniqueInput[]
    disconnect?: MailWhereUniqueInput | MailWhereUniqueInput[]
    delete?: MailWhereUniqueInput | MailWhereUniqueInput[]
    connect?: MailWhereUniqueInput | MailWhereUniqueInput[]
    update?: MailUpdateWithWhereUniqueWithoutUserInput | MailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MailUpdateManyWithWhereWithoutUserInput | MailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MailScalarWhereInput | MailScalarWhereInput[]
  }

  export type FileBoxUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FileBoxCreateWithoutUserInput, FileBoxUncheckedCreateWithoutUserInput> | FileBoxCreateWithoutUserInput[] | FileBoxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileBoxCreateOrConnectWithoutUserInput | FileBoxCreateOrConnectWithoutUserInput[]
    upsert?: FileBoxUpsertWithWhereUniqueWithoutUserInput | FileBoxUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FileBoxCreateManyUserInputEnvelope
    set?: FileBoxWhereUniqueInput | FileBoxWhereUniqueInput[]
    disconnect?: FileBoxWhereUniqueInput | FileBoxWhereUniqueInput[]
    delete?: FileBoxWhereUniqueInput | FileBoxWhereUniqueInput[]
    connect?: FileBoxWhereUniqueInput | FileBoxWhereUniqueInput[]
    update?: FileBoxUpdateWithWhereUniqueWithoutUserInput | FileBoxUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FileBoxUpdateManyWithWhereWithoutUserInput | FileBoxUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FileBoxScalarWhereInput | FileBoxScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SystemSettingUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<SystemSettingCreateWithoutUpdatedByInput, SystemSettingUncheckedCreateWithoutUpdatedByInput> | SystemSettingCreateWithoutUpdatedByInput[] | SystemSettingUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SystemSettingCreateOrConnectWithoutUpdatedByInput | SystemSettingCreateOrConnectWithoutUpdatedByInput[]
    upsert?: SystemSettingUpsertWithWhereUniqueWithoutUpdatedByInput | SystemSettingUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: SystemSettingCreateManyUpdatedByInputEnvelope
    set?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    disconnect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    delete?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    connect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    update?: SystemSettingUpdateWithWhereUniqueWithoutUpdatedByInput | SystemSettingUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: SystemSettingUpdateManyWithWhereWithoutUpdatedByInput | SystemSettingUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: SystemSettingScalarWhereInput | SystemSettingScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<PropertyPriceHistoryCreateWithoutChangedByInput, PropertyPriceHistoryUncheckedCreateWithoutChangedByInput> | PropertyPriceHistoryCreateWithoutChangedByInput[] | PropertyPriceHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: PropertyPriceHistoryCreateOrConnectWithoutChangedByInput | PropertyPriceHistoryCreateOrConnectWithoutChangedByInput[]
    upsert?: PropertyPriceHistoryUpsertWithWhereUniqueWithoutChangedByInput | PropertyPriceHistoryUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: PropertyPriceHistoryCreateManyChangedByInputEnvelope
    set?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
    disconnect?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
    delete?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
    connect?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
    update?: PropertyPriceHistoryUpdateWithWhereUniqueWithoutChangedByInput | PropertyPriceHistoryUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: PropertyPriceHistoryUpdateManyWithWhereWithoutChangedByInput | PropertyPriceHistoryUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: PropertyPriceHistoryScalarWhereInput | PropertyPriceHistoryScalarWhereInput[]
  }

  export type PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<PropertyStatusHistoryCreateWithoutChangedByInput, PropertyStatusHistoryUncheckedCreateWithoutChangedByInput> | PropertyStatusHistoryCreateWithoutChangedByInput[] | PropertyStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: PropertyStatusHistoryCreateOrConnectWithoutChangedByInput | PropertyStatusHistoryCreateOrConnectWithoutChangedByInput[]
    upsert?: PropertyStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput | PropertyStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: PropertyStatusHistoryCreateManyChangedByInputEnvelope
    set?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
    disconnect?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
    delete?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
    connect?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
    update?: PropertyStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput | PropertyStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: PropertyStatusHistoryUpdateManyWithWhereWithoutChangedByInput | PropertyStatusHistoryUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: PropertyStatusHistoryScalarWhereInput | PropertyStatusHistoryScalarWhereInput[]
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    upsert?: UserUpsertWithoutUserRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserRolesInput, UserUpdateWithoutUserRolesInput>, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    upsert?: RoleUpsertWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserRolesInput, RoleUpdateWithoutUserRolesInput>, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type BranchCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BranchCreateWithoutCompanyInput, BranchUncheckedCreateWithoutCompanyInput> | BranchCreateWithoutCompanyInput[] | BranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutCompanyInput | BranchCreateOrConnectWithoutCompanyInput[]
    createMany?: BranchCreateManyCompanyInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type BranchUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BranchCreateWithoutCompanyInput, BranchUncheckedCreateWithoutCompanyInput> | BranchCreateWithoutCompanyInput[] | BranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutCompanyInput | BranchCreateOrConnectWithoutCompanyInput[]
    createMany?: BranchCreateManyCompanyInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type EnumCompanyStatusFieldUpdateOperationsInput = {
    set?: $Enums.CompanyStatus
  }

  export type BranchUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BranchCreateWithoutCompanyInput, BranchUncheckedCreateWithoutCompanyInput> | BranchCreateWithoutCompanyInput[] | BranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutCompanyInput | BranchCreateOrConnectWithoutCompanyInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutCompanyInput | BranchUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BranchCreateManyCompanyInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutCompanyInput | BranchUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutCompanyInput | BranchUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type BranchUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BranchCreateWithoutCompanyInput, BranchUncheckedCreateWithoutCompanyInput> | BranchCreateWithoutCompanyInput[] | BranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutCompanyInput | BranchCreateOrConnectWithoutCompanyInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutCompanyInput | BranchUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BranchCreateManyCompanyInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutCompanyInput | BranchUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutCompanyInput | BranchUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutBranchesInput = {
    create?: XOR<CompanyCreateWithoutBranchesInput, CompanyUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBranchesInput
    connect?: CompanyWhereUniqueInput
  }

  export type AgentCreateNestedManyWithoutBranchInput = {
    create?: XOR<AgentCreateWithoutBranchInput, AgentUncheckedCreateWithoutBranchInput> | AgentCreateWithoutBranchInput[] | AgentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutBranchInput | AgentCreateOrConnectWithoutBranchInput[]
    createMany?: AgentCreateManyBranchInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<AgentCreateWithoutBranchInput, AgentUncheckedCreateWithoutBranchInput> | AgentCreateWithoutBranchInput[] | AgentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutBranchInput | AgentCreateOrConnectWithoutBranchInput[]
    createMany?: AgentCreateManyBranchInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CompanyUpdateOneRequiredWithoutBranchesNestedInput = {
    create?: XOR<CompanyCreateWithoutBranchesInput, CompanyUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBranchesInput
    upsert?: CompanyUpsertWithoutBranchesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutBranchesInput, CompanyUpdateWithoutBranchesInput>, CompanyUncheckedUpdateWithoutBranchesInput>
  }

  export type AgentUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AgentCreateWithoutBranchInput, AgentUncheckedCreateWithoutBranchInput> | AgentCreateWithoutBranchInput[] | AgentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutBranchInput | AgentCreateOrConnectWithoutBranchInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutBranchInput | AgentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AgentCreateManyBranchInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutBranchInput | AgentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutBranchInput | AgentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type AgentUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AgentCreateWithoutBranchInput, AgentUncheckedCreateWithoutBranchInput> | AgentCreateWithoutBranchInput[] | AgentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutBranchInput | AgentCreateOrConnectWithoutBranchInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutBranchInput | AgentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AgentCreateManyBranchInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutBranchInput | AgentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutBranchInput | AgentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAgentInput = {
    create?: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutAgentsInput = {
    create?: XOR<BranchCreateWithoutAgentsInput, BranchUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAgentsInput
    connect?: BranchWhereUniqueInput
  }

  export type PropertyCreateNestedManyWithoutAgentInput = {
    create?: XOR<PropertyCreateWithoutAgentInput, PropertyUncheckedCreateWithoutAgentInput> | PropertyCreateWithoutAgentInput[] | PropertyUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutAgentInput | PropertyCreateOrConnectWithoutAgentInput[]
    createMany?: PropertyCreateManyAgentInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type InquiryCreateNestedManyWithoutAssignedAgentInput = {
    create?: XOR<InquiryCreateWithoutAssignedAgentInput, InquiryUncheckedCreateWithoutAssignedAgentInput> | InquiryCreateWithoutAssignedAgentInput[] | InquiryUncheckedCreateWithoutAssignedAgentInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutAssignedAgentInput | InquiryCreateOrConnectWithoutAssignedAgentInput[]
    createMany?: InquiryCreateManyAssignedAgentInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type AnswerCreateNestedManyWithoutAgentInput = {
    create?: XOR<AnswerCreateWithoutAgentInput, AnswerUncheckedCreateWithoutAgentInput> | AnswerCreateWithoutAgentInput[] | AnswerUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutAgentInput | AnswerCreateOrConnectWithoutAgentInput[]
    createMany?: AnswerCreateManyAgentInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type BulkAssessmentResponseCreateNestedManyWithoutAgentInput = {
    create?: XOR<BulkAssessmentResponseCreateWithoutAgentInput, BulkAssessmentResponseUncheckedCreateWithoutAgentInput> | BulkAssessmentResponseCreateWithoutAgentInput[] | BulkAssessmentResponseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: BulkAssessmentResponseCreateOrConnectWithoutAgentInput | BulkAssessmentResponseCreateOrConnectWithoutAgentInput[]
    createMany?: BulkAssessmentResponseCreateManyAgentInputEnvelope
    connect?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<PropertyCreateWithoutAgentInput, PropertyUncheckedCreateWithoutAgentInput> | PropertyCreateWithoutAgentInput[] | PropertyUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutAgentInput | PropertyCreateOrConnectWithoutAgentInput[]
    createMany?: PropertyCreateManyAgentInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type InquiryUncheckedCreateNestedManyWithoutAssignedAgentInput = {
    create?: XOR<InquiryCreateWithoutAssignedAgentInput, InquiryUncheckedCreateWithoutAssignedAgentInput> | InquiryCreateWithoutAssignedAgentInput[] | InquiryUncheckedCreateWithoutAssignedAgentInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutAssignedAgentInput | InquiryCreateOrConnectWithoutAssignedAgentInput[]
    createMany?: InquiryCreateManyAssignedAgentInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type AnswerUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AnswerCreateWithoutAgentInput, AnswerUncheckedCreateWithoutAgentInput> | AnswerCreateWithoutAgentInput[] | AnswerUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutAgentInput | AnswerCreateOrConnectWithoutAgentInput[]
    createMany?: AnswerCreateManyAgentInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type BulkAssessmentResponseUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<BulkAssessmentResponseCreateWithoutAgentInput, BulkAssessmentResponseUncheckedCreateWithoutAgentInput> | BulkAssessmentResponseCreateWithoutAgentInput[] | BulkAssessmentResponseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: BulkAssessmentResponseCreateOrConnectWithoutAgentInput | BulkAssessmentResponseCreateOrConnectWithoutAgentInput[]
    createMany?: BulkAssessmentResponseCreateManyAgentInputEnvelope
    connect?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAgentNestedInput = {
    create?: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentInput
    upsert?: UserUpsertWithoutAgentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgentInput, UserUpdateWithoutAgentInput>, UserUncheckedUpdateWithoutAgentInput>
  }

  export type BranchUpdateOneRequiredWithoutAgentsNestedInput = {
    create?: XOR<BranchCreateWithoutAgentsInput, BranchUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAgentsInput
    upsert?: BranchUpsertWithoutAgentsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutAgentsInput, BranchUpdateWithoutAgentsInput>, BranchUncheckedUpdateWithoutAgentsInput>
  }

  export type PropertyUpdateManyWithoutAgentNestedInput = {
    create?: XOR<PropertyCreateWithoutAgentInput, PropertyUncheckedCreateWithoutAgentInput> | PropertyCreateWithoutAgentInput[] | PropertyUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutAgentInput | PropertyCreateOrConnectWithoutAgentInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutAgentInput | PropertyUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: PropertyCreateManyAgentInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutAgentInput | PropertyUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutAgentInput | PropertyUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type InquiryUpdateManyWithoutAssignedAgentNestedInput = {
    create?: XOR<InquiryCreateWithoutAssignedAgentInput, InquiryUncheckedCreateWithoutAssignedAgentInput> | InquiryCreateWithoutAssignedAgentInput[] | InquiryUncheckedCreateWithoutAssignedAgentInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutAssignedAgentInput | InquiryCreateOrConnectWithoutAssignedAgentInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutAssignedAgentInput | InquiryUpsertWithWhereUniqueWithoutAssignedAgentInput[]
    createMany?: InquiryCreateManyAssignedAgentInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutAssignedAgentInput | InquiryUpdateWithWhereUniqueWithoutAssignedAgentInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutAssignedAgentInput | InquiryUpdateManyWithWhereWithoutAssignedAgentInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type AnswerUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AnswerCreateWithoutAgentInput, AnswerUncheckedCreateWithoutAgentInput> | AnswerCreateWithoutAgentInput[] | AnswerUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutAgentInput | AnswerCreateOrConnectWithoutAgentInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutAgentInput | AnswerUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AnswerCreateManyAgentInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutAgentInput | AnswerUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutAgentInput | AnswerUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type BulkAssessmentResponseUpdateManyWithoutAgentNestedInput = {
    create?: XOR<BulkAssessmentResponseCreateWithoutAgentInput, BulkAssessmentResponseUncheckedCreateWithoutAgentInput> | BulkAssessmentResponseCreateWithoutAgentInput[] | BulkAssessmentResponseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: BulkAssessmentResponseCreateOrConnectWithoutAgentInput | BulkAssessmentResponseCreateOrConnectWithoutAgentInput[]
    upsert?: BulkAssessmentResponseUpsertWithWhereUniqueWithoutAgentInput | BulkAssessmentResponseUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: BulkAssessmentResponseCreateManyAgentInputEnvelope
    set?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
    disconnect?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
    delete?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
    connect?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
    update?: BulkAssessmentResponseUpdateWithWhereUniqueWithoutAgentInput | BulkAssessmentResponseUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: BulkAssessmentResponseUpdateManyWithWhereWithoutAgentInput | BulkAssessmentResponseUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: BulkAssessmentResponseScalarWhereInput | BulkAssessmentResponseScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<PropertyCreateWithoutAgentInput, PropertyUncheckedCreateWithoutAgentInput> | PropertyCreateWithoutAgentInput[] | PropertyUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutAgentInput | PropertyCreateOrConnectWithoutAgentInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutAgentInput | PropertyUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: PropertyCreateManyAgentInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutAgentInput | PropertyUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutAgentInput | PropertyUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type InquiryUncheckedUpdateManyWithoutAssignedAgentNestedInput = {
    create?: XOR<InquiryCreateWithoutAssignedAgentInput, InquiryUncheckedCreateWithoutAssignedAgentInput> | InquiryCreateWithoutAssignedAgentInput[] | InquiryUncheckedCreateWithoutAssignedAgentInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutAssignedAgentInput | InquiryCreateOrConnectWithoutAssignedAgentInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutAssignedAgentInput | InquiryUpsertWithWhereUniqueWithoutAssignedAgentInput[]
    createMany?: InquiryCreateManyAssignedAgentInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutAssignedAgentInput | InquiryUpdateWithWhereUniqueWithoutAssignedAgentInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutAssignedAgentInput | InquiryUpdateManyWithWhereWithoutAssignedAgentInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type AnswerUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AnswerCreateWithoutAgentInput, AnswerUncheckedCreateWithoutAgentInput> | AnswerCreateWithoutAgentInput[] | AnswerUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutAgentInput | AnswerCreateOrConnectWithoutAgentInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutAgentInput | AnswerUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AnswerCreateManyAgentInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutAgentInput | AnswerUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutAgentInput | AnswerUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type BulkAssessmentResponseUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<BulkAssessmentResponseCreateWithoutAgentInput, BulkAssessmentResponseUncheckedCreateWithoutAgentInput> | BulkAssessmentResponseCreateWithoutAgentInput[] | BulkAssessmentResponseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: BulkAssessmentResponseCreateOrConnectWithoutAgentInput | BulkAssessmentResponseCreateOrConnectWithoutAgentInput[]
    upsert?: BulkAssessmentResponseUpsertWithWhereUniqueWithoutAgentInput | BulkAssessmentResponseUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: BulkAssessmentResponseCreateManyAgentInputEnvelope
    set?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
    disconnect?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
    delete?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
    connect?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
    update?: BulkAssessmentResponseUpdateWithWhereUniqueWithoutAgentInput | BulkAssessmentResponseUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: BulkAssessmentResponseUpdateManyWithWhereWithoutAgentInput | BulkAssessmentResponseUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: BulkAssessmentResponseScalarWhereInput | BulkAssessmentResponseScalarWhereInput[]
  }

  export type PropertyCreatefeatureTagsInput = {
    set: string[]
  }

  export type PropertyTypeMasterCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<PropertyTypeMasterCreateWithoutPropertiesInput, PropertyTypeMasterUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyTypeMasterCreateOrConnectWithoutPropertiesInput
    connect?: PropertyTypeMasterWhereUniqueInput
  }

  export type PropertyCategoryMasterCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<PropertyCategoryMasterCreateWithoutPropertiesInput, PropertyCategoryMasterUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyCategoryMasterCreateOrConnectWithoutPropertiesInput
    connect?: PropertyCategoryMasterWhereUniqueInput
  }

  export type AreaMasterCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<AreaMasterCreateWithoutPropertiesInput, AreaMasterUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: AreaMasterCreateOrConnectWithoutPropertiesInput
    connect?: AreaMasterWhereUniqueInput
  }

  export type FloorPlanMasterCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<FloorPlanMasterCreateWithoutPropertiesInput, FloorPlanMasterUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: FloorPlanMasterCreateOrConnectWithoutPropertiesInput
    connect?: FloorPlanMasterWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<AgentCreateWithoutPropertiesInput, AgentUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutPropertiesInput
    connect?: AgentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertiesInput
    connect?: UserWhereUniqueInput
  }

  export type PropertyPublicationCreateNestedOneWithoutPropertyInput = {
    create?: XOR<PropertyPublicationCreateWithoutPropertyInput, PropertyPublicationUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: PropertyPublicationCreateOrConnectWithoutPropertyInput
    connect?: PropertyPublicationWhereUniqueInput
  }

  export type PropertyPriceHistoryCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyPriceHistoryCreateWithoutPropertyInput, PropertyPriceHistoryUncheckedCreateWithoutPropertyInput> | PropertyPriceHistoryCreateWithoutPropertyInput[] | PropertyPriceHistoryUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyPriceHistoryCreateOrConnectWithoutPropertyInput | PropertyPriceHistoryCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyPriceHistoryCreateManyPropertyInputEnvelope
    connect?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
  }

  export type PropertyStatusHistoryCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyStatusHistoryCreateWithoutPropertyInput, PropertyStatusHistoryUncheckedCreateWithoutPropertyInput> | PropertyStatusHistoryCreateWithoutPropertyInput[] | PropertyStatusHistoryUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyStatusHistoryCreateOrConnectWithoutPropertyInput | PropertyStatusHistoryCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyStatusHistoryCreateManyPropertyInputEnvelope
    connect?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
  }

  export type PropertyImageCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyImageCreateWithoutPropertyInput, PropertyImageUncheckedCreateWithoutPropertyInput> | PropertyImageCreateWithoutPropertyInput[] | PropertyImageUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyImageCreateOrConnectWithoutPropertyInput | PropertyImageCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyImageCreateManyPropertyInputEnvelope
    connect?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
  }

  export type PropertyFeatureCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyFeatureCreateWithoutPropertyInput, PropertyFeatureUncheckedCreateWithoutPropertyInput> | PropertyFeatureCreateWithoutPropertyInput[] | PropertyFeatureUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyFeatureCreateOrConnectWithoutPropertyInput | PropertyFeatureCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyFeatureCreateManyPropertyInputEnvelope
    connect?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
  }

  export type PropertyStationCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyStationCreateWithoutPropertyInput, PropertyStationUncheckedCreateWithoutPropertyInput> | PropertyStationCreateWithoutPropertyInput[] | PropertyStationUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyStationCreateOrConnectWithoutPropertyInput | PropertyStationCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyStationCreateManyPropertyInputEnvelope
    connect?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
  }

  export type InquiryCreateNestedManyWithoutPropertyInput = {
    create?: XOR<InquiryCreateWithoutPropertyInput, InquiryUncheckedCreateWithoutPropertyInput> | InquiryCreateWithoutPropertyInput[] | InquiryUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutPropertyInput | InquiryCreateOrConnectWithoutPropertyInput[]
    createMany?: InquiryCreateManyPropertyInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type FavoriteCreateNestedManyWithoutPropertyInput = {
    create?: XOR<FavoriteCreateWithoutPropertyInput, FavoriteUncheckedCreateWithoutPropertyInput> | FavoriteCreateWithoutPropertyInput[] | FavoriteUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutPropertyInput | FavoriteCreateOrConnectWithoutPropertyInput[]
    createMany?: FavoriteCreateManyPropertyInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type PropertyViewCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput> | PropertyViewCreateWithoutPropertyInput[] | PropertyViewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutPropertyInput | PropertyViewCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyViewCreateManyPropertyInputEnvelope
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
  }

  export type PropertyViewDailyCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyViewDailyCreateWithoutPropertyInput, PropertyViewDailyUncheckedCreateWithoutPropertyInput> | PropertyViewDailyCreateWithoutPropertyInput[] | PropertyViewDailyUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewDailyCreateOrConnectWithoutPropertyInput | PropertyViewDailyCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyViewDailyCreateManyPropertyInputEnvelope
    connect?: PropertyViewDailyWhereUniqueInput | PropertyViewDailyWhereUniqueInput[]
  }

  export type PropertyPublicationUncheckedCreateNestedOneWithoutPropertyInput = {
    create?: XOR<PropertyPublicationCreateWithoutPropertyInput, PropertyPublicationUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: PropertyPublicationCreateOrConnectWithoutPropertyInput
    connect?: PropertyPublicationWhereUniqueInput
  }

  export type PropertyPriceHistoryUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyPriceHistoryCreateWithoutPropertyInput, PropertyPriceHistoryUncheckedCreateWithoutPropertyInput> | PropertyPriceHistoryCreateWithoutPropertyInput[] | PropertyPriceHistoryUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyPriceHistoryCreateOrConnectWithoutPropertyInput | PropertyPriceHistoryCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyPriceHistoryCreateManyPropertyInputEnvelope
    connect?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
  }

  export type PropertyStatusHistoryUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyStatusHistoryCreateWithoutPropertyInput, PropertyStatusHistoryUncheckedCreateWithoutPropertyInput> | PropertyStatusHistoryCreateWithoutPropertyInput[] | PropertyStatusHistoryUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyStatusHistoryCreateOrConnectWithoutPropertyInput | PropertyStatusHistoryCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyStatusHistoryCreateManyPropertyInputEnvelope
    connect?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
  }

  export type PropertyImageUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyImageCreateWithoutPropertyInput, PropertyImageUncheckedCreateWithoutPropertyInput> | PropertyImageCreateWithoutPropertyInput[] | PropertyImageUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyImageCreateOrConnectWithoutPropertyInput | PropertyImageCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyImageCreateManyPropertyInputEnvelope
    connect?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
  }

  export type PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyFeatureCreateWithoutPropertyInput, PropertyFeatureUncheckedCreateWithoutPropertyInput> | PropertyFeatureCreateWithoutPropertyInput[] | PropertyFeatureUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyFeatureCreateOrConnectWithoutPropertyInput | PropertyFeatureCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyFeatureCreateManyPropertyInputEnvelope
    connect?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
  }

  export type PropertyStationUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyStationCreateWithoutPropertyInput, PropertyStationUncheckedCreateWithoutPropertyInput> | PropertyStationCreateWithoutPropertyInput[] | PropertyStationUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyStationCreateOrConnectWithoutPropertyInput | PropertyStationCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyStationCreateManyPropertyInputEnvelope
    connect?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
  }

  export type InquiryUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<InquiryCreateWithoutPropertyInput, InquiryUncheckedCreateWithoutPropertyInput> | InquiryCreateWithoutPropertyInput[] | InquiryUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutPropertyInput | InquiryCreateOrConnectWithoutPropertyInput[]
    createMany?: InquiryCreateManyPropertyInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<FavoriteCreateWithoutPropertyInput, FavoriteUncheckedCreateWithoutPropertyInput> | FavoriteCreateWithoutPropertyInput[] | FavoriteUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutPropertyInput | FavoriteCreateOrConnectWithoutPropertyInput[]
    createMany?: FavoriteCreateManyPropertyInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type PropertyViewUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput> | PropertyViewCreateWithoutPropertyInput[] | PropertyViewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutPropertyInput | PropertyViewCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyViewCreateManyPropertyInputEnvelope
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
  }

  export type PropertyViewDailyUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyViewDailyCreateWithoutPropertyInput, PropertyViewDailyUncheckedCreateWithoutPropertyInput> | PropertyViewDailyCreateWithoutPropertyInput[] | PropertyViewDailyUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewDailyCreateOrConnectWithoutPropertyInput | PropertyViewDailyCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyViewDailyCreateManyPropertyInputEnvelope
    connect?: PropertyViewDailyWhereUniqueInput | PropertyViewDailyWhereUniqueInput[]
  }

  export type NullableEnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType | null
  }

  export type NullableEnumPropertyConditionFieldUpdateOperationsInput = {
    set?: $Enums.PropertyCondition | null
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type PropertyUpdatefeatureTagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PropertyTypeMasterUpdateOneWithoutPropertiesNestedInput = {
    create?: XOR<PropertyTypeMasterCreateWithoutPropertiesInput, PropertyTypeMasterUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyTypeMasterCreateOrConnectWithoutPropertiesInput
    upsert?: PropertyTypeMasterUpsertWithoutPropertiesInput
    disconnect?: PropertyTypeMasterWhereInput | boolean
    delete?: PropertyTypeMasterWhereInput | boolean
    connect?: PropertyTypeMasterWhereUniqueInput
    update?: XOR<XOR<PropertyTypeMasterUpdateToOneWithWhereWithoutPropertiesInput, PropertyTypeMasterUpdateWithoutPropertiesInput>, PropertyTypeMasterUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyCategoryMasterUpdateOneWithoutPropertiesNestedInput = {
    create?: XOR<PropertyCategoryMasterCreateWithoutPropertiesInput, PropertyCategoryMasterUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyCategoryMasterCreateOrConnectWithoutPropertiesInput
    upsert?: PropertyCategoryMasterUpsertWithoutPropertiesInput
    disconnect?: PropertyCategoryMasterWhereInput | boolean
    delete?: PropertyCategoryMasterWhereInput | boolean
    connect?: PropertyCategoryMasterWhereUniqueInput
    update?: XOR<XOR<PropertyCategoryMasterUpdateToOneWithWhereWithoutPropertiesInput, PropertyCategoryMasterUpdateWithoutPropertiesInput>, PropertyCategoryMasterUncheckedUpdateWithoutPropertiesInput>
  }

  export type AreaMasterUpdateOneWithoutPropertiesNestedInput = {
    create?: XOR<AreaMasterCreateWithoutPropertiesInput, AreaMasterUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: AreaMasterCreateOrConnectWithoutPropertiesInput
    upsert?: AreaMasterUpsertWithoutPropertiesInput
    disconnect?: AreaMasterWhereInput | boolean
    delete?: AreaMasterWhereInput | boolean
    connect?: AreaMasterWhereUniqueInput
    update?: XOR<XOR<AreaMasterUpdateToOneWithWhereWithoutPropertiesInput, AreaMasterUpdateWithoutPropertiesInput>, AreaMasterUncheckedUpdateWithoutPropertiesInput>
  }

  export type FloorPlanMasterUpdateOneWithoutPropertiesNestedInput = {
    create?: XOR<FloorPlanMasterCreateWithoutPropertiesInput, FloorPlanMasterUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: FloorPlanMasterCreateOrConnectWithoutPropertiesInput
    upsert?: FloorPlanMasterUpsertWithoutPropertiesInput
    disconnect?: FloorPlanMasterWhereInput | boolean
    delete?: FloorPlanMasterWhereInput | boolean
    connect?: FloorPlanMasterWhereUniqueInput
    update?: XOR<XOR<FloorPlanMasterUpdateToOneWithWhereWithoutPropertiesInput, FloorPlanMasterUpdateWithoutPropertiesInput>, FloorPlanMasterUncheckedUpdateWithoutPropertiesInput>
  }

  export type AgentUpdateOneWithoutPropertiesNestedInput = {
    create?: XOR<AgentCreateWithoutPropertiesInput, AgentUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutPropertiesInput
    upsert?: AgentUpsertWithoutPropertiesInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutPropertiesInput, AgentUpdateWithoutPropertiesInput>, AgentUncheckedUpdateWithoutPropertiesInput>
  }

  export type UserUpdateOneRequiredWithoutPropertiesNestedInput = {
    create?: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertiesInput
    upsert?: UserUpsertWithoutPropertiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPropertiesInput, UserUpdateWithoutPropertiesInput>, UserUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyPublicationUpdateOneWithoutPropertyNestedInput = {
    create?: XOR<PropertyPublicationCreateWithoutPropertyInput, PropertyPublicationUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: PropertyPublicationCreateOrConnectWithoutPropertyInput
    upsert?: PropertyPublicationUpsertWithoutPropertyInput
    disconnect?: PropertyPublicationWhereInput | boolean
    delete?: PropertyPublicationWhereInput | boolean
    connect?: PropertyPublicationWhereUniqueInput
    update?: XOR<XOR<PropertyPublicationUpdateToOneWithWhereWithoutPropertyInput, PropertyPublicationUpdateWithoutPropertyInput>, PropertyPublicationUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyPriceHistoryUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyPriceHistoryCreateWithoutPropertyInput, PropertyPriceHistoryUncheckedCreateWithoutPropertyInput> | PropertyPriceHistoryCreateWithoutPropertyInput[] | PropertyPriceHistoryUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyPriceHistoryCreateOrConnectWithoutPropertyInput | PropertyPriceHistoryCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyPriceHistoryUpsertWithWhereUniqueWithoutPropertyInput | PropertyPriceHistoryUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyPriceHistoryCreateManyPropertyInputEnvelope
    set?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
    disconnect?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
    delete?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
    connect?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
    update?: PropertyPriceHistoryUpdateWithWhereUniqueWithoutPropertyInput | PropertyPriceHistoryUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyPriceHistoryUpdateManyWithWhereWithoutPropertyInput | PropertyPriceHistoryUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyPriceHistoryScalarWhereInput | PropertyPriceHistoryScalarWhereInput[]
  }

  export type PropertyStatusHistoryUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyStatusHistoryCreateWithoutPropertyInput, PropertyStatusHistoryUncheckedCreateWithoutPropertyInput> | PropertyStatusHistoryCreateWithoutPropertyInput[] | PropertyStatusHistoryUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyStatusHistoryCreateOrConnectWithoutPropertyInput | PropertyStatusHistoryCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyStatusHistoryUpsertWithWhereUniqueWithoutPropertyInput | PropertyStatusHistoryUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyStatusHistoryCreateManyPropertyInputEnvelope
    set?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
    disconnect?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
    delete?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
    connect?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
    update?: PropertyStatusHistoryUpdateWithWhereUniqueWithoutPropertyInput | PropertyStatusHistoryUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyStatusHistoryUpdateManyWithWhereWithoutPropertyInput | PropertyStatusHistoryUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyStatusHistoryScalarWhereInput | PropertyStatusHistoryScalarWhereInput[]
  }

  export type PropertyImageUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyImageCreateWithoutPropertyInput, PropertyImageUncheckedCreateWithoutPropertyInput> | PropertyImageCreateWithoutPropertyInput[] | PropertyImageUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyImageCreateOrConnectWithoutPropertyInput | PropertyImageCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyImageUpsertWithWhereUniqueWithoutPropertyInput | PropertyImageUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyImageCreateManyPropertyInputEnvelope
    set?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    disconnect?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    delete?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    connect?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    update?: PropertyImageUpdateWithWhereUniqueWithoutPropertyInput | PropertyImageUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyImageUpdateManyWithWhereWithoutPropertyInput | PropertyImageUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyImageScalarWhereInput | PropertyImageScalarWhereInput[]
  }

  export type PropertyFeatureUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyFeatureCreateWithoutPropertyInput, PropertyFeatureUncheckedCreateWithoutPropertyInput> | PropertyFeatureCreateWithoutPropertyInput[] | PropertyFeatureUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyFeatureCreateOrConnectWithoutPropertyInput | PropertyFeatureCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyFeatureUpsertWithWhereUniqueWithoutPropertyInput | PropertyFeatureUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyFeatureCreateManyPropertyInputEnvelope
    set?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    disconnect?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    delete?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    connect?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    update?: PropertyFeatureUpdateWithWhereUniqueWithoutPropertyInput | PropertyFeatureUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyFeatureUpdateManyWithWhereWithoutPropertyInput | PropertyFeatureUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyFeatureScalarWhereInput | PropertyFeatureScalarWhereInput[]
  }

  export type PropertyStationUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyStationCreateWithoutPropertyInput, PropertyStationUncheckedCreateWithoutPropertyInput> | PropertyStationCreateWithoutPropertyInput[] | PropertyStationUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyStationCreateOrConnectWithoutPropertyInput | PropertyStationCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyStationUpsertWithWhereUniqueWithoutPropertyInput | PropertyStationUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyStationCreateManyPropertyInputEnvelope
    set?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
    disconnect?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
    delete?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
    connect?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
    update?: PropertyStationUpdateWithWhereUniqueWithoutPropertyInput | PropertyStationUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyStationUpdateManyWithWhereWithoutPropertyInput | PropertyStationUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyStationScalarWhereInput | PropertyStationScalarWhereInput[]
  }

  export type InquiryUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<InquiryCreateWithoutPropertyInput, InquiryUncheckedCreateWithoutPropertyInput> | InquiryCreateWithoutPropertyInput[] | InquiryUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutPropertyInput | InquiryCreateOrConnectWithoutPropertyInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutPropertyInput | InquiryUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: InquiryCreateManyPropertyInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutPropertyInput | InquiryUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutPropertyInput | InquiryUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type FavoriteUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<FavoriteCreateWithoutPropertyInput, FavoriteUncheckedCreateWithoutPropertyInput> | FavoriteCreateWithoutPropertyInput[] | FavoriteUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutPropertyInput | FavoriteCreateOrConnectWithoutPropertyInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutPropertyInput | FavoriteUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: FavoriteCreateManyPropertyInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutPropertyInput | FavoriteUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutPropertyInput | FavoriteUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type PropertyViewUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput> | PropertyViewCreateWithoutPropertyInput[] | PropertyViewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutPropertyInput | PropertyViewCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyViewUpsertWithWhereUniqueWithoutPropertyInput | PropertyViewUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyViewCreateManyPropertyInputEnvelope
    set?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    disconnect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    delete?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    update?: PropertyViewUpdateWithWhereUniqueWithoutPropertyInput | PropertyViewUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyViewUpdateManyWithWhereWithoutPropertyInput | PropertyViewUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
  }

  export type PropertyViewDailyUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyViewDailyCreateWithoutPropertyInput, PropertyViewDailyUncheckedCreateWithoutPropertyInput> | PropertyViewDailyCreateWithoutPropertyInput[] | PropertyViewDailyUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewDailyCreateOrConnectWithoutPropertyInput | PropertyViewDailyCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyViewDailyUpsertWithWhereUniqueWithoutPropertyInput | PropertyViewDailyUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyViewDailyCreateManyPropertyInputEnvelope
    set?: PropertyViewDailyWhereUniqueInput | PropertyViewDailyWhereUniqueInput[]
    disconnect?: PropertyViewDailyWhereUniqueInput | PropertyViewDailyWhereUniqueInput[]
    delete?: PropertyViewDailyWhereUniqueInput | PropertyViewDailyWhereUniqueInput[]
    connect?: PropertyViewDailyWhereUniqueInput | PropertyViewDailyWhereUniqueInput[]
    update?: PropertyViewDailyUpdateWithWhereUniqueWithoutPropertyInput | PropertyViewDailyUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyViewDailyUpdateManyWithWhereWithoutPropertyInput | PropertyViewDailyUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyViewDailyScalarWhereInput | PropertyViewDailyScalarWhereInput[]
  }

  export type PropertyPublicationUncheckedUpdateOneWithoutPropertyNestedInput = {
    create?: XOR<PropertyPublicationCreateWithoutPropertyInput, PropertyPublicationUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: PropertyPublicationCreateOrConnectWithoutPropertyInput
    upsert?: PropertyPublicationUpsertWithoutPropertyInput
    disconnect?: PropertyPublicationWhereInput | boolean
    delete?: PropertyPublicationWhereInput | boolean
    connect?: PropertyPublicationWhereUniqueInput
    update?: XOR<XOR<PropertyPublicationUpdateToOneWithWhereWithoutPropertyInput, PropertyPublicationUpdateWithoutPropertyInput>, PropertyPublicationUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyPriceHistoryCreateWithoutPropertyInput, PropertyPriceHistoryUncheckedCreateWithoutPropertyInput> | PropertyPriceHistoryCreateWithoutPropertyInput[] | PropertyPriceHistoryUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyPriceHistoryCreateOrConnectWithoutPropertyInput | PropertyPriceHistoryCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyPriceHistoryUpsertWithWhereUniqueWithoutPropertyInput | PropertyPriceHistoryUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyPriceHistoryCreateManyPropertyInputEnvelope
    set?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
    disconnect?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
    delete?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
    connect?: PropertyPriceHistoryWhereUniqueInput | PropertyPriceHistoryWhereUniqueInput[]
    update?: PropertyPriceHistoryUpdateWithWhereUniqueWithoutPropertyInput | PropertyPriceHistoryUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyPriceHistoryUpdateManyWithWhereWithoutPropertyInput | PropertyPriceHistoryUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyPriceHistoryScalarWhereInput | PropertyPriceHistoryScalarWhereInput[]
  }

  export type PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyStatusHistoryCreateWithoutPropertyInput, PropertyStatusHistoryUncheckedCreateWithoutPropertyInput> | PropertyStatusHistoryCreateWithoutPropertyInput[] | PropertyStatusHistoryUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyStatusHistoryCreateOrConnectWithoutPropertyInput | PropertyStatusHistoryCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyStatusHistoryUpsertWithWhereUniqueWithoutPropertyInput | PropertyStatusHistoryUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyStatusHistoryCreateManyPropertyInputEnvelope
    set?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
    disconnect?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
    delete?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
    connect?: PropertyStatusHistoryWhereUniqueInput | PropertyStatusHistoryWhereUniqueInput[]
    update?: PropertyStatusHistoryUpdateWithWhereUniqueWithoutPropertyInput | PropertyStatusHistoryUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyStatusHistoryUpdateManyWithWhereWithoutPropertyInput | PropertyStatusHistoryUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyStatusHistoryScalarWhereInput | PropertyStatusHistoryScalarWhereInput[]
  }

  export type PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyImageCreateWithoutPropertyInput, PropertyImageUncheckedCreateWithoutPropertyInput> | PropertyImageCreateWithoutPropertyInput[] | PropertyImageUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyImageCreateOrConnectWithoutPropertyInput | PropertyImageCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyImageUpsertWithWhereUniqueWithoutPropertyInput | PropertyImageUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyImageCreateManyPropertyInputEnvelope
    set?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    disconnect?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    delete?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    connect?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    update?: PropertyImageUpdateWithWhereUniqueWithoutPropertyInput | PropertyImageUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyImageUpdateManyWithWhereWithoutPropertyInput | PropertyImageUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyImageScalarWhereInput | PropertyImageScalarWhereInput[]
  }

  export type PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyFeatureCreateWithoutPropertyInput, PropertyFeatureUncheckedCreateWithoutPropertyInput> | PropertyFeatureCreateWithoutPropertyInput[] | PropertyFeatureUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyFeatureCreateOrConnectWithoutPropertyInput | PropertyFeatureCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyFeatureUpsertWithWhereUniqueWithoutPropertyInput | PropertyFeatureUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyFeatureCreateManyPropertyInputEnvelope
    set?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    disconnect?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    delete?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    connect?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    update?: PropertyFeatureUpdateWithWhereUniqueWithoutPropertyInput | PropertyFeatureUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyFeatureUpdateManyWithWhereWithoutPropertyInput | PropertyFeatureUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyFeatureScalarWhereInput | PropertyFeatureScalarWhereInput[]
  }

  export type PropertyStationUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyStationCreateWithoutPropertyInput, PropertyStationUncheckedCreateWithoutPropertyInput> | PropertyStationCreateWithoutPropertyInput[] | PropertyStationUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyStationCreateOrConnectWithoutPropertyInput | PropertyStationCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyStationUpsertWithWhereUniqueWithoutPropertyInput | PropertyStationUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyStationCreateManyPropertyInputEnvelope
    set?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
    disconnect?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
    delete?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
    connect?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
    update?: PropertyStationUpdateWithWhereUniqueWithoutPropertyInput | PropertyStationUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyStationUpdateManyWithWhereWithoutPropertyInput | PropertyStationUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyStationScalarWhereInput | PropertyStationScalarWhereInput[]
  }

  export type InquiryUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<InquiryCreateWithoutPropertyInput, InquiryUncheckedCreateWithoutPropertyInput> | InquiryCreateWithoutPropertyInput[] | InquiryUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutPropertyInput | InquiryCreateOrConnectWithoutPropertyInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutPropertyInput | InquiryUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: InquiryCreateManyPropertyInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutPropertyInput | InquiryUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutPropertyInput | InquiryUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<FavoriteCreateWithoutPropertyInput, FavoriteUncheckedCreateWithoutPropertyInput> | FavoriteCreateWithoutPropertyInput[] | FavoriteUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutPropertyInput | FavoriteCreateOrConnectWithoutPropertyInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutPropertyInput | FavoriteUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: FavoriteCreateManyPropertyInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutPropertyInput | FavoriteUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutPropertyInput | FavoriteUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput> | PropertyViewCreateWithoutPropertyInput[] | PropertyViewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutPropertyInput | PropertyViewCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyViewUpsertWithWhereUniqueWithoutPropertyInput | PropertyViewUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyViewCreateManyPropertyInputEnvelope
    set?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    disconnect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    delete?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    update?: PropertyViewUpdateWithWhereUniqueWithoutPropertyInput | PropertyViewUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyViewUpdateManyWithWhereWithoutPropertyInput | PropertyViewUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
  }

  export type PropertyViewDailyUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyViewDailyCreateWithoutPropertyInput, PropertyViewDailyUncheckedCreateWithoutPropertyInput> | PropertyViewDailyCreateWithoutPropertyInput[] | PropertyViewDailyUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewDailyCreateOrConnectWithoutPropertyInput | PropertyViewDailyCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyViewDailyUpsertWithWhereUniqueWithoutPropertyInput | PropertyViewDailyUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyViewDailyCreateManyPropertyInputEnvelope
    set?: PropertyViewDailyWhereUniqueInput | PropertyViewDailyWhereUniqueInput[]
    disconnect?: PropertyViewDailyWhereUniqueInput | PropertyViewDailyWhereUniqueInput[]
    delete?: PropertyViewDailyWhereUniqueInput | PropertyViewDailyWhereUniqueInput[]
    connect?: PropertyViewDailyWhereUniqueInput | PropertyViewDailyWhereUniqueInput[]
    update?: PropertyViewDailyUpdateWithWhereUniqueWithoutPropertyInput | PropertyViewDailyUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyViewDailyUpdateManyWithWhereWithoutPropertyInput | PropertyViewDailyUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyViewDailyScalarWhereInput | PropertyViewDailyScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutPublicationInput = {
    create?: XOR<PropertyCreateWithoutPublicationInput, PropertyUncheckedCreateWithoutPublicationInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPublicationInput
    connect?: PropertyWhereUniqueInput
  }

  export type EnumPublicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.PublicationStatus
  }

  export type EnumPublicScopeFieldUpdateOperationsInput = {
    set?: $Enums.PublicScope
  }

  export type PropertyUpdateOneRequiredWithoutPublicationNestedInput = {
    create?: XOR<PropertyCreateWithoutPublicationInput, PropertyUncheckedCreateWithoutPublicationInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPublicationInput
    upsert?: PropertyUpsertWithoutPublicationInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPublicationInput, PropertyUpdateWithoutPublicationInput>, PropertyUncheckedUpdateWithoutPublicationInput>
  }

  export type PropertyCreateNestedOneWithoutPriceHistoriesInput = {
    create?: XOR<PropertyCreateWithoutPriceHistoriesInput, PropertyUncheckedCreateWithoutPriceHistoriesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPriceHistoriesInput
    connect?: PropertyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPriceHistoryChangesInput = {
    create?: XOR<UserCreateWithoutPriceHistoryChangesInput, UserUncheckedCreateWithoutPriceHistoryChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPriceHistoryChangesInput
    connect?: UserWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type PropertyUpdateOneRequiredWithoutPriceHistoriesNestedInput = {
    create?: XOR<PropertyCreateWithoutPriceHistoriesInput, PropertyUncheckedCreateWithoutPriceHistoriesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPriceHistoriesInput
    upsert?: PropertyUpsertWithoutPriceHistoriesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPriceHistoriesInput, PropertyUpdateWithoutPriceHistoriesInput>, PropertyUncheckedUpdateWithoutPriceHistoriesInput>
  }

  export type UserUpdateOneWithoutPriceHistoryChangesNestedInput = {
    create?: XOR<UserCreateWithoutPriceHistoryChangesInput, UserUncheckedCreateWithoutPriceHistoryChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPriceHistoryChangesInput
    upsert?: UserUpsertWithoutPriceHistoryChangesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPriceHistoryChangesInput, UserUpdateWithoutPriceHistoryChangesInput>, UserUncheckedUpdateWithoutPriceHistoryChangesInput>
  }

  export type PropertyCreateNestedOneWithoutStatusHistoriesInput = {
    create?: XOR<PropertyCreateWithoutStatusHistoriesInput, PropertyUncheckedCreateWithoutStatusHistoriesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutStatusHistoriesInput
    connect?: PropertyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStatusHistoryChangesInput = {
    create?: XOR<UserCreateWithoutStatusHistoryChangesInput, UserUncheckedCreateWithoutStatusHistoryChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatusHistoryChangesInput
    connect?: UserWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutStatusHistoriesNestedInput = {
    create?: XOR<PropertyCreateWithoutStatusHistoriesInput, PropertyUncheckedCreateWithoutStatusHistoriesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutStatusHistoriesInput
    upsert?: PropertyUpsertWithoutStatusHistoriesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutStatusHistoriesInput, PropertyUpdateWithoutStatusHistoriesInput>, PropertyUncheckedUpdateWithoutStatusHistoriesInput>
  }

  export type UserUpdateOneWithoutStatusHistoryChangesNestedInput = {
    create?: XOR<UserCreateWithoutStatusHistoryChangesInput, UserUncheckedCreateWithoutStatusHistoryChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatusHistoryChangesInput
    upsert?: UserUpsertWithoutStatusHistoryChangesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStatusHistoryChangesInput, UserUpdateWithoutStatusHistoryChangesInput>, UserUncheckedUpdateWithoutStatusHistoryChangesInput>
  }

  export type PropertyCreateNestedOneWithoutImagesInput = {
    create?: XOR<PropertyCreateWithoutImagesInput, PropertyUncheckedCreateWithoutImagesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutImagesInput
    connect?: PropertyWhereUniqueInput
  }

  export type FileBoxCreateNestedOneWithoutPropertyImagesInput = {
    create?: XOR<FileBoxCreateWithoutPropertyImagesInput, FileBoxUncheckedCreateWithoutPropertyImagesInput>
    connectOrCreate?: FileBoxCreateOrConnectWithoutPropertyImagesInput
    connect?: FileBoxWhereUniqueInput
  }

  export type EnumImageTypeFieldUpdateOperationsInput = {
    set?: $Enums.ImageType
  }

  export type PropertyUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<PropertyCreateWithoutImagesInput, PropertyUncheckedCreateWithoutImagesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutImagesInput
    upsert?: PropertyUpsertWithoutImagesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutImagesInput, PropertyUpdateWithoutImagesInput>, PropertyUncheckedUpdateWithoutImagesInput>
  }

  export type FileBoxUpdateOneWithoutPropertyImagesNestedInput = {
    create?: XOR<FileBoxCreateWithoutPropertyImagesInput, FileBoxUncheckedCreateWithoutPropertyImagesInput>
    connectOrCreate?: FileBoxCreateOrConnectWithoutPropertyImagesInput
    upsert?: FileBoxUpsertWithoutPropertyImagesInput
    disconnect?: FileBoxWhereInput | boolean
    delete?: FileBoxWhereInput | boolean
    connect?: FileBoxWhereUniqueInput
    update?: XOR<XOR<FileBoxUpdateToOneWithWhereWithoutPropertyImagesInput, FileBoxUpdateWithoutPropertyImagesInput>, FileBoxUncheckedUpdateWithoutPropertyImagesInput>
  }

  export type PropertyCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<PropertyCreateWithoutFeaturesInput, PropertyUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutFeaturesInput
    connect?: PropertyWhereUniqueInput
  }

  export type FeatureMasterCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<FeatureMasterCreateWithoutPropertiesInput, FeatureMasterUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: FeatureMasterCreateOrConnectWithoutPropertiesInput
    connect?: FeatureMasterWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<PropertyCreateWithoutFeaturesInput, PropertyUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutFeaturesInput
    upsert?: PropertyUpsertWithoutFeaturesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutFeaturesInput, PropertyUpdateWithoutFeaturesInput>, PropertyUncheckedUpdateWithoutFeaturesInput>
  }

  export type FeatureMasterUpdateOneRequiredWithoutPropertiesNestedInput = {
    create?: XOR<FeatureMasterCreateWithoutPropertiesInput, FeatureMasterUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: FeatureMasterCreateOrConnectWithoutPropertiesInput
    upsert?: FeatureMasterUpsertWithoutPropertiesInput
    connect?: FeatureMasterWhereUniqueInput
    update?: XOR<XOR<FeatureMasterUpdateToOneWithWhereWithoutPropertiesInput, FeatureMasterUpdateWithoutPropertiesInput>, FeatureMasterUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyCreateNestedOneWithoutStationsInput = {
    create?: XOR<PropertyCreateWithoutStationsInput, PropertyUncheckedCreateWithoutStationsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutStationsInput
    connect?: PropertyWhereUniqueInput
  }

  export type StationCreateNestedOneWithoutPropertyStationsInput = {
    create?: XOR<StationCreateWithoutPropertyStationsInput, StationUncheckedCreateWithoutPropertyStationsInput>
    connectOrCreate?: StationCreateOrConnectWithoutPropertyStationsInput
    connect?: StationWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutStationsNestedInput = {
    create?: XOR<PropertyCreateWithoutStationsInput, PropertyUncheckedCreateWithoutStationsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutStationsInput
    upsert?: PropertyUpsertWithoutStationsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutStationsInput, PropertyUpdateWithoutStationsInput>, PropertyUncheckedUpdateWithoutStationsInput>
  }

  export type StationUpdateOneRequiredWithoutPropertyStationsNestedInput = {
    create?: XOR<StationCreateWithoutPropertyStationsInput, StationUncheckedCreateWithoutPropertyStationsInput>
    connectOrCreate?: StationCreateOrConnectWithoutPropertyStationsInput
    upsert?: StationUpsertWithoutPropertyStationsInput
    connect?: StationWhereUniqueInput
    update?: XOR<XOR<StationUpdateToOneWithWhereWithoutPropertyStationsInput, StationUpdateWithoutPropertyStationsInput>, StationUncheckedUpdateWithoutPropertyStationsInput>
  }

  export type UserCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    connect?: UserWhereUniqueInput
  }

  export type PropertyCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<PropertyCreateWithoutFavoritesInput, PropertyUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutFavoritesInput
    connect?: PropertyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    upsert?: UserUpsertWithoutFavoritesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoritesInput, UserUpdateWithoutFavoritesInput>, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type PropertyUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<PropertyCreateWithoutFavoritesInput, PropertyUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutFavoritesInput
    upsert?: PropertyUpsertWithoutFavoritesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutFavoritesInput, PropertyUpdateWithoutFavoritesInput>, PropertyUncheckedUpdateWithoutFavoritesInput>
  }

  export type PropertyCreateNestedOneWithoutPropertyViewsInput = {
    create?: XOR<PropertyCreateWithoutPropertyViewsInput, PropertyUncheckedCreateWithoutPropertyViewsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyViewsInput
    connect?: PropertyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPropertyViewsInput = {
    create?: XOR<UserCreateWithoutPropertyViewsInput, UserUncheckedCreateWithoutPropertyViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertyViewsInput
    connect?: UserWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutPropertyViewsNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyViewsInput, PropertyUncheckedCreateWithoutPropertyViewsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyViewsInput
    upsert?: PropertyUpsertWithoutPropertyViewsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPropertyViewsInput, PropertyUpdateWithoutPropertyViewsInput>, PropertyUncheckedUpdateWithoutPropertyViewsInput>
  }

  export type UserUpdateOneWithoutPropertyViewsNestedInput = {
    create?: XOR<UserCreateWithoutPropertyViewsInput, UserUncheckedCreateWithoutPropertyViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertyViewsInput
    upsert?: UserUpsertWithoutPropertyViewsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPropertyViewsInput, UserUpdateWithoutPropertyViewsInput>, UserUncheckedUpdateWithoutPropertyViewsInput>
  }

  export type PropertyCreateNestedOneWithoutPropertyViewDailiesInput = {
    create?: XOR<PropertyCreateWithoutPropertyViewDailiesInput, PropertyUncheckedCreateWithoutPropertyViewDailiesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyViewDailiesInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutPropertyViewDailiesNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyViewDailiesInput, PropertyUncheckedCreateWithoutPropertyViewDailiesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyViewDailiesInput
    upsert?: PropertyUpsertWithoutPropertyViewDailiesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPropertyViewDailiesInput, PropertyUpdateWithoutPropertyViewDailiesInput>, PropertyUncheckedUpdateWithoutPropertyViewDailiesInput>
  }

  export type UserCreateNestedOneWithoutInquiriesInput = {
    create?: XOR<UserCreateWithoutInquiriesInput, UserUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInquiriesInput
    connect?: UserWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutAssignedInquiriesInput = {
    create?: XOR<AgentCreateWithoutAssignedInquiriesInput, AgentUncheckedCreateWithoutAssignedInquiriesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAssignedInquiriesInput
    connect?: AgentWhereUniqueInput
  }

  export type PropertyCreateNestedOneWithoutInquiriesInput = {
    create?: XOR<PropertyCreateWithoutInquiriesInput, PropertyUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutInquiriesInput
    connect?: PropertyWhereUniqueInput
  }

  export type InquiryMessageCreateNestedManyWithoutInquiryInput = {
    create?: XOR<InquiryMessageCreateWithoutInquiryInput, InquiryMessageUncheckedCreateWithoutInquiryInput> | InquiryMessageCreateWithoutInquiryInput[] | InquiryMessageUncheckedCreateWithoutInquiryInput[]
    connectOrCreate?: InquiryMessageCreateOrConnectWithoutInquiryInput | InquiryMessageCreateOrConnectWithoutInquiryInput[]
    createMany?: InquiryMessageCreateManyInquiryInputEnvelope
    connect?: InquiryMessageWhereUniqueInput | InquiryMessageWhereUniqueInput[]
  }

  export type InquiryMessageUncheckedCreateNestedManyWithoutInquiryInput = {
    create?: XOR<InquiryMessageCreateWithoutInquiryInput, InquiryMessageUncheckedCreateWithoutInquiryInput> | InquiryMessageCreateWithoutInquiryInput[] | InquiryMessageUncheckedCreateWithoutInquiryInput[]
    connectOrCreate?: InquiryMessageCreateOrConnectWithoutInquiryInput | InquiryMessageCreateOrConnectWithoutInquiryInput[]
    createMany?: InquiryMessageCreateManyInquiryInputEnvelope
    connect?: InquiryMessageWhereUniqueInput | InquiryMessageWhereUniqueInput[]
  }

  export type EnumTargetTypeFieldUpdateOperationsInput = {
    set?: $Enums.TargetType
  }

  export type EnumInquiryTypeFieldUpdateOperationsInput = {
    set?: $Enums.InquiryType
  }

  export type EnumInquiryStatusFieldUpdateOperationsInput = {
    set?: $Enums.InquiryStatus
  }

  export type EnumInquiryPriorityFieldUpdateOperationsInput = {
    set?: $Enums.InquiryPriority
  }

  export type UserUpdateOneWithoutInquiriesNestedInput = {
    create?: XOR<UserCreateWithoutInquiriesInput, UserUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInquiriesInput
    upsert?: UserUpsertWithoutInquiriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInquiriesInput, UserUpdateWithoutInquiriesInput>, UserUncheckedUpdateWithoutInquiriesInput>
  }

  export type AgentUpdateOneWithoutAssignedInquiriesNestedInput = {
    create?: XOR<AgentCreateWithoutAssignedInquiriesInput, AgentUncheckedCreateWithoutAssignedInquiriesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAssignedInquiriesInput
    upsert?: AgentUpsertWithoutAssignedInquiriesInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutAssignedInquiriesInput, AgentUpdateWithoutAssignedInquiriesInput>, AgentUncheckedUpdateWithoutAssignedInquiriesInput>
  }

  export type PropertyUpdateOneWithoutInquiriesNestedInput = {
    create?: XOR<PropertyCreateWithoutInquiriesInput, PropertyUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutInquiriesInput
    upsert?: PropertyUpsertWithoutInquiriesInput
    disconnect?: PropertyWhereInput | boolean
    delete?: PropertyWhereInput | boolean
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutInquiriesInput, PropertyUpdateWithoutInquiriesInput>, PropertyUncheckedUpdateWithoutInquiriesInput>
  }

  export type InquiryMessageUpdateManyWithoutInquiryNestedInput = {
    create?: XOR<InquiryMessageCreateWithoutInquiryInput, InquiryMessageUncheckedCreateWithoutInquiryInput> | InquiryMessageCreateWithoutInquiryInput[] | InquiryMessageUncheckedCreateWithoutInquiryInput[]
    connectOrCreate?: InquiryMessageCreateOrConnectWithoutInquiryInput | InquiryMessageCreateOrConnectWithoutInquiryInput[]
    upsert?: InquiryMessageUpsertWithWhereUniqueWithoutInquiryInput | InquiryMessageUpsertWithWhereUniqueWithoutInquiryInput[]
    createMany?: InquiryMessageCreateManyInquiryInputEnvelope
    set?: InquiryMessageWhereUniqueInput | InquiryMessageWhereUniqueInput[]
    disconnect?: InquiryMessageWhereUniqueInput | InquiryMessageWhereUniqueInput[]
    delete?: InquiryMessageWhereUniqueInput | InquiryMessageWhereUniqueInput[]
    connect?: InquiryMessageWhereUniqueInput | InquiryMessageWhereUniqueInput[]
    update?: InquiryMessageUpdateWithWhereUniqueWithoutInquiryInput | InquiryMessageUpdateWithWhereUniqueWithoutInquiryInput[]
    updateMany?: InquiryMessageUpdateManyWithWhereWithoutInquiryInput | InquiryMessageUpdateManyWithWhereWithoutInquiryInput[]
    deleteMany?: InquiryMessageScalarWhereInput | InquiryMessageScalarWhereInput[]
  }

  export type InquiryMessageUncheckedUpdateManyWithoutInquiryNestedInput = {
    create?: XOR<InquiryMessageCreateWithoutInquiryInput, InquiryMessageUncheckedCreateWithoutInquiryInput> | InquiryMessageCreateWithoutInquiryInput[] | InquiryMessageUncheckedCreateWithoutInquiryInput[]
    connectOrCreate?: InquiryMessageCreateOrConnectWithoutInquiryInput | InquiryMessageCreateOrConnectWithoutInquiryInput[]
    upsert?: InquiryMessageUpsertWithWhereUniqueWithoutInquiryInput | InquiryMessageUpsertWithWhereUniqueWithoutInquiryInput[]
    createMany?: InquiryMessageCreateManyInquiryInputEnvelope
    set?: InquiryMessageWhereUniqueInput | InquiryMessageWhereUniqueInput[]
    disconnect?: InquiryMessageWhereUniqueInput | InquiryMessageWhereUniqueInput[]
    delete?: InquiryMessageWhereUniqueInput | InquiryMessageWhereUniqueInput[]
    connect?: InquiryMessageWhereUniqueInput | InquiryMessageWhereUniqueInput[]
    update?: InquiryMessageUpdateWithWhereUniqueWithoutInquiryInput | InquiryMessageUpdateWithWhereUniqueWithoutInquiryInput[]
    updateMany?: InquiryMessageUpdateManyWithWhereWithoutInquiryInput | InquiryMessageUpdateManyWithWhereWithoutInquiryInput[]
    deleteMany?: InquiryMessageScalarWhereInput | InquiryMessageScalarWhereInput[]
  }

  export type InquiryCreateNestedOneWithoutMessagesInput = {
    create?: XOR<InquiryCreateWithoutMessagesInput, InquiryUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: InquiryCreateOrConnectWithoutMessagesInput
    connect?: InquiryWhereUniqueInput
  }

  export type EnumSenderTypeFieldUpdateOperationsInput = {
    set?: $Enums.SenderType
  }

  export type InquiryUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<InquiryCreateWithoutMessagesInput, InquiryUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: InquiryCreateOrConnectWithoutMessagesInput
    upsert?: InquiryUpsertWithoutMessagesInput
    connect?: InquiryWhereUniqueInput
    update?: XOR<XOR<InquiryUpdateToOneWithWhereWithoutMessagesInput, InquiryUpdateWithoutMessagesInput>, InquiryUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutBulkAssessmentsInput = {
    create?: XOR<UserCreateWithoutBulkAssessmentsInput, UserUncheckedCreateWithoutBulkAssessmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBulkAssessmentsInput
    connect?: UserWhereUniqueInput
  }

  export type PropertyTypeMasterCreateNestedOneWithoutBulkAssessmentsInput = {
    create?: XOR<PropertyTypeMasterCreateWithoutBulkAssessmentsInput, PropertyTypeMasterUncheckedCreateWithoutBulkAssessmentsInput>
    connectOrCreate?: PropertyTypeMasterCreateOrConnectWithoutBulkAssessmentsInput
    connect?: PropertyTypeMasterWhereUniqueInput
  }

  export type BulkAssessmentResponseCreateNestedManyWithoutAssessmentInput = {
    create?: XOR<BulkAssessmentResponseCreateWithoutAssessmentInput, BulkAssessmentResponseUncheckedCreateWithoutAssessmentInput> | BulkAssessmentResponseCreateWithoutAssessmentInput[] | BulkAssessmentResponseUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: BulkAssessmentResponseCreateOrConnectWithoutAssessmentInput | BulkAssessmentResponseCreateOrConnectWithoutAssessmentInput[]
    createMany?: BulkAssessmentResponseCreateManyAssessmentInputEnvelope
    connect?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
  }

  export type BulkAssessmentResponseUncheckedCreateNestedManyWithoutAssessmentInput = {
    create?: XOR<BulkAssessmentResponseCreateWithoutAssessmentInput, BulkAssessmentResponseUncheckedCreateWithoutAssessmentInput> | BulkAssessmentResponseCreateWithoutAssessmentInput[] | BulkAssessmentResponseUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: BulkAssessmentResponseCreateOrConnectWithoutAssessmentInput | BulkAssessmentResponseCreateOrConnectWithoutAssessmentInput[]
    createMany?: BulkAssessmentResponseCreateManyAssessmentInputEnvelope
    connect?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
  }

  export type EnumAssessmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AssessmentStatus
  }

  export type UserUpdateOneWithoutBulkAssessmentsNestedInput = {
    create?: XOR<UserCreateWithoutBulkAssessmentsInput, UserUncheckedCreateWithoutBulkAssessmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBulkAssessmentsInput
    upsert?: UserUpsertWithoutBulkAssessmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBulkAssessmentsInput, UserUpdateWithoutBulkAssessmentsInput>, UserUncheckedUpdateWithoutBulkAssessmentsInput>
  }

  export type PropertyTypeMasterUpdateOneWithoutBulkAssessmentsNestedInput = {
    create?: XOR<PropertyTypeMasterCreateWithoutBulkAssessmentsInput, PropertyTypeMasterUncheckedCreateWithoutBulkAssessmentsInput>
    connectOrCreate?: PropertyTypeMasterCreateOrConnectWithoutBulkAssessmentsInput
    upsert?: PropertyTypeMasterUpsertWithoutBulkAssessmentsInput
    disconnect?: PropertyTypeMasterWhereInput | boolean
    delete?: PropertyTypeMasterWhereInput | boolean
    connect?: PropertyTypeMasterWhereUniqueInput
    update?: XOR<XOR<PropertyTypeMasterUpdateToOneWithWhereWithoutBulkAssessmentsInput, PropertyTypeMasterUpdateWithoutBulkAssessmentsInput>, PropertyTypeMasterUncheckedUpdateWithoutBulkAssessmentsInput>
  }

  export type BulkAssessmentResponseUpdateManyWithoutAssessmentNestedInput = {
    create?: XOR<BulkAssessmentResponseCreateWithoutAssessmentInput, BulkAssessmentResponseUncheckedCreateWithoutAssessmentInput> | BulkAssessmentResponseCreateWithoutAssessmentInput[] | BulkAssessmentResponseUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: BulkAssessmentResponseCreateOrConnectWithoutAssessmentInput | BulkAssessmentResponseCreateOrConnectWithoutAssessmentInput[]
    upsert?: BulkAssessmentResponseUpsertWithWhereUniqueWithoutAssessmentInput | BulkAssessmentResponseUpsertWithWhereUniqueWithoutAssessmentInput[]
    createMany?: BulkAssessmentResponseCreateManyAssessmentInputEnvelope
    set?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
    disconnect?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
    delete?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
    connect?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
    update?: BulkAssessmentResponseUpdateWithWhereUniqueWithoutAssessmentInput | BulkAssessmentResponseUpdateWithWhereUniqueWithoutAssessmentInput[]
    updateMany?: BulkAssessmentResponseUpdateManyWithWhereWithoutAssessmentInput | BulkAssessmentResponseUpdateManyWithWhereWithoutAssessmentInput[]
    deleteMany?: BulkAssessmentResponseScalarWhereInput | BulkAssessmentResponseScalarWhereInput[]
  }

  export type BulkAssessmentResponseUncheckedUpdateManyWithoutAssessmentNestedInput = {
    create?: XOR<BulkAssessmentResponseCreateWithoutAssessmentInput, BulkAssessmentResponseUncheckedCreateWithoutAssessmentInput> | BulkAssessmentResponseCreateWithoutAssessmentInput[] | BulkAssessmentResponseUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: BulkAssessmentResponseCreateOrConnectWithoutAssessmentInput | BulkAssessmentResponseCreateOrConnectWithoutAssessmentInput[]
    upsert?: BulkAssessmentResponseUpsertWithWhereUniqueWithoutAssessmentInput | BulkAssessmentResponseUpsertWithWhereUniqueWithoutAssessmentInput[]
    createMany?: BulkAssessmentResponseCreateManyAssessmentInputEnvelope
    set?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
    disconnect?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
    delete?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
    connect?: BulkAssessmentResponseWhereUniqueInput | BulkAssessmentResponseWhereUniqueInput[]
    update?: BulkAssessmentResponseUpdateWithWhereUniqueWithoutAssessmentInput | BulkAssessmentResponseUpdateWithWhereUniqueWithoutAssessmentInput[]
    updateMany?: BulkAssessmentResponseUpdateManyWithWhereWithoutAssessmentInput | BulkAssessmentResponseUpdateManyWithWhereWithoutAssessmentInput[]
    deleteMany?: BulkAssessmentResponseScalarWhereInput | BulkAssessmentResponseScalarWhereInput[]
  }

  export type BulkAssessmentCreateNestedOneWithoutResponsesInput = {
    create?: XOR<BulkAssessmentCreateWithoutResponsesInput, BulkAssessmentUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: BulkAssessmentCreateOrConnectWithoutResponsesInput
    connect?: BulkAssessmentWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutBulkAssessmentResponsesInput = {
    create?: XOR<AgentCreateWithoutBulkAssessmentResponsesInput, AgentUncheckedCreateWithoutBulkAssessmentResponsesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutBulkAssessmentResponsesInput
    connect?: AgentWhereUniqueInput
  }

  export type EnumResponseStatusFieldUpdateOperationsInput = {
    set?: $Enums.ResponseStatus
  }

  export type BulkAssessmentUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<BulkAssessmentCreateWithoutResponsesInput, BulkAssessmentUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: BulkAssessmentCreateOrConnectWithoutResponsesInput
    upsert?: BulkAssessmentUpsertWithoutResponsesInput
    connect?: BulkAssessmentWhereUniqueInput
    update?: XOR<XOR<BulkAssessmentUpdateToOneWithWhereWithoutResponsesInput, BulkAssessmentUpdateWithoutResponsesInput>, BulkAssessmentUncheckedUpdateWithoutResponsesInput>
  }

  export type AgentUpdateOneRequiredWithoutBulkAssessmentResponsesNestedInput = {
    create?: XOR<AgentCreateWithoutBulkAssessmentResponsesInput, AgentUncheckedCreateWithoutBulkAssessmentResponsesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutBulkAssessmentResponsesInput
    upsert?: AgentUpsertWithoutBulkAssessmentResponsesInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutBulkAssessmentResponsesInput, AgentUpdateWithoutBulkAssessmentResponsesInput>, AgentUncheckedUpdateWithoutBulkAssessmentResponsesInput>
  }

  export type QuestionCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<UserCreateWithoutQuestionsInput, UserUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionCategoryCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<QuestionCategoryCreateWithoutQuestionsInput, QuestionCategoryUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuestionCategoryCreateOrConnectWithoutQuestionsInput
    connect?: QuestionCategoryWhereUniqueInput
  }

  export type AnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput> | AnswerCreateWithoutQuestionInput[] | AnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutQuestionInput | AnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: AnswerCreateManyQuestionInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type AnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput> | AnswerCreateWithoutQuestionInput[] | AnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutQuestionInput | AnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: AnswerCreateManyQuestionInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type QuestionUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumQuestionStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuestionStatus
  }

  export type UserUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<UserCreateWithoutQuestionsInput, UserUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsInput
    upsert?: UserUpsertWithoutQuestionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuestionsInput, UserUpdateWithoutQuestionsInput>, UserUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuestionCategoryUpdateOneWithoutQuestionsNestedInput = {
    create?: XOR<QuestionCategoryCreateWithoutQuestionsInput, QuestionCategoryUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuestionCategoryCreateOrConnectWithoutQuestionsInput
    upsert?: QuestionCategoryUpsertWithoutQuestionsInput
    disconnect?: QuestionCategoryWhereInput | boolean
    delete?: QuestionCategoryWhereInput | boolean
    connect?: QuestionCategoryWhereUniqueInput
    update?: XOR<XOR<QuestionCategoryUpdateToOneWithWhereWithoutQuestionsInput, QuestionCategoryUpdateWithoutQuestionsInput>, QuestionCategoryUncheckedUpdateWithoutQuestionsInput>
  }

  export type AnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput> | AnswerCreateWithoutQuestionInput[] | AnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutQuestionInput | AnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutQuestionInput | AnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: AnswerCreateManyQuestionInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutQuestionInput | AnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutQuestionInput | AnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type AnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput> | AnswerCreateWithoutQuestionInput[] | AnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutQuestionInput | AnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutQuestionInput | AnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: AnswerCreateManyQuestionInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutQuestionInput | AnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutQuestionInput | AnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type QuestionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutAnswersInput
    connect?: QuestionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAnswersInput = {
    create?: XOR<UserCreateWithoutAnswersInput, UserUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnswersInput
    connect?: UserWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutAnswersInput = {
    create?: XOR<AgentCreateWithoutAnswersInput, AgentUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAnswersInput
    connect?: AgentWhereUniqueInput
  }

  export type QuestionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutAnswersInput
    upsert?: QuestionUpsertWithoutAnswersInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutAnswersInput, QuestionUpdateWithoutAnswersInput>, QuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type UserUpdateOneWithoutAnswersNestedInput = {
    create?: XOR<UserCreateWithoutAnswersInput, UserUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnswersInput
    upsert?: UserUpsertWithoutAnswersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnswersInput, UserUpdateWithoutAnswersInput>, UserUncheckedUpdateWithoutAnswersInput>
  }

  export type AgentUpdateOneWithoutAnswersNestedInput = {
    create?: XOR<AgentCreateWithoutAnswersInput, AgentUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAnswersInput
    upsert?: AgentUpsertWithoutAnswersInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutAnswersInput, AgentUpdateWithoutAnswersInput>, AgentUncheckedUpdateWithoutAnswersInput>
  }

  export type PropertyFeatureCreateNestedManyWithoutFeatureInput = {
    create?: XOR<PropertyFeatureCreateWithoutFeatureInput, PropertyFeatureUncheckedCreateWithoutFeatureInput> | PropertyFeatureCreateWithoutFeatureInput[] | PropertyFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: PropertyFeatureCreateOrConnectWithoutFeatureInput | PropertyFeatureCreateOrConnectWithoutFeatureInput[]
    createMany?: PropertyFeatureCreateManyFeatureInputEnvelope
    connect?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
  }

  export type PropertyFeatureUncheckedCreateNestedManyWithoutFeatureInput = {
    create?: XOR<PropertyFeatureCreateWithoutFeatureInput, PropertyFeatureUncheckedCreateWithoutFeatureInput> | PropertyFeatureCreateWithoutFeatureInput[] | PropertyFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: PropertyFeatureCreateOrConnectWithoutFeatureInput | PropertyFeatureCreateOrConnectWithoutFeatureInput[]
    createMany?: PropertyFeatureCreateManyFeatureInputEnvelope
    connect?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
  }

  export type EnumFeatureCategoryFieldUpdateOperationsInput = {
    set?: $Enums.FeatureCategory
  }

  export type PropertyFeatureUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<PropertyFeatureCreateWithoutFeatureInput, PropertyFeatureUncheckedCreateWithoutFeatureInput> | PropertyFeatureCreateWithoutFeatureInput[] | PropertyFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: PropertyFeatureCreateOrConnectWithoutFeatureInput | PropertyFeatureCreateOrConnectWithoutFeatureInput[]
    upsert?: PropertyFeatureUpsertWithWhereUniqueWithoutFeatureInput | PropertyFeatureUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: PropertyFeatureCreateManyFeatureInputEnvelope
    set?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    disconnect?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    delete?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    connect?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    update?: PropertyFeatureUpdateWithWhereUniqueWithoutFeatureInput | PropertyFeatureUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: PropertyFeatureUpdateManyWithWhereWithoutFeatureInput | PropertyFeatureUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: PropertyFeatureScalarWhereInput | PropertyFeatureScalarWhereInput[]
  }

  export type PropertyFeatureUncheckedUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<PropertyFeatureCreateWithoutFeatureInput, PropertyFeatureUncheckedCreateWithoutFeatureInput> | PropertyFeatureCreateWithoutFeatureInput[] | PropertyFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: PropertyFeatureCreateOrConnectWithoutFeatureInput | PropertyFeatureCreateOrConnectWithoutFeatureInput[]
    upsert?: PropertyFeatureUpsertWithWhereUniqueWithoutFeatureInput | PropertyFeatureUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: PropertyFeatureCreateManyFeatureInputEnvelope
    set?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    disconnect?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    delete?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    connect?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    update?: PropertyFeatureUpdateWithWhereUniqueWithoutFeatureInput | PropertyFeatureUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: PropertyFeatureUpdateManyWithWhereWithoutFeatureInput | PropertyFeatureUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: PropertyFeatureScalarWhereInput | PropertyFeatureScalarWhereInput[]
  }

  export type AreaMasterCreateNestedManyWithoutRegionInput = {
    create?: XOR<AreaMasterCreateWithoutRegionInput, AreaMasterUncheckedCreateWithoutRegionInput> | AreaMasterCreateWithoutRegionInput[] | AreaMasterUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: AreaMasterCreateOrConnectWithoutRegionInput | AreaMasterCreateOrConnectWithoutRegionInput[]
    createMany?: AreaMasterCreateManyRegionInputEnvelope
    connect?: AreaMasterWhereUniqueInput | AreaMasterWhereUniqueInput[]
  }

  export type AreaMasterUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<AreaMasterCreateWithoutRegionInput, AreaMasterUncheckedCreateWithoutRegionInput> | AreaMasterCreateWithoutRegionInput[] | AreaMasterUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: AreaMasterCreateOrConnectWithoutRegionInput | AreaMasterCreateOrConnectWithoutRegionInput[]
    createMany?: AreaMasterCreateManyRegionInputEnvelope
    connect?: AreaMasterWhereUniqueInput | AreaMasterWhereUniqueInput[]
  }

  export type AreaMasterUpdateManyWithoutRegionNestedInput = {
    create?: XOR<AreaMasterCreateWithoutRegionInput, AreaMasterUncheckedCreateWithoutRegionInput> | AreaMasterCreateWithoutRegionInput[] | AreaMasterUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: AreaMasterCreateOrConnectWithoutRegionInput | AreaMasterCreateOrConnectWithoutRegionInput[]
    upsert?: AreaMasterUpsertWithWhereUniqueWithoutRegionInput | AreaMasterUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: AreaMasterCreateManyRegionInputEnvelope
    set?: AreaMasterWhereUniqueInput | AreaMasterWhereUniqueInput[]
    disconnect?: AreaMasterWhereUniqueInput | AreaMasterWhereUniqueInput[]
    delete?: AreaMasterWhereUniqueInput | AreaMasterWhereUniqueInput[]
    connect?: AreaMasterWhereUniqueInput | AreaMasterWhereUniqueInput[]
    update?: AreaMasterUpdateWithWhereUniqueWithoutRegionInput | AreaMasterUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: AreaMasterUpdateManyWithWhereWithoutRegionInput | AreaMasterUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: AreaMasterScalarWhereInput | AreaMasterScalarWhereInput[]
  }

  export type AreaMasterUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<AreaMasterCreateWithoutRegionInput, AreaMasterUncheckedCreateWithoutRegionInput> | AreaMasterCreateWithoutRegionInput[] | AreaMasterUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: AreaMasterCreateOrConnectWithoutRegionInput | AreaMasterCreateOrConnectWithoutRegionInput[]
    upsert?: AreaMasterUpsertWithWhereUniqueWithoutRegionInput | AreaMasterUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: AreaMasterCreateManyRegionInputEnvelope
    set?: AreaMasterWhereUniqueInput | AreaMasterWhereUniqueInput[]
    disconnect?: AreaMasterWhereUniqueInput | AreaMasterWhereUniqueInput[]
    delete?: AreaMasterWhereUniqueInput | AreaMasterWhereUniqueInput[]
    connect?: AreaMasterWhereUniqueInput | AreaMasterWhereUniqueInput[]
    update?: AreaMasterUpdateWithWhereUniqueWithoutRegionInput | AreaMasterUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: AreaMasterUpdateManyWithWhereWithoutRegionInput | AreaMasterUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: AreaMasterScalarWhereInput | AreaMasterScalarWhereInput[]
  }

  export type RegionMasterCreateNestedOneWithoutAreasInput = {
    create?: XOR<RegionMasterCreateWithoutAreasInput, RegionMasterUncheckedCreateWithoutAreasInput>
    connectOrCreate?: RegionMasterCreateOrConnectWithoutAreasInput
    connect?: RegionMasterWhereUniqueInput
  }

  export type PropertyCreateNestedManyWithoutAreaInput = {
    create?: XOR<PropertyCreateWithoutAreaInput, PropertyUncheckedCreateWithoutAreaInput> | PropertyCreateWithoutAreaInput[] | PropertyUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutAreaInput | PropertyCreateOrConnectWithoutAreaInput[]
    createMany?: PropertyCreateManyAreaInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<PropertyCreateWithoutAreaInput, PropertyUncheckedCreateWithoutAreaInput> | PropertyCreateWithoutAreaInput[] | PropertyUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutAreaInput | PropertyCreateOrConnectWithoutAreaInput[]
    createMany?: PropertyCreateManyAreaInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type RegionMasterUpdateOneWithoutAreasNestedInput = {
    create?: XOR<RegionMasterCreateWithoutAreasInput, RegionMasterUncheckedCreateWithoutAreasInput>
    connectOrCreate?: RegionMasterCreateOrConnectWithoutAreasInput
    upsert?: RegionMasterUpsertWithoutAreasInput
    disconnect?: RegionMasterWhereInput | boolean
    delete?: RegionMasterWhereInput | boolean
    connect?: RegionMasterWhereUniqueInput
    update?: XOR<XOR<RegionMasterUpdateToOneWithWhereWithoutAreasInput, RegionMasterUpdateWithoutAreasInput>, RegionMasterUncheckedUpdateWithoutAreasInput>
  }

  export type PropertyUpdateManyWithoutAreaNestedInput = {
    create?: XOR<PropertyCreateWithoutAreaInput, PropertyUncheckedCreateWithoutAreaInput> | PropertyCreateWithoutAreaInput[] | PropertyUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutAreaInput | PropertyCreateOrConnectWithoutAreaInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutAreaInput | PropertyUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: PropertyCreateManyAreaInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutAreaInput | PropertyUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutAreaInput | PropertyUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<PropertyCreateWithoutAreaInput, PropertyUncheckedCreateWithoutAreaInput> | PropertyCreateWithoutAreaInput[] | PropertyUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutAreaInput | PropertyCreateOrConnectWithoutAreaInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutAreaInput | PropertyUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: PropertyCreateManyAreaInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutAreaInput | PropertyUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutAreaInput | PropertyUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyCreateNestedManyWithoutPropertyTypeInput = {
    create?: XOR<PropertyCreateWithoutPropertyTypeInput, PropertyUncheckedCreateWithoutPropertyTypeInput> | PropertyCreateWithoutPropertyTypeInput[] | PropertyUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyTypeInput | PropertyCreateOrConnectWithoutPropertyTypeInput[]
    createMany?: PropertyCreateManyPropertyTypeInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type BulkAssessmentCreateNestedManyWithoutPropertyTypeInput = {
    create?: XOR<BulkAssessmentCreateWithoutPropertyTypeInput, BulkAssessmentUncheckedCreateWithoutPropertyTypeInput> | BulkAssessmentCreateWithoutPropertyTypeInput[] | BulkAssessmentUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: BulkAssessmentCreateOrConnectWithoutPropertyTypeInput | BulkAssessmentCreateOrConnectWithoutPropertyTypeInput[]
    createMany?: BulkAssessmentCreateManyPropertyTypeInputEnvelope
    connect?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutPropertyTypeInput = {
    create?: XOR<PropertyCreateWithoutPropertyTypeInput, PropertyUncheckedCreateWithoutPropertyTypeInput> | PropertyCreateWithoutPropertyTypeInput[] | PropertyUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyTypeInput | PropertyCreateOrConnectWithoutPropertyTypeInput[]
    createMany?: PropertyCreateManyPropertyTypeInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type BulkAssessmentUncheckedCreateNestedManyWithoutPropertyTypeInput = {
    create?: XOR<BulkAssessmentCreateWithoutPropertyTypeInput, BulkAssessmentUncheckedCreateWithoutPropertyTypeInput> | BulkAssessmentCreateWithoutPropertyTypeInput[] | BulkAssessmentUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: BulkAssessmentCreateOrConnectWithoutPropertyTypeInput | BulkAssessmentCreateOrConnectWithoutPropertyTypeInput[]
    createMany?: BulkAssessmentCreateManyPropertyTypeInputEnvelope
    connect?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
  }

  export type PropertyUpdateManyWithoutPropertyTypeNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyTypeInput, PropertyUncheckedCreateWithoutPropertyTypeInput> | PropertyCreateWithoutPropertyTypeInput[] | PropertyUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyTypeInput | PropertyCreateOrConnectWithoutPropertyTypeInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutPropertyTypeInput | PropertyUpsertWithWhereUniqueWithoutPropertyTypeInput[]
    createMany?: PropertyCreateManyPropertyTypeInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutPropertyTypeInput | PropertyUpdateWithWhereUniqueWithoutPropertyTypeInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutPropertyTypeInput | PropertyUpdateManyWithWhereWithoutPropertyTypeInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type BulkAssessmentUpdateManyWithoutPropertyTypeNestedInput = {
    create?: XOR<BulkAssessmentCreateWithoutPropertyTypeInput, BulkAssessmentUncheckedCreateWithoutPropertyTypeInput> | BulkAssessmentCreateWithoutPropertyTypeInput[] | BulkAssessmentUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: BulkAssessmentCreateOrConnectWithoutPropertyTypeInput | BulkAssessmentCreateOrConnectWithoutPropertyTypeInput[]
    upsert?: BulkAssessmentUpsertWithWhereUniqueWithoutPropertyTypeInput | BulkAssessmentUpsertWithWhereUniqueWithoutPropertyTypeInput[]
    createMany?: BulkAssessmentCreateManyPropertyTypeInputEnvelope
    set?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
    disconnect?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
    delete?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
    connect?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
    update?: BulkAssessmentUpdateWithWhereUniqueWithoutPropertyTypeInput | BulkAssessmentUpdateWithWhereUniqueWithoutPropertyTypeInput[]
    updateMany?: BulkAssessmentUpdateManyWithWhereWithoutPropertyTypeInput | BulkAssessmentUpdateManyWithWhereWithoutPropertyTypeInput[]
    deleteMany?: BulkAssessmentScalarWhereInput | BulkAssessmentScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutPropertyTypeNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyTypeInput, PropertyUncheckedCreateWithoutPropertyTypeInput> | PropertyCreateWithoutPropertyTypeInput[] | PropertyUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyTypeInput | PropertyCreateOrConnectWithoutPropertyTypeInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutPropertyTypeInput | PropertyUpsertWithWhereUniqueWithoutPropertyTypeInput[]
    createMany?: PropertyCreateManyPropertyTypeInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutPropertyTypeInput | PropertyUpdateWithWhereUniqueWithoutPropertyTypeInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutPropertyTypeInput | PropertyUpdateManyWithWhereWithoutPropertyTypeInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type BulkAssessmentUncheckedUpdateManyWithoutPropertyTypeNestedInput = {
    create?: XOR<BulkAssessmentCreateWithoutPropertyTypeInput, BulkAssessmentUncheckedCreateWithoutPropertyTypeInput> | BulkAssessmentCreateWithoutPropertyTypeInput[] | BulkAssessmentUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: BulkAssessmentCreateOrConnectWithoutPropertyTypeInput | BulkAssessmentCreateOrConnectWithoutPropertyTypeInput[]
    upsert?: BulkAssessmentUpsertWithWhereUniqueWithoutPropertyTypeInput | BulkAssessmentUpsertWithWhereUniqueWithoutPropertyTypeInput[]
    createMany?: BulkAssessmentCreateManyPropertyTypeInputEnvelope
    set?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
    disconnect?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
    delete?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
    connect?: BulkAssessmentWhereUniqueInput | BulkAssessmentWhereUniqueInput[]
    update?: BulkAssessmentUpdateWithWhereUniqueWithoutPropertyTypeInput | BulkAssessmentUpdateWithWhereUniqueWithoutPropertyTypeInput[]
    updateMany?: BulkAssessmentUpdateManyWithWhereWithoutPropertyTypeInput | BulkAssessmentUpdateManyWithWhereWithoutPropertyTypeInput[]
    deleteMany?: BulkAssessmentScalarWhereInput | BulkAssessmentScalarWhereInput[]
  }

  export type PropertyCreateNestedManyWithoutPropertyCategoryInput = {
    create?: XOR<PropertyCreateWithoutPropertyCategoryInput, PropertyUncheckedCreateWithoutPropertyCategoryInput> | PropertyCreateWithoutPropertyCategoryInput[] | PropertyUncheckedCreateWithoutPropertyCategoryInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyCategoryInput | PropertyCreateOrConnectWithoutPropertyCategoryInput[]
    createMany?: PropertyCreateManyPropertyCategoryInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutPropertyCategoryInput = {
    create?: XOR<PropertyCreateWithoutPropertyCategoryInput, PropertyUncheckedCreateWithoutPropertyCategoryInput> | PropertyCreateWithoutPropertyCategoryInput[] | PropertyUncheckedCreateWithoutPropertyCategoryInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyCategoryInput | PropertyCreateOrConnectWithoutPropertyCategoryInput[]
    createMany?: PropertyCreateManyPropertyCategoryInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyUpdateManyWithoutPropertyCategoryNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyCategoryInput, PropertyUncheckedCreateWithoutPropertyCategoryInput> | PropertyCreateWithoutPropertyCategoryInput[] | PropertyUncheckedCreateWithoutPropertyCategoryInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyCategoryInput | PropertyCreateOrConnectWithoutPropertyCategoryInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutPropertyCategoryInput | PropertyUpsertWithWhereUniqueWithoutPropertyCategoryInput[]
    createMany?: PropertyCreateManyPropertyCategoryInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutPropertyCategoryInput | PropertyUpdateWithWhereUniqueWithoutPropertyCategoryInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutPropertyCategoryInput | PropertyUpdateManyWithWhereWithoutPropertyCategoryInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutPropertyCategoryNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyCategoryInput, PropertyUncheckedCreateWithoutPropertyCategoryInput> | PropertyCreateWithoutPropertyCategoryInput[] | PropertyUncheckedCreateWithoutPropertyCategoryInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyCategoryInput | PropertyCreateOrConnectWithoutPropertyCategoryInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutPropertyCategoryInput | PropertyUpsertWithWhereUniqueWithoutPropertyCategoryInput[]
    createMany?: PropertyCreateManyPropertyCategoryInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutPropertyCategoryInput | PropertyUpdateWithWhereUniqueWithoutPropertyCategoryInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutPropertyCategoryInput | PropertyUpdateManyWithWhereWithoutPropertyCategoryInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyCreateNestedManyWithoutLayoutTypeInput = {
    create?: XOR<PropertyCreateWithoutLayoutTypeInput, PropertyUncheckedCreateWithoutLayoutTypeInput> | PropertyCreateWithoutLayoutTypeInput[] | PropertyUncheckedCreateWithoutLayoutTypeInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutLayoutTypeInput | PropertyCreateOrConnectWithoutLayoutTypeInput[]
    createMany?: PropertyCreateManyLayoutTypeInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutLayoutTypeInput = {
    create?: XOR<PropertyCreateWithoutLayoutTypeInput, PropertyUncheckedCreateWithoutLayoutTypeInput> | PropertyCreateWithoutLayoutTypeInput[] | PropertyUncheckedCreateWithoutLayoutTypeInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutLayoutTypeInput | PropertyCreateOrConnectWithoutLayoutTypeInput[]
    createMany?: PropertyCreateManyLayoutTypeInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyUpdateManyWithoutLayoutTypeNestedInput = {
    create?: XOR<PropertyCreateWithoutLayoutTypeInput, PropertyUncheckedCreateWithoutLayoutTypeInput> | PropertyCreateWithoutLayoutTypeInput[] | PropertyUncheckedCreateWithoutLayoutTypeInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutLayoutTypeInput | PropertyCreateOrConnectWithoutLayoutTypeInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutLayoutTypeInput | PropertyUpsertWithWhereUniqueWithoutLayoutTypeInput[]
    createMany?: PropertyCreateManyLayoutTypeInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutLayoutTypeInput | PropertyUpdateWithWhereUniqueWithoutLayoutTypeInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutLayoutTypeInput | PropertyUpdateManyWithWhereWithoutLayoutTypeInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutLayoutTypeNestedInput = {
    create?: XOR<PropertyCreateWithoutLayoutTypeInput, PropertyUncheckedCreateWithoutLayoutTypeInput> | PropertyCreateWithoutLayoutTypeInput[] | PropertyUncheckedCreateWithoutLayoutTypeInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutLayoutTypeInput | PropertyCreateOrConnectWithoutLayoutTypeInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutLayoutTypeInput | PropertyUpsertWithWhereUniqueWithoutLayoutTypeInput[]
    createMany?: PropertyCreateManyLayoutTypeInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutLayoutTypeInput | PropertyUpdateWithWhereUniqueWithoutLayoutTypeInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutLayoutTypeInput | PropertyUpdateManyWithWhereWithoutLayoutTypeInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type StationCreateNestedManyWithoutRouteInput = {
    create?: XOR<StationCreateWithoutRouteInput, StationUncheckedCreateWithoutRouteInput> | StationCreateWithoutRouteInput[] | StationUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: StationCreateOrConnectWithoutRouteInput | StationCreateOrConnectWithoutRouteInput[]
    createMany?: StationCreateManyRouteInputEnvelope
    connect?: StationWhereUniqueInput | StationWhereUniqueInput[]
  }

  export type StationUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<StationCreateWithoutRouteInput, StationUncheckedCreateWithoutRouteInput> | StationCreateWithoutRouteInput[] | StationUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: StationCreateOrConnectWithoutRouteInput | StationCreateOrConnectWithoutRouteInput[]
    createMany?: StationCreateManyRouteInputEnvelope
    connect?: StationWhereUniqueInput | StationWhereUniqueInput[]
  }

  export type StationUpdateManyWithoutRouteNestedInput = {
    create?: XOR<StationCreateWithoutRouteInput, StationUncheckedCreateWithoutRouteInput> | StationCreateWithoutRouteInput[] | StationUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: StationCreateOrConnectWithoutRouteInput | StationCreateOrConnectWithoutRouteInput[]
    upsert?: StationUpsertWithWhereUniqueWithoutRouteInput | StationUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: StationCreateManyRouteInputEnvelope
    set?: StationWhereUniqueInput | StationWhereUniqueInput[]
    disconnect?: StationWhereUniqueInput | StationWhereUniqueInput[]
    delete?: StationWhereUniqueInput | StationWhereUniqueInput[]
    connect?: StationWhereUniqueInput | StationWhereUniqueInput[]
    update?: StationUpdateWithWhereUniqueWithoutRouteInput | StationUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: StationUpdateManyWithWhereWithoutRouteInput | StationUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: StationScalarWhereInput | StationScalarWhereInput[]
  }

  export type StationUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<StationCreateWithoutRouteInput, StationUncheckedCreateWithoutRouteInput> | StationCreateWithoutRouteInput[] | StationUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: StationCreateOrConnectWithoutRouteInput | StationCreateOrConnectWithoutRouteInput[]
    upsert?: StationUpsertWithWhereUniqueWithoutRouteInput | StationUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: StationCreateManyRouteInputEnvelope
    set?: StationWhereUniqueInput | StationWhereUniqueInput[]
    disconnect?: StationWhereUniqueInput | StationWhereUniqueInput[]
    delete?: StationWhereUniqueInput | StationWhereUniqueInput[]
    connect?: StationWhereUniqueInput | StationWhereUniqueInput[]
    update?: StationUpdateWithWhereUniqueWithoutRouteInput | StationUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: StationUpdateManyWithWhereWithoutRouteInput | StationUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: StationScalarWhereInput | StationScalarWhereInput[]
  }

  export type RouteMasterCreateNestedOneWithoutStationsInput = {
    create?: XOR<RouteMasterCreateWithoutStationsInput, RouteMasterUncheckedCreateWithoutStationsInput>
    connectOrCreate?: RouteMasterCreateOrConnectWithoutStationsInput
    connect?: RouteMasterWhereUniqueInput
  }

  export type PropertyStationCreateNestedManyWithoutStationInput = {
    create?: XOR<PropertyStationCreateWithoutStationInput, PropertyStationUncheckedCreateWithoutStationInput> | PropertyStationCreateWithoutStationInput[] | PropertyStationUncheckedCreateWithoutStationInput[]
    connectOrCreate?: PropertyStationCreateOrConnectWithoutStationInput | PropertyStationCreateOrConnectWithoutStationInput[]
    createMany?: PropertyStationCreateManyStationInputEnvelope
    connect?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
  }

  export type PropertyStationUncheckedCreateNestedManyWithoutStationInput = {
    create?: XOR<PropertyStationCreateWithoutStationInput, PropertyStationUncheckedCreateWithoutStationInput> | PropertyStationCreateWithoutStationInput[] | PropertyStationUncheckedCreateWithoutStationInput[]
    connectOrCreate?: PropertyStationCreateOrConnectWithoutStationInput | PropertyStationCreateOrConnectWithoutStationInput[]
    createMany?: PropertyStationCreateManyStationInputEnvelope
    connect?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
  }

  export type RouteMasterUpdateOneWithoutStationsNestedInput = {
    create?: XOR<RouteMasterCreateWithoutStationsInput, RouteMasterUncheckedCreateWithoutStationsInput>
    connectOrCreate?: RouteMasterCreateOrConnectWithoutStationsInput
    upsert?: RouteMasterUpsertWithoutStationsInput
    disconnect?: RouteMasterWhereInput | boolean
    delete?: RouteMasterWhereInput | boolean
    connect?: RouteMasterWhereUniqueInput
    update?: XOR<XOR<RouteMasterUpdateToOneWithWhereWithoutStationsInput, RouteMasterUpdateWithoutStationsInput>, RouteMasterUncheckedUpdateWithoutStationsInput>
  }

  export type PropertyStationUpdateManyWithoutStationNestedInput = {
    create?: XOR<PropertyStationCreateWithoutStationInput, PropertyStationUncheckedCreateWithoutStationInput> | PropertyStationCreateWithoutStationInput[] | PropertyStationUncheckedCreateWithoutStationInput[]
    connectOrCreate?: PropertyStationCreateOrConnectWithoutStationInput | PropertyStationCreateOrConnectWithoutStationInput[]
    upsert?: PropertyStationUpsertWithWhereUniqueWithoutStationInput | PropertyStationUpsertWithWhereUniqueWithoutStationInput[]
    createMany?: PropertyStationCreateManyStationInputEnvelope
    set?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
    disconnect?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
    delete?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
    connect?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
    update?: PropertyStationUpdateWithWhereUniqueWithoutStationInput | PropertyStationUpdateWithWhereUniqueWithoutStationInput[]
    updateMany?: PropertyStationUpdateManyWithWhereWithoutStationInput | PropertyStationUpdateManyWithWhereWithoutStationInput[]
    deleteMany?: PropertyStationScalarWhereInput | PropertyStationScalarWhereInput[]
  }

  export type PropertyStationUncheckedUpdateManyWithoutStationNestedInput = {
    create?: XOR<PropertyStationCreateWithoutStationInput, PropertyStationUncheckedCreateWithoutStationInput> | PropertyStationCreateWithoutStationInput[] | PropertyStationUncheckedCreateWithoutStationInput[]
    connectOrCreate?: PropertyStationCreateOrConnectWithoutStationInput | PropertyStationCreateOrConnectWithoutStationInput[]
    upsert?: PropertyStationUpsertWithWhereUniqueWithoutStationInput | PropertyStationUpsertWithWhereUniqueWithoutStationInput[]
    createMany?: PropertyStationCreateManyStationInputEnvelope
    set?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
    disconnect?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
    delete?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
    connect?: PropertyStationWhereUniqueInput | PropertyStationWhereUniqueInput[]
    update?: PropertyStationUpdateWithWhereUniqueWithoutStationInput | PropertyStationUpdateWithWhereUniqueWithoutStationInput[]
    updateMany?: PropertyStationUpdateManyWithWhereWithoutStationInput | PropertyStationUpdateManyWithWhereWithoutStationInput[]
    deleteMany?: PropertyStationScalarWhereInput | PropertyStationScalarWhereInput[]
  }

  export type QuestionCreateNestedManyWithoutCategoryInput = {
    create?: XOR<QuestionCreateWithoutCategoryInput, QuestionUncheckedCreateWithoutCategoryInput> | QuestionCreateWithoutCategoryInput[] | QuestionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCategoryInput | QuestionCreateOrConnectWithoutCategoryInput[]
    createMany?: QuestionCreateManyCategoryInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<QuestionCreateWithoutCategoryInput, QuestionUncheckedCreateWithoutCategoryInput> | QuestionCreateWithoutCategoryInput[] | QuestionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCategoryInput | QuestionCreateOrConnectWithoutCategoryInput[]
    createMany?: QuestionCreateManyCategoryInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type QuestionUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<QuestionCreateWithoutCategoryInput, QuestionUncheckedCreateWithoutCategoryInput> | QuestionCreateWithoutCategoryInput[] | QuestionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCategoryInput | QuestionCreateOrConnectWithoutCategoryInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutCategoryInput | QuestionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: QuestionCreateManyCategoryInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutCategoryInput | QuestionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutCategoryInput | QuestionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<QuestionCreateWithoutCategoryInput, QuestionUncheckedCreateWithoutCategoryInput> | QuestionCreateWithoutCategoryInput[] | QuestionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCategoryInput | QuestionCreateOrConnectWithoutCategoryInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutCategoryInput | QuestionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: QuestionCreateManyCategoryInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutCategoryInput | QuestionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutCategoryInput | QuestionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type MailCreateccEmailInput = {
    set: string[]
  }

  export type MailCreatebccEmailInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutMailsInput = {
    create?: XOR<UserCreateWithoutMailsInput, UserUncheckedCreateWithoutMailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMailsInput
    connect?: UserWhereUniqueInput
  }

  export type MailUpdateccEmailInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MailUpdatebccEmailInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumMailStatusFieldUpdateOperationsInput = {
    set?: $Enums.MailStatus
  }

  export type EnumMailTypeFieldUpdateOperationsInput = {
    set?: $Enums.MailType
  }

  export type UserUpdateOneWithoutMailsNestedInput = {
    create?: XOR<UserCreateWithoutMailsInput, UserUncheckedCreateWithoutMailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMailsInput
    upsert?: UserUpsertWithoutMailsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMailsInput, UserUpdateWithoutMailsInput>, UserUncheckedUpdateWithoutMailsInput>
  }

  export type UserCreateNestedOneWithoutFileBoxesInput = {
    create?: XOR<UserCreateWithoutFileBoxesInput, UserUncheckedCreateWithoutFileBoxesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFileBoxesInput
    connect?: UserWhereUniqueInput
  }

  export type PropertyImageCreateNestedManyWithoutFileBoxInput = {
    create?: XOR<PropertyImageCreateWithoutFileBoxInput, PropertyImageUncheckedCreateWithoutFileBoxInput> | PropertyImageCreateWithoutFileBoxInput[] | PropertyImageUncheckedCreateWithoutFileBoxInput[]
    connectOrCreate?: PropertyImageCreateOrConnectWithoutFileBoxInput | PropertyImageCreateOrConnectWithoutFileBoxInput[]
    createMany?: PropertyImageCreateManyFileBoxInputEnvelope
    connect?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
  }

  export type PropertyImageUncheckedCreateNestedManyWithoutFileBoxInput = {
    create?: XOR<PropertyImageCreateWithoutFileBoxInput, PropertyImageUncheckedCreateWithoutFileBoxInput> | PropertyImageCreateWithoutFileBoxInput[] | PropertyImageUncheckedCreateWithoutFileBoxInput[]
    connectOrCreate?: PropertyImageCreateOrConnectWithoutFileBoxInput | PropertyImageCreateOrConnectWithoutFileBoxInput[]
    createMany?: PropertyImageCreateManyFileBoxInputEnvelope
    connect?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutFileBoxesNestedInput = {
    create?: XOR<UserCreateWithoutFileBoxesInput, UserUncheckedCreateWithoutFileBoxesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFileBoxesInput
    upsert?: UserUpsertWithoutFileBoxesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFileBoxesInput, UserUpdateWithoutFileBoxesInput>, UserUncheckedUpdateWithoutFileBoxesInput>
  }

  export type PropertyImageUpdateManyWithoutFileBoxNestedInput = {
    create?: XOR<PropertyImageCreateWithoutFileBoxInput, PropertyImageUncheckedCreateWithoutFileBoxInput> | PropertyImageCreateWithoutFileBoxInput[] | PropertyImageUncheckedCreateWithoutFileBoxInput[]
    connectOrCreate?: PropertyImageCreateOrConnectWithoutFileBoxInput | PropertyImageCreateOrConnectWithoutFileBoxInput[]
    upsert?: PropertyImageUpsertWithWhereUniqueWithoutFileBoxInput | PropertyImageUpsertWithWhereUniqueWithoutFileBoxInput[]
    createMany?: PropertyImageCreateManyFileBoxInputEnvelope
    set?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    disconnect?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    delete?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    connect?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    update?: PropertyImageUpdateWithWhereUniqueWithoutFileBoxInput | PropertyImageUpdateWithWhereUniqueWithoutFileBoxInput[]
    updateMany?: PropertyImageUpdateManyWithWhereWithoutFileBoxInput | PropertyImageUpdateManyWithWhereWithoutFileBoxInput[]
    deleteMany?: PropertyImageScalarWhereInput | PropertyImageScalarWhereInput[]
  }

  export type PropertyImageUncheckedUpdateManyWithoutFileBoxNestedInput = {
    create?: XOR<PropertyImageCreateWithoutFileBoxInput, PropertyImageUncheckedCreateWithoutFileBoxInput> | PropertyImageCreateWithoutFileBoxInput[] | PropertyImageUncheckedCreateWithoutFileBoxInput[]
    connectOrCreate?: PropertyImageCreateOrConnectWithoutFileBoxInput | PropertyImageCreateOrConnectWithoutFileBoxInput[]
    upsert?: PropertyImageUpsertWithWhereUniqueWithoutFileBoxInput | PropertyImageUpsertWithWhereUniqueWithoutFileBoxInput[]
    createMany?: PropertyImageCreateManyFileBoxInputEnvelope
    set?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    disconnect?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    delete?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    connect?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    update?: PropertyImageUpdateWithWhereUniqueWithoutFileBoxInput | PropertyImageUpdateWithWhereUniqueWithoutFileBoxInput[]
    updateMany?: PropertyImageUpdateManyWithWhereWithoutFileBoxInput | PropertyImageUpdateManyWithWhereWithoutFileBoxInput[]
    deleteMany?: PropertyImageScalarWhereInput | PropertyImageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSystemSettingsUpdatedInput = {
    create?: XOR<UserCreateWithoutSystemSettingsUpdatedInput, UserUncheckedCreateWithoutSystemSettingsUpdatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutSystemSettingsUpdatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutSystemSettingsUpdatedNestedInput = {
    create?: XOR<UserCreateWithoutSystemSettingsUpdatedInput, UserUncheckedCreateWithoutSystemSettingsUpdatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutSystemSettingsUpdatedInput
    upsert?: UserUpsertWithoutSystemSettingsUpdatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSystemSettingsUpdatedInput, UserUpdateWithoutSystemSettingsUpdatedInput>, UserUncheckedUpdateWithoutSystemSettingsUpdatedInput>
  }

  export type AuditLogCreatechangedFieldsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.AuditAction
  }

  export type AuditLogUpdatechangedFieldsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedEnumCompanyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatus | EnumCompanyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatus[] | ListEnumCompanyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyStatus[] | ListEnumCompanyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyStatusFilter<$PrismaModel> | $Enums.CompanyStatus
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedEnumCompanyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatus | EnumCompanyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatus[] | ListEnumCompanyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyStatus[] | ListEnumCompanyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyStatusWithAggregatesFilter<$PrismaModel> | $Enums.CompanyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyStatusFilter<$PrismaModel>
    _max?: NestedEnumCompanyStatusFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumTransactionTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTransactionTypeNullableFilter<$PrismaModel> | $Enums.TransactionType | null
  }

  export type NestedEnumPropertyConditionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyCondition | EnumPropertyConditionFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyCondition[] | ListEnumPropertyConditionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyCondition[] | ListEnumPropertyConditionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyConditionNullableFilter<$PrismaModel> | $Enums.PropertyCondition | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTransactionTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPropertyConditionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyCondition | EnumPropertyConditionFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyCondition[] | ListEnumPropertyConditionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyCondition[] | ListEnumPropertyConditionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyConditionNullableWithAggregatesFilter<$PrismaModel> | $Enums.PropertyCondition | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPropertyConditionNullableFilter<$PrismaModel>
    _max?: NestedEnumPropertyConditionNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumPublicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicationStatus | EnumPublicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicationStatusFilter<$PrismaModel> | $Enums.PublicationStatus
  }

  export type NestedEnumPublicScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicScope | EnumPublicScopeFieldRefInput<$PrismaModel>
    in?: $Enums.PublicScope[] | ListEnumPublicScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicScope[] | ListEnumPublicScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicScopeFilter<$PrismaModel> | $Enums.PublicScope
  }

  export type NestedEnumPublicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicationStatus | EnumPublicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.PublicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublicationStatusFilter<$PrismaModel>
    _max?: NestedEnumPublicationStatusFilter<$PrismaModel>
  }

  export type NestedEnumPublicScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicScope | EnumPublicScopeFieldRefInput<$PrismaModel>
    in?: $Enums.PublicScope[] | ListEnumPublicScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicScope[] | ListEnumPublicScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicScopeWithAggregatesFilter<$PrismaModel> | $Enums.PublicScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublicScopeFilter<$PrismaModel>
    _max?: NestedEnumPublicScopeFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumImageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageType | EnumImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImageType[] | ListEnumImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageType[] | ListEnumImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImageTypeFilter<$PrismaModel> | $Enums.ImageType
  }

  export type NestedEnumImageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageType | EnumImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImageType[] | ListEnumImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageType[] | ListEnumImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImageTypeWithAggregatesFilter<$PrismaModel> | $Enums.ImageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImageTypeFilter<$PrismaModel>
    _max?: NestedEnumImageTypeFilter<$PrismaModel>
  }

  export type NestedEnumTargetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TargetType | EnumTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TargetType[] | ListEnumTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TargetType[] | ListEnumTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTargetTypeFilter<$PrismaModel> | $Enums.TargetType
  }

  export type NestedEnumInquiryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryType | EnumInquiryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryType[] | ListEnumInquiryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryType[] | ListEnumInquiryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryTypeFilter<$PrismaModel> | $Enums.InquiryType
  }

  export type NestedEnumInquiryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryStatus | EnumInquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryStatusFilter<$PrismaModel> | $Enums.InquiryStatus
  }

  export type NestedEnumInquiryPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryPriority | EnumInquiryPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryPriority[] | ListEnumInquiryPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryPriority[] | ListEnumInquiryPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryPriorityFilter<$PrismaModel> | $Enums.InquiryPriority
  }

  export type NestedEnumTargetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TargetType | EnumTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TargetType[] | ListEnumTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TargetType[] | ListEnumTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTargetTypeWithAggregatesFilter<$PrismaModel> | $Enums.TargetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTargetTypeFilter<$PrismaModel>
    _max?: NestedEnumTargetTypeFilter<$PrismaModel>
  }

  export type NestedEnumInquiryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryType | EnumInquiryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryType[] | ListEnumInquiryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryType[] | ListEnumInquiryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryTypeWithAggregatesFilter<$PrismaModel> | $Enums.InquiryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInquiryTypeFilter<$PrismaModel>
    _max?: NestedEnumInquiryTypeFilter<$PrismaModel>
  }

  export type NestedEnumInquiryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryStatus | EnumInquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InquiryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInquiryStatusFilter<$PrismaModel>
    _max?: NestedEnumInquiryStatusFilter<$PrismaModel>
  }

  export type NestedEnumInquiryPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryPriority | EnumInquiryPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryPriority[] | ListEnumInquiryPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryPriority[] | ListEnumInquiryPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryPriorityWithAggregatesFilter<$PrismaModel> | $Enums.InquiryPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInquiryPriorityFilter<$PrismaModel>
    _max?: NestedEnumInquiryPriorityFilter<$PrismaModel>
  }

  export type NestedEnumSenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeFilter<$PrismaModel> | $Enums.SenderType
  }

  export type NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.SenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSenderTypeFilter<$PrismaModel>
    _max?: NestedEnumSenderTypeFilter<$PrismaModel>
  }

  export type NestedEnumAssessmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentStatus | EnumAssessmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssessmentStatus[] | ListEnumAssessmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssessmentStatus[] | ListEnumAssessmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssessmentStatusFilter<$PrismaModel> | $Enums.AssessmentStatus
  }

  export type NestedEnumAssessmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentStatus | EnumAssessmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssessmentStatus[] | ListEnumAssessmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssessmentStatus[] | ListEnumAssessmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssessmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssessmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssessmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAssessmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumResponseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ResponseStatus | EnumResponseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ResponseStatus[] | ListEnumResponseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResponseStatus[] | ListEnumResponseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumResponseStatusFilter<$PrismaModel> | $Enums.ResponseStatus
  }

  export type NestedEnumResponseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResponseStatus | EnumResponseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ResponseStatus[] | ListEnumResponseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResponseStatus[] | ListEnumResponseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumResponseStatusWithAggregatesFilter<$PrismaModel> | $Enums.ResponseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResponseStatusFilter<$PrismaModel>
    _max?: NestedEnumResponseStatusFilter<$PrismaModel>
  }

  export type NestedEnumQuestionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionStatus | EnumQuestionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionStatusFilter<$PrismaModel> | $Enums.QuestionStatus
  }

  export type NestedEnumQuestionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionStatus | EnumQuestionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuestionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionStatusFilter<$PrismaModel>
    _max?: NestedEnumQuestionStatusFilter<$PrismaModel>
  }

  export type NestedEnumFeatureCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatureCategory | EnumFeatureCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeatureCategory[] | ListEnumFeatureCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatureCategory[] | ListEnumFeatureCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatureCategoryFilter<$PrismaModel> | $Enums.FeatureCategory
  }

  export type NestedEnumFeatureCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatureCategory | EnumFeatureCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeatureCategory[] | ListEnumFeatureCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatureCategory[] | ListEnumFeatureCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatureCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FeatureCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeatureCategoryFilter<$PrismaModel>
    _max?: NestedEnumFeatureCategoryFilter<$PrismaModel>
  }

  export type NestedEnumMailStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MailStatus | EnumMailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MailStatus[] | ListEnumMailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailStatus[] | ListEnumMailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMailStatusFilter<$PrismaModel> | $Enums.MailStatus
  }

  export type NestedEnumMailTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MailType | EnumMailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MailType[] | ListEnumMailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailType[] | ListEnumMailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMailTypeFilter<$PrismaModel> | $Enums.MailType
  }

  export type NestedEnumMailStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MailStatus | EnumMailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MailStatus[] | ListEnumMailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailStatus[] | ListEnumMailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMailStatusWithAggregatesFilter<$PrismaModel> | $Enums.MailStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMailStatusFilter<$PrismaModel>
    _max?: NestedEnumMailStatusFilter<$PrismaModel>
  }

  export type NestedEnumMailTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MailType | EnumMailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MailType[] | ListEnumMailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailType[] | ListEnumMailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMailTypeWithAggregatesFilter<$PrismaModel> | $Enums.MailType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMailTypeFilter<$PrismaModel>
    _max?: NestedEnumMailTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type NestedEnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type UserRoleCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AgentCreateWithoutUserInput = {
    id?: string
    position?: string | null
    department?: string | null
    licenseNumber?: string | null
    licenseExpireDate?: Date | string | null
    goodCount?: number
    responseRate?: Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    branch: BranchCreateNestedOneWithoutAgentsInput
    properties?: PropertyCreateNestedManyWithoutAgentInput
    assignedInquiries?: InquiryCreateNestedManyWithoutAssignedAgentInput
    answers?: AnswerCreateNestedManyWithoutAgentInput
    bulkAssessmentResponses?: BulkAssessmentResponseCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutUserInput = {
    id?: string
    position?: string | null
    department?: string | null
    licenseNumber?: string | null
    licenseExpireDate?: Date | string | null
    goodCount?: number
    responseRate?: Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: number | null
    branchId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    properties?: PropertyUncheckedCreateNestedManyWithoutAgentInput
    assignedInquiries?: InquiryUncheckedCreateNestedManyWithoutAssignedAgentInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAgentInput
    bulkAssessmentResponses?: BulkAssessmentResponseUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutUserInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
  }

  export type PropertyCreateWithoutUserInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutPropertiesInput
    propertyCategory?: PropertyCategoryMasterCreateNestedOneWithoutPropertiesInput
    area?: AreaMasterCreateNestedOneWithoutPropertiesInput
    layoutType?: FloorPlanMasterCreateNestedOneWithoutPropertiesInput
    agent?: AgentCreateNestedOneWithoutPropertiesInput
    publication?: PropertyPublicationCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryCreateNestedManyWithoutPropertyInput
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutUserInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    publication?: PropertyPublicationUncheckedCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutPropertyInput
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutUserInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput>
  }

  export type PropertyCreateManyUserInputEnvelope = {
    data: PropertyCreateManyUserInput | PropertyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InquiryCreateWithoutUserInput = {
    id?: string
    inquiryNumber: string
    targetType: $Enums.TargetType
    name: string
    furigana?: string | null
    email: string
    phone?: string | null
    companyName?: string | null
    inquiryType?: $Enums.InquiryType
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    assignedAt?: Date | string | null
    responseCount?: number
    lastRespondedAt?: Date | string | null
    closedAt?: Date | string | null
    closedReason?: string | null
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedAgent?: AgentCreateNestedOneWithoutAssignedInquiriesInput
    property?: PropertyCreateNestedOneWithoutInquiriesInput
    messages?: InquiryMessageCreateNestedManyWithoutInquiryInput
  }

  export type InquiryUncheckedCreateWithoutUserInput = {
    id?: string
    inquiryNumber: string
    targetType: $Enums.TargetType
    targetId?: string | null
    name: string
    furigana?: string | null
    email: string
    phone?: string | null
    companyName?: string | null
    inquiryType?: $Enums.InquiryType
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    assignedAgentId?: string | null
    assignedAt?: Date | string | null
    responseCount?: number
    lastRespondedAt?: Date | string | null
    closedAt?: Date | string | null
    closedReason?: string | null
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: InquiryMessageUncheckedCreateNestedManyWithoutInquiryInput
  }

  export type InquiryCreateOrConnectWithoutUserInput = {
    where: InquiryWhereUniqueInput
    create: XOR<InquiryCreateWithoutUserInput, InquiryUncheckedCreateWithoutUserInput>
  }

  export type InquiryCreateManyUserInputEnvelope = {
    data: InquiryCreateManyUserInput | InquiryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    property: PropertyCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateWithoutUserInput = {
    id?: string
    propertyId: string
    createdAt?: Date | string
  }

  export type FavoriteCreateOrConnectWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput>
  }

  export type FavoriteCreateManyUserInputEnvelope = {
    data: FavoriteCreateManyUserInput | FavoriteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PropertyViewCreateWithoutUserInput = {
    id?: string
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    referer?: string | null
    viewedAt?: Date | string
    viewDurationSeconds?: number | null
    property: PropertyCreateNestedOneWithoutPropertyViewsInput
  }

  export type PropertyViewUncheckedCreateWithoutUserInput = {
    id?: string
    propertyId: string
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    referer?: string | null
    viewedAt?: Date | string
    viewDurationSeconds?: number | null
  }

  export type PropertyViewCreateOrConnectWithoutUserInput = {
    where: PropertyViewWhereUniqueInput
    create: XOR<PropertyViewCreateWithoutUserInput, PropertyViewUncheckedCreateWithoutUserInput>
  }

  export type PropertyViewCreateManyUserInputEnvelope = {
    data: PropertyViewCreateManyUserInput | PropertyViewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuestionCreateWithoutAuthorInput = {
    id?: string
    questionNumber: string
    title: string
    content: string
    tags?: QuestionCreatetagsInput | string[]
    viewCount?: number
    answerCount?: number
    status?: $Enums.QuestionStatus
    bestAnswerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    category?: QuestionCategoryCreateNestedOneWithoutQuestionsInput
    answers?: AnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutAuthorInput = {
    id?: string
    questionNumber: string
    title: string
    content: string
    categoryId?: string | null
    tags?: QuestionCreatetagsInput | string[]
    viewCount?: number
    answerCount?: number
    status?: $Enums.QuestionStatus
    bestAnswerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutAuthorInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutAuthorInput, QuestionUncheckedCreateWithoutAuthorInput>
  }

  export type QuestionCreateManyAuthorInputEnvelope = {
    data: QuestionCreateManyAuthorInput | QuestionCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type AnswerCreateWithoutAuthorInput = {
    id?: string
    content: string
    goodCount?: number
    isBestAnswer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    question: QuestionCreateNestedOneWithoutAnswersInput
    agent?: AgentCreateNestedOneWithoutAnswersInput
  }

  export type AnswerUncheckedCreateWithoutAuthorInput = {
    id?: string
    questionId: string
    content: string
    goodCount?: number
    isBestAnswer?: boolean
    agentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AnswerCreateOrConnectWithoutAuthorInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutAuthorInput, AnswerUncheckedCreateWithoutAuthorInput>
  }

  export type AnswerCreateManyAuthorInputEnvelope = {
    data: AnswerCreateManyAuthorInput | AnswerCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type BulkAssessmentCreateWithoutUserInput = {
    id?: string
    assessmentNumber: string
    propertyAddress: string
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    constructionYear?: number | null
    ownerName: string
    email: string
    phone?: string | null
    preferredContactMethod?: string | null
    preferredContactTime?: string | null
    status?: $Enums.AssessmentStatus
    agentCount?: number
    responseCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    completedAt?: Date | string | null
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutBulkAssessmentsInput
    responses?: BulkAssessmentResponseCreateNestedManyWithoutAssessmentInput
  }

  export type BulkAssessmentUncheckedCreateWithoutUserInput = {
    id?: string
    assessmentNumber: string
    propertyAddress: string
    propertyTypeId?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    constructionYear?: number | null
    ownerName: string
    email: string
    phone?: string | null
    preferredContactMethod?: string | null
    preferredContactTime?: string | null
    status?: $Enums.AssessmentStatus
    agentCount?: number
    responseCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    completedAt?: Date | string | null
    responses?: BulkAssessmentResponseUncheckedCreateNestedManyWithoutAssessmentInput
  }

  export type BulkAssessmentCreateOrConnectWithoutUserInput = {
    where: BulkAssessmentWhereUniqueInput
    create: XOR<BulkAssessmentCreateWithoutUserInput, BulkAssessmentUncheckedCreateWithoutUserInput>
  }

  export type BulkAssessmentCreateManyUserInputEnvelope = {
    data: BulkAssessmentCreateManyUserInput | BulkAssessmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MailCreateWithoutUserInput = {
    id?: string
    fromEmail: string
    fromName?: string | null
    toEmail: string
    toName?: string | null
    ccEmail?: MailCreateccEmailInput | string[]
    bccEmail?: MailCreatebccEmailInput | string[]
    subject: string
    bodyText: string
    bodyHtml?: string | null
    status?: $Enums.MailStatus
    mailType?: $Enums.MailType
    templateCode?: string | null
    templateVariables?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MailUncheckedCreateWithoutUserInput = {
    id?: string
    fromEmail: string
    fromName?: string | null
    toEmail: string
    toName?: string | null
    ccEmail?: MailCreateccEmailInput | string[]
    bccEmail?: MailCreatebccEmailInput | string[]
    subject: string
    bodyText: string
    bodyHtml?: string | null
    status?: $Enums.MailStatus
    mailType?: $Enums.MailType
    templateCode?: string | null
    templateVariables?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MailCreateOrConnectWithoutUserInput = {
    where: MailWhereUniqueInput
    create: XOR<MailCreateWithoutUserInput, MailUncheckedCreateWithoutUserInput>
  }

  export type MailCreateManyUserInputEnvelope = {
    data: MailCreateManyUserInput | MailCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FileBoxCreateWithoutUserInput = {
    id?: string
    bucketName: string
    storagePath: string
    fileName: string
    originalName: string
    publicUrl?: string | null
    mimeType: string
    fileSize: bigint | number
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyImages?: PropertyImageCreateNestedManyWithoutFileBoxInput
  }

  export type FileBoxUncheckedCreateWithoutUserInput = {
    id?: string
    bucketName: string
    storagePath: string
    fileName: string
    originalName: string
    publicUrl?: string | null
    mimeType: string
    fileSize: bigint | number
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyImages?: PropertyImageUncheckedCreateNestedManyWithoutFileBoxInput
  }

  export type FileBoxCreateOrConnectWithoutUserInput = {
    where: FileBoxWhereUniqueInput
    create: XOR<FileBoxCreateWithoutUserInput, FileBoxUncheckedCreateWithoutUserInput>
  }

  export type FileBoxCreateManyUserInputEnvelope = {
    data: FileBoxCreateManyUserInput | FileBoxCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    linkUrl?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    linkUrl?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SystemSettingCreateWithoutUpdatedByInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    valueType: string
    category?: string | null
    description?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    valueType: string
    category?: string | null
    description?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingCreateOrConnectWithoutUpdatedByInput = {
    where: SystemSettingWhereUniqueInput
    create: XOR<SystemSettingCreateWithoutUpdatedByInput, SystemSettingUncheckedCreateWithoutUpdatedByInput>
  }

  export type SystemSettingCreateManyUpdatedByInputEnvelope = {
    data: SystemSettingCreateManyUpdatedByInput | SystemSettingCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    tableName: string
    recordId: string
    action: $Enums.AuditAction
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: AuditLogCreatechangedFieldsInput | string[]
    userEmail?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    tableName: string
    recordId: string
    action: $Enums.AuditAction
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: AuditLogCreatechangedFieldsInput | string[]
    userEmail?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PropertyPriceHistoryCreateWithoutChangedByInput = {
    id?: string
    previousPrice?: bigint | number | null
    newPrice: bigint | number
    changePercent?: Decimal | DecimalJsLike | number | string | null
    changeReason?: string | null
    createdAt?: Date | string
    property: PropertyCreateNestedOneWithoutPriceHistoriesInput
  }

  export type PropertyPriceHistoryUncheckedCreateWithoutChangedByInput = {
    id?: string
    propertyId: string
    previousPrice?: bigint | number | null
    newPrice: bigint | number
    changePercent?: Decimal | DecimalJsLike | number | string | null
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type PropertyPriceHistoryCreateOrConnectWithoutChangedByInput = {
    where: PropertyPriceHistoryWhereUniqueInput
    create: XOR<PropertyPriceHistoryCreateWithoutChangedByInput, PropertyPriceHistoryUncheckedCreateWithoutChangedByInput>
  }

  export type PropertyPriceHistoryCreateManyChangedByInputEnvelope = {
    data: PropertyPriceHistoryCreateManyChangedByInput | PropertyPriceHistoryCreateManyChangedByInput[]
    skipDuplicates?: boolean
  }

  export type PropertyStatusHistoryCreateWithoutChangedByInput = {
    id?: string
    previousStatus?: string | null
    newStatus: string
    changeReason?: string | null
    createdAt?: Date | string
    property: PropertyCreateNestedOneWithoutStatusHistoriesInput
  }

  export type PropertyStatusHistoryUncheckedCreateWithoutChangedByInput = {
    id?: string
    propertyId: string
    previousStatus?: string | null
    newStatus: string
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type PropertyStatusHistoryCreateOrConnectWithoutChangedByInput = {
    where: PropertyStatusHistoryWhereUniqueInput
    create: XOR<PropertyStatusHistoryCreateWithoutChangedByInput, PropertyStatusHistoryUncheckedCreateWithoutChangedByInput>
  }

  export type PropertyStatusHistoryCreateManyChangedByInputEnvelope = {
    data: PropertyStatusHistoryCreateManyChangedByInput | PropertyStatusHistoryCreateManyChangedByInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    id?: UuidFilter<"UserRole"> | string
    userId?: UuidFilter<"UserRole"> | string
    roleId?: UuidFilter<"UserRole"> | string
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
  }

  export type AgentUpsertWithoutUserInput = {
    update: XOR<AgentUpdateWithoutUserInput, AgentUncheckedUpdateWithoutUserInput>
    create: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutUserInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutUserInput, AgentUncheckedUpdateWithoutUserInput>
  }

  export type AgentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goodCount?: IntFieldUpdateOperationsInput | number
    responseRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneRequiredWithoutAgentsNestedInput
    properties?: PropertyUpdateManyWithoutAgentNestedInput
    assignedInquiries?: InquiryUpdateManyWithoutAssignedAgentNestedInput
    answers?: AnswerUpdateManyWithoutAgentNestedInput
    bulkAssessmentResponses?: BulkAssessmentResponseUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goodCount?: IntFieldUpdateOperationsInput | number
    responseRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    properties?: PropertyUncheckedUpdateManyWithoutAgentNestedInput
    assignedInquiries?: InquiryUncheckedUpdateManyWithoutAssignedAgentNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAgentNestedInput
    bulkAssessmentResponses?: BulkAssessmentResponseUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type PropertyUpsertWithWhereUniqueWithoutUserInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutUserInput, PropertyUncheckedUpdateWithoutUserInput>
    create: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutUserInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutUserInput, PropertyUncheckedUpdateWithoutUserInput>
  }

  export type PropertyUpdateManyWithWhereWithoutUserInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutUserInput>
  }

  export type PropertyScalarWhereInput = {
    AND?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    OR?: PropertyScalarWhereInput[]
    NOT?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    id?: UuidFilter<"Property"> | string
    propertyCode?: StringFilter<"Property"> | string
    propertyName?: StringFilter<"Property"> | string
    propertyNameKana?: StringNullableFilter<"Property"> | string | null
    propertyTypeId?: UuidNullableFilter<"Property"> | string | null
    propertyCategoryId?: UuidNullableFilter<"Property"> | string | null
    areaId?: UuidNullableFilter<"Property"> | string | null
    transactionType?: EnumTransactionTypeNullableFilter<"Property"> | $Enums.TransactionType | null
    propertyCondition?: EnumPropertyConditionNullableFilter<"Property"> | $Enums.PropertyCondition | null
    postalCode?: StringNullableFilter<"Property"> | string | null
    prefecture?: StringNullableFilter<"Property"> | string | null
    city?: StringNullableFilter<"Property"> | string | null
    town?: StringNullableFilter<"Property"> | string | null
    block?: StringNullableFilter<"Property"> | string | null
    building?: StringNullableFilter<"Property"> | string | null
    roomNumber?: StringNullableFilter<"Property"> | string | null
    fullAddress?: StringNullableFilter<"Property"> | string | null
    latitude?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: IntNullableFilter<"Property"> | number | null
    layoutTypeId?: UuidNullableFilter<"Property"> | string | null
    layoutDisplay?: StringNullableFilter<"Property"> | string | null
    buildingArea?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    landArea?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    balconyArea?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: StringNullableFilter<"Property"> | string | null
    constructionDate?: DateTimeNullableFilter<"Property"> | Date | string | null
    constructionYearMonth?: StringNullableFilter<"Property"> | string | null
    totalFloors?: IntNullableFilter<"Property"> | number | null
    floor?: IntNullableFilter<"Property"> | number | null
    currentPrice?: BigIntNullableFilter<"Property"> | bigint | number | null
    pricePerTsubo?: BigIntNullableFilter<"Property"> | bigint | number | null
    managementFee?: IntNullableFilter<"Property"> | number | null
    commonServiceFee?: IntNullableFilter<"Property"> | number | null
    depositMonths?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: StringNullableFilter<"Property"> | string | null
    primaryStationName?: StringNullableFilter<"Property"> | string | null
    primaryStationWalkMinutes?: IntNullableFilter<"Property"> | number | null
    featureTags?: StringNullableListFilter<"Property">
    viewCount?: IntFilter<"Property"> | number
    inquiryCount?: IntFilter<"Property"> | number
    favoriteCount?: IntFilter<"Property"> | number
    agentId?: UuidNullableFilter<"Property"> | string | null
    remarks?: StringNullableFilter<"Property"> | string | null
    internalMemo?: StringNullableFilter<"Property"> | string | null
    metadata?: JsonNullableFilter<"Property">
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    userId?: UuidFilter<"Property"> | string
  }

  export type InquiryUpsertWithWhereUniqueWithoutUserInput = {
    where: InquiryWhereUniqueInput
    update: XOR<InquiryUpdateWithoutUserInput, InquiryUncheckedUpdateWithoutUserInput>
    create: XOR<InquiryCreateWithoutUserInput, InquiryUncheckedCreateWithoutUserInput>
  }

  export type InquiryUpdateWithWhereUniqueWithoutUserInput = {
    where: InquiryWhereUniqueInput
    data: XOR<InquiryUpdateWithoutUserInput, InquiryUncheckedUpdateWithoutUserInput>
  }

  export type InquiryUpdateManyWithWhereWithoutUserInput = {
    where: InquiryScalarWhereInput
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyWithoutUserInput>
  }

  export type InquiryScalarWhereInput = {
    AND?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
    OR?: InquiryScalarWhereInput[]
    NOT?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
    id?: UuidFilter<"Inquiry"> | string
    inquiryNumber?: StringFilter<"Inquiry"> | string
    targetType?: EnumTargetTypeFilter<"Inquiry"> | $Enums.TargetType
    targetId?: UuidNullableFilter<"Inquiry"> | string | null
    name?: StringFilter<"Inquiry"> | string
    furigana?: StringNullableFilter<"Inquiry"> | string | null
    email?: StringFilter<"Inquiry"> | string
    phone?: StringNullableFilter<"Inquiry"> | string | null
    companyName?: StringNullableFilter<"Inquiry"> | string | null
    inquiryType?: EnumInquiryTypeFilter<"Inquiry"> | $Enums.InquiryType
    subject?: StringNullableFilter<"Inquiry"> | string | null
    message?: StringFilter<"Inquiry"> | string
    status?: EnumInquiryStatusFilter<"Inquiry"> | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFilter<"Inquiry"> | $Enums.InquiryPriority
    userId?: UuidNullableFilter<"Inquiry"> | string | null
    assignedAgentId?: UuidNullableFilter<"Inquiry"> | string | null
    assignedAt?: DateTimeNullableFilter<"Inquiry"> | Date | string | null
    responseCount?: IntFilter<"Inquiry"> | number
    lastRespondedAt?: DateTimeNullableFilter<"Inquiry"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"Inquiry"> | Date | string | null
    closedReason?: StringNullableFilter<"Inquiry"> | string | null
    source?: StringNullableFilter<"Inquiry"> | string | null
    metadata?: JsonNullableFilter<"Inquiry">
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Inquiry"> | Date | string
  }

  export type FavoriteUpsertWithWhereUniqueWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutUserInput, FavoriteUncheckedUpdateWithoutUserInput>
    create: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutUserInput, FavoriteUncheckedUpdateWithoutUserInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutUserInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutUserInput>
  }

  export type FavoriteScalarWhereInput = {
    AND?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    OR?: FavoriteScalarWhereInput[]
    NOT?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    id?: UuidFilter<"Favorite"> | string
    userId?: UuidFilter<"Favorite"> | string
    propertyId?: UuidFilter<"Favorite"> | string
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
  }

  export type PropertyViewUpsertWithWhereUniqueWithoutUserInput = {
    where: PropertyViewWhereUniqueInput
    update: XOR<PropertyViewUpdateWithoutUserInput, PropertyViewUncheckedUpdateWithoutUserInput>
    create: XOR<PropertyViewCreateWithoutUserInput, PropertyViewUncheckedCreateWithoutUserInput>
  }

  export type PropertyViewUpdateWithWhereUniqueWithoutUserInput = {
    where: PropertyViewWhereUniqueInput
    data: XOR<PropertyViewUpdateWithoutUserInput, PropertyViewUncheckedUpdateWithoutUserInput>
  }

  export type PropertyViewUpdateManyWithWhereWithoutUserInput = {
    where: PropertyViewScalarWhereInput
    data: XOR<PropertyViewUpdateManyMutationInput, PropertyViewUncheckedUpdateManyWithoutUserInput>
  }

  export type PropertyViewScalarWhereInput = {
    AND?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
    OR?: PropertyViewScalarWhereInput[]
    NOT?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
    id?: UuidFilter<"PropertyView"> | string
    propertyId?: UuidFilter<"PropertyView"> | string
    userId?: UuidNullableFilter<"PropertyView"> | string | null
    sessionId?: StringNullableFilter<"PropertyView"> | string | null
    ipAddress?: StringNullableFilter<"PropertyView"> | string | null
    userAgent?: StringNullableFilter<"PropertyView"> | string | null
    referer?: StringNullableFilter<"PropertyView"> | string | null
    viewedAt?: DateTimeFilter<"PropertyView"> | Date | string
    viewDurationSeconds?: IntNullableFilter<"PropertyView"> | number | null
  }

  export type QuestionUpsertWithWhereUniqueWithoutAuthorInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutAuthorInput, QuestionUncheckedUpdateWithoutAuthorInput>
    create: XOR<QuestionCreateWithoutAuthorInput, QuestionUncheckedCreateWithoutAuthorInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutAuthorInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutAuthorInput, QuestionUncheckedUpdateWithoutAuthorInput>
  }

  export type QuestionUpdateManyWithWhereWithoutAuthorInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutAuthorInput>
  }

  export type QuestionScalarWhereInput = {
    AND?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    OR?: QuestionScalarWhereInput[]
    NOT?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    id?: UuidFilter<"Question"> | string
    questionNumber?: StringFilter<"Question"> | string
    title?: StringFilter<"Question"> | string
    content?: StringFilter<"Question"> | string
    categoryId?: UuidNullableFilter<"Question"> | string | null
    tags?: StringNullableListFilter<"Question">
    viewCount?: IntFilter<"Question"> | number
    answerCount?: IntFilter<"Question"> | number
    status?: EnumQuestionStatusFilter<"Question"> | $Enums.QuestionStatus
    authorId?: UuidFilter<"Question"> | string
    bestAnswerId?: UuidNullableFilter<"Question"> | string | null
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Question"> | Date | string | null
  }

  export type AnswerUpsertWithWhereUniqueWithoutAuthorInput = {
    where: AnswerWhereUniqueInput
    update: XOR<AnswerUpdateWithoutAuthorInput, AnswerUncheckedUpdateWithoutAuthorInput>
    create: XOR<AnswerCreateWithoutAuthorInput, AnswerUncheckedCreateWithoutAuthorInput>
  }

  export type AnswerUpdateWithWhereUniqueWithoutAuthorInput = {
    where: AnswerWhereUniqueInput
    data: XOR<AnswerUpdateWithoutAuthorInput, AnswerUncheckedUpdateWithoutAuthorInput>
  }

  export type AnswerUpdateManyWithWhereWithoutAuthorInput = {
    where: AnswerScalarWhereInput
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyWithoutAuthorInput>
  }

  export type AnswerScalarWhereInput = {
    AND?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
    OR?: AnswerScalarWhereInput[]
    NOT?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
    id?: UuidFilter<"Answer"> | string
    questionId?: UuidFilter<"Answer"> | string
    content?: StringFilter<"Answer"> | string
    goodCount?: IntFilter<"Answer"> | number
    isBestAnswer?: BoolFilter<"Answer"> | boolean
    authorId?: UuidNullableFilter<"Answer"> | string | null
    agentId?: UuidNullableFilter<"Answer"> | string | null
    createdAt?: DateTimeFilter<"Answer"> | Date | string
    updatedAt?: DateTimeFilter<"Answer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Answer"> | Date | string | null
  }

  export type BulkAssessmentUpsertWithWhereUniqueWithoutUserInput = {
    where: BulkAssessmentWhereUniqueInput
    update: XOR<BulkAssessmentUpdateWithoutUserInput, BulkAssessmentUncheckedUpdateWithoutUserInput>
    create: XOR<BulkAssessmentCreateWithoutUserInput, BulkAssessmentUncheckedCreateWithoutUserInput>
  }

  export type BulkAssessmentUpdateWithWhereUniqueWithoutUserInput = {
    where: BulkAssessmentWhereUniqueInput
    data: XOR<BulkAssessmentUpdateWithoutUserInput, BulkAssessmentUncheckedUpdateWithoutUserInput>
  }

  export type BulkAssessmentUpdateManyWithWhereWithoutUserInput = {
    where: BulkAssessmentScalarWhereInput
    data: XOR<BulkAssessmentUpdateManyMutationInput, BulkAssessmentUncheckedUpdateManyWithoutUserInput>
  }

  export type BulkAssessmentScalarWhereInput = {
    AND?: BulkAssessmentScalarWhereInput | BulkAssessmentScalarWhereInput[]
    OR?: BulkAssessmentScalarWhereInput[]
    NOT?: BulkAssessmentScalarWhereInput | BulkAssessmentScalarWhereInput[]
    id?: UuidFilter<"BulkAssessment"> | string
    assessmentNumber?: StringFilter<"BulkAssessment"> | string
    propertyAddress?: StringFilter<"BulkAssessment"> | string
    propertyTypeId?: UuidNullableFilter<"BulkAssessment"> | string | null
    buildingArea?: DecimalNullableFilter<"BulkAssessment"> | Decimal | DecimalJsLike | number | string | null
    landArea?: DecimalNullableFilter<"BulkAssessment"> | Decimal | DecimalJsLike | number | string | null
    constructionYear?: IntNullableFilter<"BulkAssessment"> | number | null
    ownerName?: StringFilter<"BulkAssessment"> | string
    email?: StringFilter<"BulkAssessment"> | string
    phone?: StringNullableFilter<"BulkAssessment"> | string | null
    preferredContactMethod?: StringNullableFilter<"BulkAssessment"> | string | null
    preferredContactTime?: StringNullableFilter<"BulkAssessment"> | string | null
    status?: EnumAssessmentStatusFilter<"BulkAssessment"> | $Enums.AssessmentStatus
    agentCount?: IntFilter<"BulkAssessment"> | number
    responseCount?: IntFilter<"BulkAssessment"> | number
    userId?: UuidNullableFilter<"BulkAssessment"> | string | null
    metadata?: JsonNullableFilter<"BulkAssessment">
    createdAt?: DateTimeFilter<"BulkAssessment"> | Date | string
    completedAt?: DateTimeNullableFilter<"BulkAssessment"> | Date | string | null
  }

  export type MailUpsertWithWhereUniqueWithoutUserInput = {
    where: MailWhereUniqueInput
    update: XOR<MailUpdateWithoutUserInput, MailUncheckedUpdateWithoutUserInput>
    create: XOR<MailCreateWithoutUserInput, MailUncheckedCreateWithoutUserInput>
  }

  export type MailUpdateWithWhereUniqueWithoutUserInput = {
    where: MailWhereUniqueInput
    data: XOR<MailUpdateWithoutUserInput, MailUncheckedUpdateWithoutUserInput>
  }

  export type MailUpdateManyWithWhereWithoutUserInput = {
    where: MailScalarWhereInput
    data: XOR<MailUpdateManyMutationInput, MailUncheckedUpdateManyWithoutUserInput>
  }

  export type MailScalarWhereInput = {
    AND?: MailScalarWhereInput | MailScalarWhereInput[]
    OR?: MailScalarWhereInput[]
    NOT?: MailScalarWhereInput | MailScalarWhereInput[]
    id?: UuidFilter<"Mail"> | string
    fromEmail?: StringFilter<"Mail"> | string
    fromName?: StringNullableFilter<"Mail"> | string | null
    toEmail?: StringFilter<"Mail"> | string
    toName?: StringNullableFilter<"Mail"> | string | null
    ccEmail?: StringNullableListFilter<"Mail">
    bccEmail?: StringNullableListFilter<"Mail">
    subject?: StringFilter<"Mail"> | string
    bodyText?: StringFilter<"Mail"> | string
    bodyHtml?: StringNullableFilter<"Mail"> | string | null
    status?: EnumMailStatusFilter<"Mail"> | $Enums.MailStatus
    mailType?: EnumMailTypeFilter<"Mail"> | $Enums.MailType
    templateCode?: StringNullableFilter<"Mail"> | string | null
    templateVariables?: JsonNullableFilter<"Mail">
    errorMessage?: StringNullableFilter<"Mail"> | string | null
    userId?: UuidNullableFilter<"Mail"> | string | null
    retryCount?: IntFilter<"Mail"> | number
    scheduledAt?: DateTimeNullableFilter<"Mail"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Mail"> | Date | string | null
    createdAt?: DateTimeFilter<"Mail"> | Date | string
  }

  export type FileBoxUpsertWithWhereUniqueWithoutUserInput = {
    where: FileBoxWhereUniqueInput
    update: XOR<FileBoxUpdateWithoutUserInput, FileBoxUncheckedUpdateWithoutUserInput>
    create: XOR<FileBoxCreateWithoutUserInput, FileBoxUncheckedCreateWithoutUserInput>
  }

  export type FileBoxUpdateWithWhereUniqueWithoutUserInput = {
    where: FileBoxWhereUniqueInput
    data: XOR<FileBoxUpdateWithoutUserInput, FileBoxUncheckedUpdateWithoutUserInput>
  }

  export type FileBoxUpdateManyWithWhereWithoutUserInput = {
    where: FileBoxScalarWhereInput
    data: XOR<FileBoxUpdateManyMutationInput, FileBoxUncheckedUpdateManyWithoutUserInput>
  }

  export type FileBoxScalarWhereInput = {
    AND?: FileBoxScalarWhereInput | FileBoxScalarWhereInput[]
    OR?: FileBoxScalarWhereInput[]
    NOT?: FileBoxScalarWhereInput | FileBoxScalarWhereInput[]
    id?: UuidFilter<"FileBox"> | string
    bucketName?: StringFilter<"FileBox"> | string
    storagePath?: StringFilter<"FileBox"> | string
    fileName?: StringFilter<"FileBox"> | string
    originalName?: StringFilter<"FileBox"> | string
    publicUrl?: StringNullableFilter<"FileBox"> | string | null
    mimeType?: StringFilter<"FileBox"> | string
    fileSize?: BigIntFilter<"FileBox"> | bigint | number
    category?: StringNullableFilter<"FileBox"> | string | null
    metadata?: JsonNullableFilter<"FileBox">
    userId?: UuidNullableFilter<"FileBox"> | string | null
    isPublic?: BoolFilter<"FileBox"> | boolean
    createdAt?: DateTimeFilter<"FileBox"> | Date | string
    updatedAt?: DateTimeFilter<"FileBox"> | Date | string
    deletedAt?: DateTimeNullableFilter<"FileBox"> | Date | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: UuidFilter<"Notification"> | string
    userId?: UuidFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    linkUrl?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type SystemSettingUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: SystemSettingWhereUniqueInput
    update: XOR<SystemSettingUpdateWithoutUpdatedByInput, SystemSettingUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<SystemSettingCreateWithoutUpdatedByInput, SystemSettingUncheckedCreateWithoutUpdatedByInput>
  }

  export type SystemSettingUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: SystemSettingWhereUniqueInput
    data: XOR<SystemSettingUpdateWithoutUpdatedByInput, SystemSettingUncheckedUpdateWithoutUpdatedByInput>
  }

  export type SystemSettingUpdateManyWithWhereWithoutUpdatedByInput = {
    where: SystemSettingScalarWhereInput
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type SystemSettingScalarWhereInput = {
    AND?: SystemSettingScalarWhereInput | SystemSettingScalarWhereInput[]
    OR?: SystemSettingScalarWhereInput[]
    NOT?: SystemSettingScalarWhereInput | SystemSettingScalarWhereInput[]
    id?: UuidFilter<"SystemSetting"> | string
    key?: StringFilter<"SystemSetting"> | string
    value?: JsonFilter<"SystemSetting">
    valueType?: StringFilter<"SystemSetting"> | string
    category?: StringNullableFilter<"SystemSetting"> | string | null
    description?: StringNullableFilter<"SystemSetting"> | string | null
    isPublic?: BoolFilter<"SystemSetting"> | boolean
    updatedById?: UuidNullableFilter<"SystemSetting"> | string | null
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: UuidFilter<"AuditLog"> | string
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    changedFields?: StringNullableListFilter<"AuditLog">
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    userEmail?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    sessionId?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type PropertyPriceHistoryUpsertWithWhereUniqueWithoutChangedByInput = {
    where: PropertyPriceHistoryWhereUniqueInput
    update: XOR<PropertyPriceHistoryUpdateWithoutChangedByInput, PropertyPriceHistoryUncheckedUpdateWithoutChangedByInput>
    create: XOR<PropertyPriceHistoryCreateWithoutChangedByInput, PropertyPriceHistoryUncheckedCreateWithoutChangedByInput>
  }

  export type PropertyPriceHistoryUpdateWithWhereUniqueWithoutChangedByInput = {
    where: PropertyPriceHistoryWhereUniqueInput
    data: XOR<PropertyPriceHistoryUpdateWithoutChangedByInput, PropertyPriceHistoryUncheckedUpdateWithoutChangedByInput>
  }

  export type PropertyPriceHistoryUpdateManyWithWhereWithoutChangedByInput = {
    where: PropertyPriceHistoryScalarWhereInput
    data: XOR<PropertyPriceHistoryUpdateManyMutationInput, PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByInput>
  }

  export type PropertyPriceHistoryScalarWhereInput = {
    AND?: PropertyPriceHistoryScalarWhereInput | PropertyPriceHistoryScalarWhereInput[]
    OR?: PropertyPriceHistoryScalarWhereInput[]
    NOT?: PropertyPriceHistoryScalarWhereInput | PropertyPriceHistoryScalarWhereInput[]
    id?: UuidFilter<"PropertyPriceHistory"> | string
    propertyId?: UuidFilter<"PropertyPriceHistory"> | string
    previousPrice?: BigIntNullableFilter<"PropertyPriceHistory"> | bigint | number | null
    newPrice?: BigIntFilter<"PropertyPriceHistory"> | bigint | number
    changePercent?: DecimalNullableFilter<"PropertyPriceHistory"> | Decimal | DecimalJsLike | number | string | null
    changeReason?: StringNullableFilter<"PropertyPriceHistory"> | string | null
    changedById?: UuidNullableFilter<"PropertyPriceHistory"> | string | null
    createdAt?: DateTimeFilter<"PropertyPriceHistory"> | Date | string
  }

  export type PropertyStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput = {
    where: PropertyStatusHistoryWhereUniqueInput
    update: XOR<PropertyStatusHistoryUpdateWithoutChangedByInput, PropertyStatusHistoryUncheckedUpdateWithoutChangedByInput>
    create: XOR<PropertyStatusHistoryCreateWithoutChangedByInput, PropertyStatusHistoryUncheckedCreateWithoutChangedByInput>
  }

  export type PropertyStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput = {
    where: PropertyStatusHistoryWhereUniqueInput
    data: XOR<PropertyStatusHistoryUpdateWithoutChangedByInput, PropertyStatusHistoryUncheckedUpdateWithoutChangedByInput>
  }

  export type PropertyStatusHistoryUpdateManyWithWhereWithoutChangedByInput = {
    where: PropertyStatusHistoryScalarWhereInput
    data: XOR<PropertyStatusHistoryUpdateManyMutationInput, PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByInput>
  }

  export type PropertyStatusHistoryScalarWhereInput = {
    AND?: PropertyStatusHistoryScalarWhereInput | PropertyStatusHistoryScalarWhereInput[]
    OR?: PropertyStatusHistoryScalarWhereInput[]
    NOT?: PropertyStatusHistoryScalarWhereInput | PropertyStatusHistoryScalarWhereInput[]
    id?: UuidFilter<"PropertyStatusHistory"> | string
    propertyId?: UuidFilter<"PropertyStatusHistory"> | string
    previousStatus?: StringNullableFilter<"PropertyStatusHistory"> | string | null
    newStatus?: StringFilter<"PropertyStatusHistory"> | string
    changeReason?: StringNullableFilter<"PropertyStatusHistory"> | string | null
    changedById?: UuidNullableFilter<"PropertyStatusHistory"> | string | null
    createdAt?: DateTimeFilter<"PropertyStatusHistory"> | Date | string
  }

  export type UserRoleCreateWithoutRoleInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserCreateWithoutUserRolesInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    agent?: AgentCreateNestedOneWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutAuthorInput
    answers?: AnswerCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentCreateNestedManyWithoutUserInput
    mails?: MailCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateWithoutUserRolesInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutAuthorInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentUncheckedCreateNestedManyWithoutUserInput
    mails?: MailUncheckedCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserCreateOrConnectWithoutUserRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
  }

  export type RoleCreateWithoutUserRolesInput = {
    id?: string
    name: string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    createdAt?: Date | string
  }

  export type RoleUncheckedCreateWithoutUserRolesInput = {
    id?: string
    name: string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    createdAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutUserRolesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
  }

  export type UserUpsertWithoutUserRolesInput = {
    update: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agent?: AgentUpdateOneWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUpdateManyWithoutUserNestedInput
    mails?: MailUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUncheckedUpdateManyWithoutUserNestedInput
    mails?: MailUncheckedUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type RoleUpsertWithoutUserRolesInput = {
    update: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateWithoutCompanyInput = {
    id?: string
    branchName: string
    postalCode: string
    prefecture: string
    city: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    phone: string
    fax?: string | null
    businessHours?: string | null
    isHeadquarters?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    agents?: AgentCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutCompanyInput = {
    id?: string
    branchName: string
    postalCode: string
    prefecture: string
    city: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    phone: string
    fax?: string | null
    businessHours?: string | null
    isHeadquarters?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    agents?: AgentUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutCompanyInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutCompanyInput, BranchUncheckedCreateWithoutCompanyInput>
  }

  export type BranchCreateManyCompanyInputEnvelope = {
    data: BranchCreateManyCompanyInput | BranchCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithWhereUniqueWithoutCompanyInput = {
    where: BranchWhereUniqueInput
    update: XOR<BranchUpdateWithoutCompanyInput, BranchUncheckedUpdateWithoutCompanyInput>
    create: XOR<BranchCreateWithoutCompanyInput, BranchUncheckedCreateWithoutCompanyInput>
  }

  export type BranchUpdateWithWhereUniqueWithoutCompanyInput = {
    where: BranchWhereUniqueInput
    data: XOR<BranchUpdateWithoutCompanyInput, BranchUncheckedUpdateWithoutCompanyInput>
  }

  export type BranchUpdateManyWithWhereWithoutCompanyInput = {
    where: BranchScalarWhereInput
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyWithoutCompanyInput>
  }

  export type BranchScalarWhereInput = {
    AND?: BranchScalarWhereInput | BranchScalarWhereInput[]
    OR?: BranchScalarWhereInput[]
    NOT?: BranchScalarWhereInput | BranchScalarWhereInput[]
    id?: UuidFilter<"Branch"> | string
    branchName?: StringFilter<"Branch"> | string
    postalCode?: StringFilter<"Branch"> | string
    prefecture?: StringFilter<"Branch"> | string
    city?: StringFilter<"Branch"> | string
    address?: StringFilter<"Branch"> | string
    latitude?: DecimalNullableFilter<"Branch"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Branch"> | Decimal | DecimalJsLike | number | string | null
    phone?: StringFilter<"Branch"> | string
    fax?: StringNullableFilter<"Branch"> | string | null
    businessHours?: StringNullableFilter<"Branch"> | string | null
    isHeadquarters?: BoolFilter<"Branch"> | boolean
    companyId?: UuidFilter<"Branch"> | string
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Branch"> | Date | string | null
  }

  export type CompanyCreateWithoutBranchesInput = {
    id?: string
    companyName: string
    companyNameKana?: string | null
    representativeName: string
    postalCode: string
    prefecture: string
    city: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    phone: string
    fax?: string | null
    website?: string | null
    licenseNumber: string
    associationMembership?: string | null
    accountType?: $Enums.AccountType
    status?: $Enums.CompanyStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CompanyUncheckedCreateWithoutBranchesInput = {
    id?: string
    companyName: string
    companyNameKana?: string | null
    representativeName: string
    postalCode: string
    prefecture: string
    city: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    phone: string
    fax?: string | null
    website?: string | null
    licenseNumber: string
    associationMembership?: string | null
    accountType?: $Enums.AccountType
    status?: $Enums.CompanyStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CompanyCreateOrConnectWithoutBranchesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutBranchesInput, CompanyUncheckedCreateWithoutBranchesInput>
  }

  export type AgentCreateWithoutBranchInput = {
    id?: string
    position?: string | null
    department?: string | null
    licenseNumber?: string | null
    licenseExpireDate?: Date | string | null
    goodCount?: number
    responseRate?: Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAgentInput
    properties?: PropertyCreateNestedManyWithoutAgentInput
    assignedInquiries?: InquiryCreateNestedManyWithoutAssignedAgentInput
    answers?: AnswerCreateNestedManyWithoutAgentInput
    bulkAssessmentResponses?: BulkAssessmentResponseCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutBranchInput = {
    id?: string
    position?: string | null
    department?: string | null
    licenseNumber?: string | null
    licenseExpireDate?: Date | string | null
    goodCount?: number
    responseRate?: Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: number | null
    userId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    properties?: PropertyUncheckedCreateNestedManyWithoutAgentInput
    assignedInquiries?: InquiryUncheckedCreateNestedManyWithoutAssignedAgentInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAgentInput
    bulkAssessmentResponses?: BulkAssessmentResponseUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutBranchInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutBranchInput, AgentUncheckedCreateWithoutBranchInput>
  }

  export type AgentCreateManyBranchInputEnvelope = {
    data: AgentCreateManyBranchInput | AgentCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutBranchesInput = {
    update: XOR<CompanyUpdateWithoutBranchesInput, CompanyUncheckedUpdateWithoutBranchesInput>
    create: XOR<CompanyCreateWithoutBranchesInput, CompanyUncheckedCreateWithoutBranchesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutBranchesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutBranchesInput, CompanyUncheckedUpdateWithoutBranchesInput>
  }

  export type CompanyUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    representativeName?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    phone?: StringFieldUpdateOperationsInput | string
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    associationMembership?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    representativeName?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    phone?: StringFieldUpdateOperationsInput | string
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: StringFieldUpdateOperationsInput | string
    associationMembership?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgentUpsertWithWhereUniqueWithoutBranchInput = {
    where: AgentWhereUniqueInput
    update: XOR<AgentUpdateWithoutBranchInput, AgentUncheckedUpdateWithoutBranchInput>
    create: XOR<AgentCreateWithoutBranchInput, AgentUncheckedCreateWithoutBranchInput>
  }

  export type AgentUpdateWithWhereUniqueWithoutBranchInput = {
    where: AgentWhereUniqueInput
    data: XOR<AgentUpdateWithoutBranchInput, AgentUncheckedUpdateWithoutBranchInput>
  }

  export type AgentUpdateManyWithWhereWithoutBranchInput = {
    where: AgentScalarWhereInput
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyWithoutBranchInput>
  }

  export type AgentScalarWhereInput = {
    AND?: AgentScalarWhereInput | AgentScalarWhereInput[]
    OR?: AgentScalarWhereInput[]
    NOT?: AgentScalarWhereInput | AgentScalarWhereInput[]
    id?: UuidFilter<"Agent"> | string
    position?: StringNullableFilter<"Agent"> | string | null
    department?: StringNullableFilter<"Agent"> | string | null
    licenseNumber?: StringNullableFilter<"Agent"> | string | null
    licenseExpireDate?: DateTimeNullableFilter<"Agent"> | Date | string | null
    goodCount?: IntFilter<"Agent"> | number
    responseRate?: DecimalNullableFilter<"Agent"> | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: IntNullableFilter<"Agent"> | number | null
    userId?: UuidFilter<"Agent"> | string
    branchId?: UuidFilter<"Agent"> | string
    isActive?: BoolFilter<"Agent"> | boolean
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Agent"> | Date | string | null
  }

  export type UserCreateWithoutAgentInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutAuthorInput
    answers?: AnswerCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentCreateNestedManyWithoutUserInput
    mails?: MailCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateWithoutAgentInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutAuthorInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentUncheckedCreateNestedManyWithoutUserInput
    mails?: MailUncheckedCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserCreateOrConnectWithoutAgentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
  }

  export type BranchCreateWithoutAgentsInput = {
    id?: string
    branchName: string
    postalCode: string
    prefecture: string
    city: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    phone: string
    fax?: string | null
    businessHours?: string | null
    isHeadquarters?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutBranchesInput
  }

  export type BranchUncheckedCreateWithoutAgentsInput = {
    id?: string
    branchName: string
    postalCode: string
    prefecture: string
    city: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    phone: string
    fax?: string | null
    businessHours?: string | null
    isHeadquarters?: boolean
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BranchCreateOrConnectWithoutAgentsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutAgentsInput, BranchUncheckedCreateWithoutAgentsInput>
  }

  export type PropertyCreateWithoutAgentInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutPropertiesInput
    propertyCategory?: PropertyCategoryMasterCreateNestedOneWithoutPropertiesInput
    area?: AreaMasterCreateNestedOneWithoutPropertiesInput
    layoutType?: FloorPlanMasterCreateNestedOneWithoutPropertiesInput
    user: UserCreateNestedOneWithoutPropertiesInput
    publication?: PropertyPublicationCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryCreateNestedManyWithoutPropertyInput
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutAgentInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
    publication?: PropertyPublicationUncheckedCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutPropertyInput
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutAgentInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutAgentInput, PropertyUncheckedCreateWithoutAgentInput>
  }

  export type PropertyCreateManyAgentInputEnvelope = {
    data: PropertyCreateManyAgentInput | PropertyCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type InquiryCreateWithoutAssignedAgentInput = {
    id?: string
    inquiryNumber: string
    targetType: $Enums.TargetType
    name: string
    furigana?: string | null
    email: string
    phone?: string | null
    companyName?: string | null
    inquiryType?: $Enums.InquiryType
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    assignedAt?: Date | string | null
    responseCount?: number
    lastRespondedAt?: Date | string | null
    closedAt?: Date | string | null
    closedReason?: string | null
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutInquiriesInput
    property?: PropertyCreateNestedOneWithoutInquiriesInput
    messages?: InquiryMessageCreateNestedManyWithoutInquiryInput
  }

  export type InquiryUncheckedCreateWithoutAssignedAgentInput = {
    id?: string
    inquiryNumber: string
    targetType: $Enums.TargetType
    targetId?: string | null
    name: string
    furigana?: string | null
    email: string
    phone?: string | null
    companyName?: string | null
    inquiryType?: $Enums.InquiryType
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    userId?: string | null
    assignedAt?: Date | string | null
    responseCount?: number
    lastRespondedAt?: Date | string | null
    closedAt?: Date | string | null
    closedReason?: string | null
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: InquiryMessageUncheckedCreateNestedManyWithoutInquiryInput
  }

  export type InquiryCreateOrConnectWithoutAssignedAgentInput = {
    where: InquiryWhereUniqueInput
    create: XOR<InquiryCreateWithoutAssignedAgentInput, InquiryUncheckedCreateWithoutAssignedAgentInput>
  }

  export type InquiryCreateManyAssignedAgentInputEnvelope = {
    data: InquiryCreateManyAssignedAgentInput | InquiryCreateManyAssignedAgentInput[]
    skipDuplicates?: boolean
  }

  export type AnswerCreateWithoutAgentInput = {
    id?: string
    content: string
    goodCount?: number
    isBestAnswer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    question: QuestionCreateNestedOneWithoutAnswersInput
    author?: UserCreateNestedOneWithoutAnswersInput
  }

  export type AnswerUncheckedCreateWithoutAgentInput = {
    id?: string
    questionId: string
    content: string
    goodCount?: number
    isBestAnswer?: boolean
    authorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AnswerCreateOrConnectWithoutAgentInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutAgentInput, AnswerUncheckedCreateWithoutAgentInput>
  }

  export type AnswerCreateManyAgentInputEnvelope = {
    data: AnswerCreateManyAgentInput | AnswerCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type BulkAssessmentResponseCreateWithoutAgentInput = {
    id?: string
    assessedPrice?: bigint | number | null
    priceRangeMin?: bigint | number | null
    priceRangeMax?: bigint | number | null
    comments?: string | null
    proposalDocument?: string | null
    status?: $Enums.ResponseStatus
    submittedAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    assessment: BulkAssessmentCreateNestedOneWithoutResponsesInput
  }

  export type BulkAssessmentResponseUncheckedCreateWithoutAgentInput = {
    id?: string
    assessmentId: string
    assessedPrice?: bigint | number | null
    priceRangeMin?: bigint | number | null
    priceRangeMax?: bigint | number | null
    comments?: string | null
    proposalDocument?: string | null
    status?: $Enums.ResponseStatus
    submittedAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BulkAssessmentResponseCreateOrConnectWithoutAgentInput = {
    where: BulkAssessmentResponseWhereUniqueInput
    create: XOR<BulkAssessmentResponseCreateWithoutAgentInput, BulkAssessmentResponseUncheckedCreateWithoutAgentInput>
  }

  export type BulkAssessmentResponseCreateManyAgentInputEnvelope = {
    data: BulkAssessmentResponseCreateManyAgentInput | BulkAssessmentResponseCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAgentInput = {
    update: XOR<UserUpdateWithoutAgentInput, UserUncheckedUpdateWithoutAgentInput>
    create: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgentInput, UserUncheckedUpdateWithoutAgentInput>
  }

  export type UserUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUpdateManyWithoutUserNestedInput
    mails?: MailUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUncheckedUpdateManyWithoutUserNestedInput
    mails?: MailUncheckedUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type BranchUpsertWithoutAgentsInput = {
    update: XOR<BranchUpdateWithoutAgentsInput, BranchUncheckedUpdateWithoutAgentsInput>
    create: XOR<BranchCreateWithoutAgentsInput, BranchUncheckedCreateWithoutAgentsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutAgentsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutAgentsInput, BranchUncheckedUpdateWithoutAgentsInput>
  }

  export type BranchUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    phone?: StringFieldUpdateOperationsInput | string
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    businessHours?: NullableStringFieldUpdateOperationsInput | string | null
    isHeadquarters?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
  }

  export type BranchUncheckedUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    phone?: StringFieldUpdateOperationsInput | string
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    businessHours?: NullableStringFieldUpdateOperationsInput | string | null
    isHeadquarters?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyUpsertWithWhereUniqueWithoutAgentInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutAgentInput, PropertyUncheckedUpdateWithoutAgentInput>
    create: XOR<PropertyCreateWithoutAgentInput, PropertyUncheckedCreateWithoutAgentInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutAgentInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutAgentInput, PropertyUncheckedUpdateWithoutAgentInput>
  }

  export type PropertyUpdateManyWithWhereWithoutAgentInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutAgentInput>
  }

  export type InquiryUpsertWithWhereUniqueWithoutAssignedAgentInput = {
    where: InquiryWhereUniqueInput
    update: XOR<InquiryUpdateWithoutAssignedAgentInput, InquiryUncheckedUpdateWithoutAssignedAgentInput>
    create: XOR<InquiryCreateWithoutAssignedAgentInput, InquiryUncheckedCreateWithoutAssignedAgentInput>
  }

  export type InquiryUpdateWithWhereUniqueWithoutAssignedAgentInput = {
    where: InquiryWhereUniqueInput
    data: XOR<InquiryUpdateWithoutAssignedAgentInput, InquiryUncheckedUpdateWithoutAssignedAgentInput>
  }

  export type InquiryUpdateManyWithWhereWithoutAssignedAgentInput = {
    where: InquiryScalarWhereInput
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyWithoutAssignedAgentInput>
  }

  export type AnswerUpsertWithWhereUniqueWithoutAgentInput = {
    where: AnswerWhereUniqueInput
    update: XOR<AnswerUpdateWithoutAgentInput, AnswerUncheckedUpdateWithoutAgentInput>
    create: XOR<AnswerCreateWithoutAgentInput, AnswerUncheckedCreateWithoutAgentInput>
  }

  export type AnswerUpdateWithWhereUniqueWithoutAgentInput = {
    where: AnswerWhereUniqueInput
    data: XOR<AnswerUpdateWithoutAgentInput, AnswerUncheckedUpdateWithoutAgentInput>
  }

  export type AnswerUpdateManyWithWhereWithoutAgentInput = {
    where: AnswerScalarWhereInput
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyWithoutAgentInput>
  }

  export type BulkAssessmentResponseUpsertWithWhereUniqueWithoutAgentInput = {
    where: BulkAssessmentResponseWhereUniqueInput
    update: XOR<BulkAssessmentResponseUpdateWithoutAgentInput, BulkAssessmentResponseUncheckedUpdateWithoutAgentInput>
    create: XOR<BulkAssessmentResponseCreateWithoutAgentInput, BulkAssessmentResponseUncheckedCreateWithoutAgentInput>
  }

  export type BulkAssessmentResponseUpdateWithWhereUniqueWithoutAgentInput = {
    where: BulkAssessmentResponseWhereUniqueInput
    data: XOR<BulkAssessmentResponseUpdateWithoutAgentInput, BulkAssessmentResponseUncheckedUpdateWithoutAgentInput>
  }

  export type BulkAssessmentResponseUpdateManyWithWhereWithoutAgentInput = {
    where: BulkAssessmentResponseScalarWhereInput
    data: XOR<BulkAssessmentResponseUpdateManyMutationInput, BulkAssessmentResponseUncheckedUpdateManyWithoutAgentInput>
  }

  export type BulkAssessmentResponseScalarWhereInput = {
    AND?: BulkAssessmentResponseScalarWhereInput | BulkAssessmentResponseScalarWhereInput[]
    OR?: BulkAssessmentResponseScalarWhereInput[]
    NOT?: BulkAssessmentResponseScalarWhereInput | BulkAssessmentResponseScalarWhereInput[]
    id?: UuidFilter<"BulkAssessmentResponse"> | string
    assessmentId?: UuidFilter<"BulkAssessmentResponse"> | string
    agentId?: UuidFilter<"BulkAssessmentResponse"> | string
    assessedPrice?: BigIntNullableFilter<"BulkAssessmentResponse"> | bigint | number | null
    priceRangeMin?: BigIntNullableFilter<"BulkAssessmentResponse"> | bigint | number | null
    priceRangeMax?: BigIntNullableFilter<"BulkAssessmentResponse"> | bigint | number | null
    comments?: StringNullableFilter<"BulkAssessmentResponse"> | string | null
    proposalDocument?: StringNullableFilter<"BulkAssessmentResponse"> | string | null
    status?: EnumResponseStatusFilter<"BulkAssessmentResponse"> | $Enums.ResponseStatus
    submittedAt?: DateTimeNullableFilter<"BulkAssessmentResponse"> | Date | string | null
    viewedAt?: DateTimeNullableFilter<"BulkAssessmentResponse"> | Date | string | null
    createdAt?: DateTimeFilter<"BulkAssessmentResponse"> | Date | string
  }

  export type PropertyTypeMasterCreateWithoutPropertiesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    displayOrder?: number
    isActive?: boolean
    bulkAssessments?: BulkAssessmentCreateNestedManyWithoutPropertyTypeInput
  }

  export type PropertyTypeMasterUncheckedCreateWithoutPropertiesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    displayOrder?: number
    isActive?: boolean
    bulkAssessments?: BulkAssessmentUncheckedCreateNestedManyWithoutPropertyTypeInput
  }

  export type PropertyTypeMasterCreateOrConnectWithoutPropertiesInput = {
    where: PropertyTypeMasterWhereUniqueInput
    create: XOR<PropertyTypeMasterCreateWithoutPropertiesInput, PropertyTypeMasterUncheckedCreateWithoutPropertiesInput>
  }

  export type PropertyCategoryMasterCreateWithoutPropertiesInput = {
    id?: string
    code: string
    name: string
    displayOrder?: number
    isActive?: boolean
  }

  export type PropertyCategoryMasterUncheckedCreateWithoutPropertiesInput = {
    id?: string
    code: string
    name: string
    displayOrder?: number
    isActive?: boolean
  }

  export type PropertyCategoryMasterCreateOrConnectWithoutPropertiesInput = {
    where: PropertyCategoryMasterWhereUniqueInput
    create: XOR<PropertyCategoryMasterCreateWithoutPropertiesInput, PropertyCategoryMasterUncheckedCreateWithoutPropertiesInput>
  }

  export type AreaMasterCreateWithoutPropertiesInput = {
    id?: string
    prefectureCode: string
    prefecture: string
    cityCode?: string | null
    city: string
    displayOrder?: number
    isActive?: boolean
    region?: RegionMasterCreateNestedOneWithoutAreasInput
  }

  export type AreaMasterUncheckedCreateWithoutPropertiesInput = {
    id?: string
    regionId?: string | null
    prefectureCode: string
    prefecture: string
    cityCode?: string | null
    city: string
    displayOrder?: number
    isActive?: boolean
  }

  export type AreaMasterCreateOrConnectWithoutPropertiesInput = {
    where: AreaMasterWhereUniqueInput
    create: XOR<AreaMasterCreateWithoutPropertiesInput, AreaMasterUncheckedCreateWithoutPropertiesInput>
  }

  export type FloorPlanMasterCreateWithoutPropertiesInput = {
    id?: string
    code: string
    name: string
    roomCount?: number | null
    displayOrder?: number
    isActive?: boolean
  }

  export type FloorPlanMasterUncheckedCreateWithoutPropertiesInput = {
    id?: string
    code: string
    name: string
    roomCount?: number | null
    displayOrder?: number
    isActive?: boolean
  }

  export type FloorPlanMasterCreateOrConnectWithoutPropertiesInput = {
    where: FloorPlanMasterWhereUniqueInput
    create: XOR<FloorPlanMasterCreateWithoutPropertiesInput, FloorPlanMasterUncheckedCreateWithoutPropertiesInput>
  }

  export type AgentCreateWithoutPropertiesInput = {
    id?: string
    position?: string | null
    department?: string | null
    licenseNumber?: string | null
    licenseExpireDate?: Date | string | null
    goodCount?: number
    responseRate?: Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAgentInput
    branch: BranchCreateNestedOneWithoutAgentsInput
    assignedInquiries?: InquiryCreateNestedManyWithoutAssignedAgentInput
    answers?: AnswerCreateNestedManyWithoutAgentInput
    bulkAssessmentResponses?: BulkAssessmentResponseCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutPropertiesInput = {
    id?: string
    position?: string | null
    department?: string | null
    licenseNumber?: string | null
    licenseExpireDate?: Date | string | null
    goodCount?: number
    responseRate?: Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: number | null
    userId: string
    branchId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    assignedInquiries?: InquiryUncheckedCreateNestedManyWithoutAssignedAgentInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAgentInput
    bulkAssessmentResponses?: BulkAssessmentResponseUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutPropertiesInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutPropertiesInput, AgentUncheckedCreateWithoutPropertiesInput>
  }

  export type UserCreateWithoutPropertiesInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutAuthorInput
    answers?: AnswerCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentCreateNestedManyWithoutUserInput
    mails?: MailCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateWithoutPropertiesInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutAuthorInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentUncheckedCreateNestedManyWithoutUserInput
    mails?: MailUncheckedCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserCreateOrConnectWithoutPropertiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
  }

  export type PropertyPublicationCreateWithoutPropertyInput = {
    id?: string
    status?: $Enums.PublicationStatus
    scope?: $Enums.PublicScope
    featured?: boolean
    featuredOrder?: number | null
    publishedAt?: Date | string | null
    unpublishedAt?: Date | string | null
    soldAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyPublicationUncheckedCreateWithoutPropertyInput = {
    id?: string
    status?: $Enums.PublicationStatus
    scope?: $Enums.PublicScope
    featured?: boolean
    featuredOrder?: number | null
    publishedAt?: Date | string | null
    unpublishedAt?: Date | string | null
    soldAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyPublicationCreateOrConnectWithoutPropertyInput = {
    where: PropertyPublicationWhereUniqueInput
    create: XOR<PropertyPublicationCreateWithoutPropertyInput, PropertyPublicationUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyPriceHistoryCreateWithoutPropertyInput = {
    id?: string
    previousPrice?: bigint | number | null
    newPrice: bigint | number
    changePercent?: Decimal | DecimalJsLike | number | string | null
    changeReason?: string | null
    createdAt?: Date | string
    changedBy?: UserCreateNestedOneWithoutPriceHistoryChangesInput
  }

  export type PropertyPriceHistoryUncheckedCreateWithoutPropertyInput = {
    id?: string
    previousPrice?: bigint | number | null
    newPrice: bigint | number
    changePercent?: Decimal | DecimalJsLike | number | string | null
    changeReason?: string | null
    changedById?: string | null
    createdAt?: Date | string
  }

  export type PropertyPriceHistoryCreateOrConnectWithoutPropertyInput = {
    where: PropertyPriceHistoryWhereUniqueInput
    create: XOR<PropertyPriceHistoryCreateWithoutPropertyInput, PropertyPriceHistoryUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyPriceHistoryCreateManyPropertyInputEnvelope = {
    data: PropertyPriceHistoryCreateManyPropertyInput | PropertyPriceHistoryCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyStatusHistoryCreateWithoutPropertyInput = {
    id?: string
    previousStatus?: string | null
    newStatus: string
    changeReason?: string | null
    createdAt?: Date | string
    changedBy?: UserCreateNestedOneWithoutStatusHistoryChangesInput
  }

  export type PropertyStatusHistoryUncheckedCreateWithoutPropertyInput = {
    id?: string
    previousStatus?: string | null
    newStatus: string
    changeReason?: string | null
    changedById?: string | null
    createdAt?: Date | string
  }

  export type PropertyStatusHistoryCreateOrConnectWithoutPropertyInput = {
    where: PropertyStatusHistoryWhereUniqueInput
    create: XOR<PropertyStatusHistoryCreateWithoutPropertyInput, PropertyStatusHistoryUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyStatusHistoryCreateManyPropertyInputEnvelope = {
    data: PropertyStatusHistoryCreateManyPropertyInput | PropertyStatusHistoryCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyImageCreateWithoutPropertyInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    imageType?: $Enums.ImageType
    displayOrder?: number
    isMain?: boolean
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    fileBox?: FileBoxCreateNestedOneWithoutPropertyImagesInput
  }

  export type PropertyImageUncheckedCreateWithoutPropertyInput = {
    id?: string
    fileBoxId?: string | null
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    imageType?: $Enums.ImageType
    displayOrder?: number
    isMain?: boolean
    width?: number | null
    height?: number | null
    createdAt?: Date | string
  }

  export type PropertyImageCreateOrConnectWithoutPropertyInput = {
    where: PropertyImageWhereUniqueInput
    create: XOR<PropertyImageCreateWithoutPropertyInput, PropertyImageUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyImageCreateManyPropertyInputEnvelope = {
    data: PropertyImageCreateManyPropertyInput | PropertyImageCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyFeatureCreateWithoutPropertyInput = {
    id?: string
    feature: FeatureMasterCreateNestedOneWithoutPropertiesInput
  }

  export type PropertyFeatureUncheckedCreateWithoutPropertyInput = {
    id?: string
    featureId: string
  }

  export type PropertyFeatureCreateOrConnectWithoutPropertyInput = {
    where: PropertyFeatureWhereUniqueInput
    create: XOR<PropertyFeatureCreateWithoutPropertyInput, PropertyFeatureUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyFeatureCreateManyPropertyInputEnvelope = {
    data: PropertyFeatureCreateManyPropertyInput | PropertyFeatureCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyStationCreateWithoutPropertyInput = {
    id?: string
    walkMinutes?: number | null
    busMinutes?: number | null
    busStopName?: string | null
    isPrimary?: boolean
    station: StationCreateNestedOneWithoutPropertyStationsInput
  }

  export type PropertyStationUncheckedCreateWithoutPropertyInput = {
    id?: string
    stationId: string
    walkMinutes?: number | null
    busMinutes?: number | null
    busStopName?: string | null
    isPrimary?: boolean
  }

  export type PropertyStationCreateOrConnectWithoutPropertyInput = {
    where: PropertyStationWhereUniqueInput
    create: XOR<PropertyStationCreateWithoutPropertyInput, PropertyStationUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyStationCreateManyPropertyInputEnvelope = {
    data: PropertyStationCreateManyPropertyInput | PropertyStationCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type InquiryCreateWithoutPropertyInput = {
    id?: string
    inquiryNumber: string
    targetType: $Enums.TargetType
    name: string
    furigana?: string | null
    email: string
    phone?: string | null
    companyName?: string | null
    inquiryType?: $Enums.InquiryType
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    assignedAt?: Date | string | null
    responseCount?: number
    lastRespondedAt?: Date | string | null
    closedAt?: Date | string | null
    closedReason?: string | null
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutInquiriesInput
    assignedAgent?: AgentCreateNestedOneWithoutAssignedInquiriesInput
    messages?: InquiryMessageCreateNestedManyWithoutInquiryInput
  }

  export type InquiryUncheckedCreateWithoutPropertyInput = {
    id?: string
    inquiryNumber: string
    targetType: $Enums.TargetType
    name: string
    furigana?: string | null
    email: string
    phone?: string | null
    companyName?: string | null
    inquiryType?: $Enums.InquiryType
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    userId?: string | null
    assignedAgentId?: string | null
    assignedAt?: Date | string | null
    responseCount?: number
    lastRespondedAt?: Date | string | null
    closedAt?: Date | string | null
    closedReason?: string | null
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: InquiryMessageUncheckedCreateNestedManyWithoutInquiryInput
  }

  export type InquiryCreateOrConnectWithoutPropertyInput = {
    where: InquiryWhereUniqueInput
    create: XOR<InquiryCreateWithoutPropertyInput, InquiryUncheckedCreateWithoutPropertyInput>
  }

  export type InquiryCreateManyPropertyInputEnvelope = {
    data: InquiryCreateManyPropertyInput | InquiryCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteCreateWithoutPropertyInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateWithoutPropertyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type FavoriteCreateOrConnectWithoutPropertyInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutPropertyInput, FavoriteUncheckedCreateWithoutPropertyInput>
  }

  export type FavoriteCreateManyPropertyInputEnvelope = {
    data: FavoriteCreateManyPropertyInput | FavoriteCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyViewCreateWithoutPropertyInput = {
    id?: string
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    referer?: string | null
    viewedAt?: Date | string
    viewDurationSeconds?: number | null
    user?: UserCreateNestedOneWithoutPropertyViewsInput
  }

  export type PropertyViewUncheckedCreateWithoutPropertyInput = {
    id?: string
    userId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    referer?: string | null
    viewedAt?: Date | string
    viewDurationSeconds?: number | null
  }

  export type PropertyViewCreateOrConnectWithoutPropertyInput = {
    where: PropertyViewWhereUniqueInput
    create: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyViewCreateManyPropertyInputEnvelope = {
    data: PropertyViewCreateManyPropertyInput | PropertyViewCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyViewDailyCreateWithoutPropertyInput = {
    id?: string
    viewDate: Date | string
    totalViews?: number
    uniqueUsers?: number
    avgDurationSeconds?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PropertyViewDailyUncheckedCreateWithoutPropertyInput = {
    id?: string
    viewDate: Date | string
    totalViews?: number
    uniqueUsers?: number
    avgDurationSeconds?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PropertyViewDailyCreateOrConnectWithoutPropertyInput = {
    where: PropertyViewDailyWhereUniqueInput
    create: XOR<PropertyViewDailyCreateWithoutPropertyInput, PropertyViewDailyUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyViewDailyCreateManyPropertyInputEnvelope = {
    data: PropertyViewDailyCreateManyPropertyInput | PropertyViewDailyCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyTypeMasterUpsertWithoutPropertiesInput = {
    update: XOR<PropertyTypeMasterUpdateWithoutPropertiesInput, PropertyTypeMasterUncheckedUpdateWithoutPropertiesInput>
    create: XOR<PropertyTypeMasterCreateWithoutPropertiesInput, PropertyTypeMasterUncheckedCreateWithoutPropertiesInput>
    where?: PropertyTypeMasterWhereInput
  }

  export type PropertyTypeMasterUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: PropertyTypeMasterWhereInput
    data: XOR<PropertyTypeMasterUpdateWithoutPropertiesInput, PropertyTypeMasterUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyTypeMasterUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bulkAssessments?: BulkAssessmentUpdateManyWithoutPropertyTypeNestedInput
  }

  export type PropertyTypeMasterUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bulkAssessments?: BulkAssessmentUncheckedUpdateManyWithoutPropertyTypeNestedInput
  }

  export type PropertyCategoryMasterUpsertWithoutPropertiesInput = {
    update: XOR<PropertyCategoryMasterUpdateWithoutPropertiesInput, PropertyCategoryMasterUncheckedUpdateWithoutPropertiesInput>
    create: XOR<PropertyCategoryMasterCreateWithoutPropertiesInput, PropertyCategoryMasterUncheckedCreateWithoutPropertiesInput>
    where?: PropertyCategoryMasterWhereInput
  }

  export type PropertyCategoryMasterUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: PropertyCategoryMasterWhereInput
    data: XOR<PropertyCategoryMasterUpdateWithoutPropertiesInput, PropertyCategoryMasterUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyCategoryMasterUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertyCategoryMasterUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AreaMasterUpsertWithoutPropertiesInput = {
    update: XOR<AreaMasterUpdateWithoutPropertiesInput, AreaMasterUncheckedUpdateWithoutPropertiesInput>
    create: XOR<AreaMasterCreateWithoutPropertiesInput, AreaMasterUncheckedCreateWithoutPropertiesInput>
    where?: AreaMasterWhereInput
  }

  export type AreaMasterUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: AreaMasterWhereInput
    data: XOR<AreaMasterUpdateWithoutPropertiesInput, AreaMasterUncheckedUpdateWithoutPropertiesInput>
  }

  export type AreaMasterUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    prefectureCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    region?: RegionMasterUpdateOneWithoutAreasNestedInput
  }

  export type AreaMasterUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    regionId?: NullableStringFieldUpdateOperationsInput | string | null
    prefectureCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FloorPlanMasterUpsertWithoutPropertiesInput = {
    update: XOR<FloorPlanMasterUpdateWithoutPropertiesInput, FloorPlanMasterUncheckedUpdateWithoutPropertiesInput>
    create: XOR<FloorPlanMasterCreateWithoutPropertiesInput, FloorPlanMasterUncheckedCreateWithoutPropertiesInput>
    where?: FloorPlanMasterWhereInput
  }

  export type FloorPlanMasterUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: FloorPlanMasterWhereInput
    data: XOR<FloorPlanMasterUpdateWithoutPropertiesInput, FloorPlanMasterUncheckedUpdateWithoutPropertiesInput>
  }

  export type FloorPlanMasterUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roomCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FloorPlanMasterUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roomCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AgentUpsertWithoutPropertiesInput = {
    update: XOR<AgentUpdateWithoutPropertiesInput, AgentUncheckedUpdateWithoutPropertiesInput>
    create: XOR<AgentCreateWithoutPropertiesInput, AgentUncheckedCreateWithoutPropertiesInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutPropertiesInput, AgentUncheckedUpdateWithoutPropertiesInput>
  }

  export type AgentUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goodCount?: IntFieldUpdateOperationsInput | number
    responseRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    branch?: BranchUpdateOneRequiredWithoutAgentsNestedInput
    assignedInquiries?: InquiryUpdateManyWithoutAssignedAgentNestedInput
    answers?: AnswerUpdateManyWithoutAgentNestedInput
    bulkAssessmentResponses?: BulkAssessmentResponseUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goodCount?: IntFieldUpdateOperationsInput | number
    responseRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedInquiries?: InquiryUncheckedUpdateManyWithoutAssignedAgentNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAgentNestedInput
    bulkAssessmentResponses?: BulkAssessmentResponseUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type UserUpsertWithoutPropertiesInput = {
    update: XOR<UserUpdateWithoutPropertiesInput, UserUncheckedUpdateWithoutPropertiesInput>
    create: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPropertiesInput, UserUncheckedUpdateWithoutPropertiesInput>
  }

  export type UserUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUpdateManyWithoutUserNestedInput
    mails?: MailUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUncheckedUpdateManyWithoutUserNestedInput
    mails?: MailUncheckedUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type PropertyPublicationUpsertWithoutPropertyInput = {
    update: XOR<PropertyPublicationUpdateWithoutPropertyInput, PropertyPublicationUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyPublicationCreateWithoutPropertyInput, PropertyPublicationUncheckedCreateWithoutPropertyInput>
    where?: PropertyPublicationWhereInput
  }

  export type PropertyPublicationUpdateToOneWithWhereWithoutPropertyInput = {
    where?: PropertyPublicationWhereInput
    data: XOR<PropertyPublicationUpdateWithoutPropertyInput, PropertyPublicationUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyPublicationUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    scope?: EnumPublicScopeFieldUpdateOperationsInput | $Enums.PublicScope
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredOrder?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unpublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soldAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPublicationUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    scope?: EnumPublicScopeFieldUpdateOperationsInput | $Enums.PublicScope
    featured?: BoolFieldUpdateOperationsInput | boolean
    featuredOrder?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unpublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soldAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPriceHistoryUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyPriceHistoryWhereUniqueInput
    update: XOR<PropertyPriceHistoryUpdateWithoutPropertyInput, PropertyPriceHistoryUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyPriceHistoryCreateWithoutPropertyInput, PropertyPriceHistoryUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyPriceHistoryUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyPriceHistoryWhereUniqueInput
    data: XOR<PropertyPriceHistoryUpdateWithoutPropertyInput, PropertyPriceHistoryUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyPriceHistoryUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyPriceHistoryScalarWhereInput
    data: XOR<PropertyPriceHistoryUpdateManyMutationInput, PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyStatusHistoryUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyStatusHistoryWhereUniqueInput
    update: XOR<PropertyStatusHistoryUpdateWithoutPropertyInput, PropertyStatusHistoryUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyStatusHistoryCreateWithoutPropertyInput, PropertyStatusHistoryUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyStatusHistoryUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyStatusHistoryWhereUniqueInput
    data: XOR<PropertyStatusHistoryUpdateWithoutPropertyInput, PropertyStatusHistoryUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyStatusHistoryUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyStatusHistoryScalarWhereInput
    data: XOR<PropertyStatusHistoryUpdateManyMutationInput, PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyImageUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyImageWhereUniqueInput
    update: XOR<PropertyImageUpdateWithoutPropertyInput, PropertyImageUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyImageCreateWithoutPropertyInput, PropertyImageUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyImageUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyImageWhereUniqueInput
    data: XOR<PropertyImageUpdateWithoutPropertyInput, PropertyImageUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyImageUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyImageScalarWhereInput
    data: XOR<PropertyImageUpdateManyMutationInput, PropertyImageUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyImageScalarWhereInput = {
    AND?: PropertyImageScalarWhereInput | PropertyImageScalarWhereInput[]
    OR?: PropertyImageScalarWhereInput[]
    NOT?: PropertyImageScalarWhereInput | PropertyImageScalarWhereInput[]
    id?: UuidFilter<"PropertyImage"> | string
    propertyId?: UuidFilter<"PropertyImage"> | string
    fileBoxId?: UuidNullableFilter<"PropertyImage"> | string | null
    url?: StringFilter<"PropertyImage"> | string
    thumbnailUrl?: StringNullableFilter<"PropertyImage"> | string | null
    caption?: StringNullableFilter<"PropertyImage"> | string | null
    imageType?: EnumImageTypeFilter<"PropertyImage"> | $Enums.ImageType
    displayOrder?: IntFilter<"PropertyImage"> | number
    isMain?: BoolFilter<"PropertyImage"> | boolean
    width?: IntNullableFilter<"PropertyImage"> | number | null
    height?: IntNullableFilter<"PropertyImage"> | number | null
    createdAt?: DateTimeFilter<"PropertyImage"> | Date | string
  }

  export type PropertyFeatureUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyFeatureWhereUniqueInput
    update: XOR<PropertyFeatureUpdateWithoutPropertyInput, PropertyFeatureUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyFeatureCreateWithoutPropertyInput, PropertyFeatureUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyFeatureUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyFeatureWhereUniqueInput
    data: XOR<PropertyFeatureUpdateWithoutPropertyInput, PropertyFeatureUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyFeatureUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyFeatureScalarWhereInput
    data: XOR<PropertyFeatureUpdateManyMutationInput, PropertyFeatureUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyFeatureScalarWhereInput = {
    AND?: PropertyFeatureScalarWhereInput | PropertyFeatureScalarWhereInput[]
    OR?: PropertyFeatureScalarWhereInput[]
    NOT?: PropertyFeatureScalarWhereInput | PropertyFeatureScalarWhereInput[]
    id?: UuidFilter<"PropertyFeature"> | string
    propertyId?: UuidFilter<"PropertyFeature"> | string
    featureId?: UuidFilter<"PropertyFeature"> | string
  }

  export type PropertyStationUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyStationWhereUniqueInput
    update: XOR<PropertyStationUpdateWithoutPropertyInput, PropertyStationUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyStationCreateWithoutPropertyInput, PropertyStationUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyStationUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyStationWhereUniqueInput
    data: XOR<PropertyStationUpdateWithoutPropertyInput, PropertyStationUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyStationUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyStationScalarWhereInput
    data: XOR<PropertyStationUpdateManyMutationInput, PropertyStationUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyStationScalarWhereInput = {
    AND?: PropertyStationScalarWhereInput | PropertyStationScalarWhereInput[]
    OR?: PropertyStationScalarWhereInput[]
    NOT?: PropertyStationScalarWhereInput | PropertyStationScalarWhereInput[]
    id?: UuidFilter<"PropertyStation"> | string
    propertyId?: UuidFilter<"PropertyStation"> | string
    stationId?: UuidFilter<"PropertyStation"> | string
    walkMinutes?: IntNullableFilter<"PropertyStation"> | number | null
    busMinutes?: IntNullableFilter<"PropertyStation"> | number | null
    busStopName?: StringNullableFilter<"PropertyStation"> | string | null
    isPrimary?: BoolFilter<"PropertyStation"> | boolean
  }

  export type InquiryUpsertWithWhereUniqueWithoutPropertyInput = {
    where: InquiryWhereUniqueInput
    update: XOR<InquiryUpdateWithoutPropertyInput, InquiryUncheckedUpdateWithoutPropertyInput>
    create: XOR<InquiryCreateWithoutPropertyInput, InquiryUncheckedCreateWithoutPropertyInput>
  }

  export type InquiryUpdateWithWhereUniqueWithoutPropertyInput = {
    where: InquiryWhereUniqueInput
    data: XOR<InquiryUpdateWithoutPropertyInput, InquiryUncheckedUpdateWithoutPropertyInput>
  }

  export type InquiryUpdateManyWithWhereWithoutPropertyInput = {
    where: InquiryScalarWhereInput
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyWithoutPropertyInput>
  }

  export type FavoriteUpsertWithWhereUniqueWithoutPropertyInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutPropertyInput, FavoriteUncheckedUpdateWithoutPropertyInput>
    create: XOR<FavoriteCreateWithoutPropertyInput, FavoriteUncheckedCreateWithoutPropertyInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutPropertyInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutPropertyInput, FavoriteUncheckedUpdateWithoutPropertyInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutPropertyInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyViewUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyViewWhereUniqueInput
    update: XOR<PropertyViewUpdateWithoutPropertyInput, PropertyViewUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyViewUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyViewWhereUniqueInput
    data: XOR<PropertyViewUpdateWithoutPropertyInput, PropertyViewUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyViewUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyViewScalarWhereInput
    data: XOR<PropertyViewUpdateManyMutationInput, PropertyViewUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyViewDailyUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyViewDailyWhereUniqueInput
    update: XOR<PropertyViewDailyUpdateWithoutPropertyInput, PropertyViewDailyUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyViewDailyCreateWithoutPropertyInput, PropertyViewDailyUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyViewDailyUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyViewDailyWhereUniqueInput
    data: XOR<PropertyViewDailyUpdateWithoutPropertyInput, PropertyViewDailyUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyViewDailyUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyViewDailyScalarWhereInput
    data: XOR<PropertyViewDailyUpdateManyMutationInput, PropertyViewDailyUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyViewDailyScalarWhereInput = {
    AND?: PropertyViewDailyScalarWhereInput | PropertyViewDailyScalarWhereInput[]
    OR?: PropertyViewDailyScalarWhereInput[]
    NOT?: PropertyViewDailyScalarWhereInput | PropertyViewDailyScalarWhereInput[]
    id?: UuidFilter<"PropertyViewDaily"> | string
    propertyId?: UuidFilter<"PropertyViewDaily"> | string
    viewDate?: DateTimeFilter<"PropertyViewDaily"> | Date | string
    totalViews?: IntFilter<"PropertyViewDaily"> | number
    uniqueUsers?: IntFilter<"PropertyViewDaily"> | number
    avgDurationSeconds?: DecimalNullableFilter<"PropertyViewDaily"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"PropertyViewDaily"> | Date | string
  }

  export type PropertyCreateWithoutPublicationInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutPropertiesInput
    propertyCategory?: PropertyCategoryMasterCreateNestedOneWithoutPropertiesInput
    area?: AreaMasterCreateNestedOneWithoutPropertiesInput
    layoutType?: FloorPlanMasterCreateNestedOneWithoutPropertiesInput
    agent?: AgentCreateNestedOneWithoutPropertiesInput
    user: UserCreateNestedOneWithoutPropertiesInput
    priceHistories?: PropertyPriceHistoryCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryCreateNestedManyWithoutPropertyInput
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPublicationInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
    priceHistories?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutPropertyInput
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPublicationInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPublicationInput, PropertyUncheckedCreateWithoutPublicationInput>
  }

  export type PropertyUpsertWithoutPublicationInput = {
    update: XOR<PropertyUpdateWithoutPublicationInput, PropertyUncheckedUpdateWithoutPublicationInput>
    create: XOR<PropertyCreateWithoutPublicationInput, PropertyUncheckedCreateWithoutPublicationInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPublicationInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPublicationInput, PropertyUncheckedUpdateWithoutPublicationInput>
  }

  export type PropertyUpdateWithoutPublicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyType?: PropertyTypeMasterUpdateOneWithoutPropertiesNestedInput
    propertyCategory?: PropertyCategoryMasterUpdateOneWithoutPropertiesNestedInput
    area?: AreaMasterUpdateOneWithoutPropertiesNestedInput
    layoutType?: FloorPlanMasterUpdateOneWithoutPropertiesNestedInput
    agent?: AgentUpdateOneWithoutPropertiesNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    priceHistories?: PropertyPriceHistoryUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPublicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    priceHistories?: PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutPriceHistoriesInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutPropertiesInput
    propertyCategory?: PropertyCategoryMasterCreateNestedOneWithoutPropertiesInput
    area?: AreaMasterCreateNestedOneWithoutPropertiesInput
    layoutType?: FloorPlanMasterCreateNestedOneWithoutPropertiesInput
    agent?: AgentCreateNestedOneWithoutPropertiesInput
    user: UserCreateNestedOneWithoutPropertiesInput
    publication?: PropertyPublicationCreateNestedOneWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryCreateNestedManyWithoutPropertyInput
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPriceHistoriesInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
    publication?: PropertyPublicationUncheckedCreateNestedOneWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutPropertyInput
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPriceHistoriesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPriceHistoriesInput, PropertyUncheckedCreateWithoutPriceHistoriesInput>
  }

  export type UserCreateWithoutPriceHistoryChangesInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutAuthorInput
    answers?: AnswerCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentCreateNestedManyWithoutUserInput
    mails?: MailCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    statusHistoryChanges?: PropertyStatusHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateWithoutPriceHistoryChangesInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutAuthorInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentUncheckedCreateNestedManyWithoutUserInput
    mails?: MailUncheckedCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserCreateOrConnectWithoutPriceHistoryChangesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPriceHistoryChangesInput, UserUncheckedCreateWithoutPriceHistoryChangesInput>
  }

  export type PropertyUpsertWithoutPriceHistoriesInput = {
    update: XOR<PropertyUpdateWithoutPriceHistoriesInput, PropertyUncheckedUpdateWithoutPriceHistoriesInput>
    create: XOR<PropertyCreateWithoutPriceHistoriesInput, PropertyUncheckedCreateWithoutPriceHistoriesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPriceHistoriesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPriceHistoriesInput, PropertyUncheckedUpdateWithoutPriceHistoriesInput>
  }

  export type PropertyUpdateWithoutPriceHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyType?: PropertyTypeMasterUpdateOneWithoutPropertiesNestedInput
    propertyCategory?: PropertyCategoryMasterUpdateOneWithoutPropertiesNestedInput
    area?: AreaMasterUpdateOneWithoutPropertiesNestedInput
    layoutType?: FloorPlanMasterUpdateOneWithoutPropertiesNestedInput
    agent?: AgentUpdateOneWithoutPropertiesNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    publication?: PropertyPublicationUpdateOneWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPriceHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    publication?: PropertyPublicationUncheckedUpdateOneWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type UserUpsertWithoutPriceHistoryChangesInput = {
    update: XOR<UserUpdateWithoutPriceHistoryChangesInput, UserUncheckedUpdateWithoutPriceHistoryChangesInput>
    create: XOR<UserCreateWithoutPriceHistoryChangesInput, UserUncheckedCreateWithoutPriceHistoryChangesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPriceHistoryChangesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPriceHistoryChangesInput, UserUncheckedUpdateWithoutPriceHistoryChangesInput>
  }

  export type UserUpdateWithoutPriceHistoryChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUpdateManyWithoutUserNestedInput
    mails?: MailUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPriceHistoryChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUncheckedUpdateManyWithoutUserNestedInput
    mails?: MailUncheckedUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type PropertyCreateWithoutStatusHistoriesInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutPropertiesInput
    propertyCategory?: PropertyCategoryMasterCreateNestedOneWithoutPropertiesInput
    area?: AreaMasterCreateNestedOneWithoutPropertiesInput
    layoutType?: FloorPlanMasterCreateNestedOneWithoutPropertiesInput
    agent?: AgentCreateNestedOneWithoutPropertiesInput
    user: UserCreateNestedOneWithoutPropertiesInput
    publication?: PropertyPublicationCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryCreateNestedManyWithoutPropertyInput
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutStatusHistoriesInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
    publication?: PropertyPublicationUncheckedCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutPropertyInput
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutStatusHistoriesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutStatusHistoriesInput, PropertyUncheckedCreateWithoutStatusHistoriesInput>
  }

  export type UserCreateWithoutStatusHistoryChangesInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutAuthorInput
    answers?: AnswerCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentCreateNestedManyWithoutUserInput
    mails?: MailCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateWithoutStatusHistoryChangesInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutAuthorInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentUncheckedCreateNestedManyWithoutUserInput
    mails?: MailUncheckedCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserCreateOrConnectWithoutStatusHistoryChangesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStatusHistoryChangesInput, UserUncheckedCreateWithoutStatusHistoryChangesInput>
  }

  export type PropertyUpsertWithoutStatusHistoriesInput = {
    update: XOR<PropertyUpdateWithoutStatusHistoriesInput, PropertyUncheckedUpdateWithoutStatusHistoriesInput>
    create: XOR<PropertyCreateWithoutStatusHistoriesInput, PropertyUncheckedCreateWithoutStatusHistoriesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutStatusHistoriesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutStatusHistoriesInput, PropertyUncheckedUpdateWithoutStatusHistoriesInput>
  }

  export type PropertyUpdateWithoutStatusHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyType?: PropertyTypeMasterUpdateOneWithoutPropertiesNestedInput
    propertyCategory?: PropertyCategoryMasterUpdateOneWithoutPropertiesNestedInput
    area?: AreaMasterUpdateOneWithoutPropertiesNestedInput
    layoutType?: FloorPlanMasterUpdateOneWithoutPropertiesNestedInput
    agent?: AgentUpdateOneWithoutPropertiesNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    publication?: PropertyPublicationUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutStatusHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    publication?: PropertyPublicationUncheckedUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type UserUpsertWithoutStatusHistoryChangesInput = {
    update: XOR<UserUpdateWithoutStatusHistoryChangesInput, UserUncheckedUpdateWithoutStatusHistoryChangesInput>
    create: XOR<UserCreateWithoutStatusHistoryChangesInput, UserUncheckedCreateWithoutStatusHistoryChangesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStatusHistoryChangesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStatusHistoryChangesInput, UserUncheckedUpdateWithoutStatusHistoryChangesInput>
  }

  export type UserUpdateWithoutStatusHistoryChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUpdateManyWithoutUserNestedInput
    mails?: MailUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateWithoutStatusHistoryChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUncheckedUpdateManyWithoutUserNestedInput
    mails?: MailUncheckedUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type PropertyCreateWithoutImagesInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutPropertiesInput
    propertyCategory?: PropertyCategoryMasterCreateNestedOneWithoutPropertiesInput
    area?: AreaMasterCreateNestedOneWithoutPropertiesInput
    layoutType?: FloorPlanMasterCreateNestedOneWithoutPropertiesInput
    agent?: AgentCreateNestedOneWithoutPropertiesInput
    user: UserCreateNestedOneWithoutPropertiesInput
    publication?: PropertyPublicationCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutImagesInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
    publication?: PropertyPublicationUncheckedCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutImagesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutImagesInput, PropertyUncheckedCreateWithoutImagesInput>
  }

  export type FileBoxCreateWithoutPropertyImagesInput = {
    id?: string
    bucketName: string
    storagePath: string
    fileName: string
    originalName: string
    publicUrl?: string | null
    mimeType: string
    fileSize: bigint | number
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutFileBoxesInput
  }

  export type FileBoxUncheckedCreateWithoutPropertyImagesInput = {
    id?: string
    bucketName: string
    storagePath: string
    fileName: string
    originalName: string
    publicUrl?: string | null
    mimeType: string
    fileSize: bigint | number
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type FileBoxCreateOrConnectWithoutPropertyImagesInput = {
    where: FileBoxWhereUniqueInput
    create: XOR<FileBoxCreateWithoutPropertyImagesInput, FileBoxUncheckedCreateWithoutPropertyImagesInput>
  }

  export type PropertyUpsertWithoutImagesInput = {
    update: XOR<PropertyUpdateWithoutImagesInput, PropertyUncheckedUpdateWithoutImagesInput>
    create: XOR<PropertyCreateWithoutImagesInput, PropertyUncheckedCreateWithoutImagesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutImagesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutImagesInput, PropertyUncheckedUpdateWithoutImagesInput>
  }

  export type PropertyUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyType?: PropertyTypeMasterUpdateOneWithoutPropertiesNestedInput
    propertyCategory?: PropertyCategoryMasterUpdateOneWithoutPropertiesNestedInput
    area?: AreaMasterUpdateOneWithoutPropertiesNestedInput
    layoutType?: FloorPlanMasterUpdateOneWithoutPropertiesNestedInput
    agent?: AgentUpdateOneWithoutPropertiesNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    publication?: PropertyPublicationUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    publication?: PropertyPublicationUncheckedUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type FileBoxUpsertWithoutPropertyImagesInput = {
    update: XOR<FileBoxUpdateWithoutPropertyImagesInput, FileBoxUncheckedUpdateWithoutPropertyImagesInput>
    create: XOR<FileBoxCreateWithoutPropertyImagesInput, FileBoxUncheckedCreateWithoutPropertyImagesInput>
    where?: FileBoxWhereInput
  }

  export type FileBoxUpdateToOneWithWhereWithoutPropertyImagesInput = {
    where?: FileBoxWhereInput
    data: XOR<FileBoxUpdateWithoutPropertyImagesInput, FileBoxUncheckedUpdateWithoutPropertyImagesInput>
  }

  export type FileBoxUpdateWithoutPropertyImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutFileBoxesNestedInput
  }

  export type FileBoxUncheckedUpdateWithoutPropertyImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyCreateWithoutFeaturesInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutPropertiesInput
    propertyCategory?: PropertyCategoryMasterCreateNestedOneWithoutPropertiesInput
    area?: AreaMasterCreateNestedOneWithoutPropertiesInput
    layoutType?: FloorPlanMasterCreateNestedOneWithoutPropertiesInput
    agent?: AgentCreateNestedOneWithoutPropertiesInput
    user: UserCreateNestedOneWithoutPropertiesInput
    publication?: PropertyPublicationCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryCreateNestedManyWithoutPropertyInput
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutFeaturesInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
    publication?: PropertyPublicationUncheckedCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutPropertyInput
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutFeaturesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutFeaturesInput, PropertyUncheckedCreateWithoutFeaturesInput>
  }

  export type FeatureMasterCreateWithoutPropertiesInput = {
    id?: string
    code: string
    name: string
    category: $Enums.FeatureCategory
    icon?: string | null
    displayOrder?: number
    isActive?: boolean
  }

  export type FeatureMasterUncheckedCreateWithoutPropertiesInput = {
    id?: string
    code: string
    name: string
    category: $Enums.FeatureCategory
    icon?: string | null
    displayOrder?: number
    isActive?: boolean
  }

  export type FeatureMasterCreateOrConnectWithoutPropertiesInput = {
    where: FeatureMasterWhereUniqueInput
    create: XOR<FeatureMasterCreateWithoutPropertiesInput, FeatureMasterUncheckedCreateWithoutPropertiesInput>
  }

  export type PropertyUpsertWithoutFeaturesInput = {
    update: XOR<PropertyUpdateWithoutFeaturesInput, PropertyUncheckedUpdateWithoutFeaturesInput>
    create: XOR<PropertyCreateWithoutFeaturesInput, PropertyUncheckedCreateWithoutFeaturesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutFeaturesInput, PropertyUncheckedUpdateWithoutFeaturesInput>
  }

  export type PropertyUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyType?: PropertyTypeMasterUpdateOneWithoutPropertiesNestedInput
    propertyCategory?: PropertyCategoryMasterUpdateOneWithoutPropertiesNestedInput
    area?: AreaMasterUpdateOneWithoutPropertiesNestedInput
    layoutType?: FloorPlanMasterUpdateOneWithoutPropertiesNestedInput
    agent?: AgentUpdateOneWithoutPropertiesNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    publication?: PropertyPublicationUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    publication?: PropertyPublicationUncheckedUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type FeatureMasterUpsertWithoutPropertiesInput = {
    update: XOR<FeatureMasterUpdateWithoutPropertiesInput, FeatureMasterUncheckedUpdateWithoutPropertiesInput>
    create: XOR<FeatureMasterCreateWithoutPropertiesInput, FeatureMasterUncheckedCreateWithoutPropertiesInput>
    where?: FeatureMasterWhereInput
  }

  export type FeatureMasterUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: FeatureMasterWhereInput
    data: XOR<FeatureMasterUpdateWithoutPropertiesInput, FeatureMasterUncheckedUpdateWithoutPropertiesInput>
  }

  export type FeatureMasterUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFeatureCategoryFieldUpdateOperationsInput | $Enums.FeatureCategory
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeatureMasterUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFeatureCategoryFieldUpdateOperationsInput | $Enums.FeatureCategory
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertyCreateWithoutStationsInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutPropertiesInput
    propertyCategory?: PropertyCategoryMasterCreateNestedOneWithoutPropertiesInput
    area?: AreaMasterCreateNestedOneWithoutPropertiesInput
    layoutType?: FloorPlanMasterCreateNestedOneWithoutPropertiesInput
    agent?: AgentCreateNestedOneWithoutPropertiesInput
    user: UserCreateNestedOneWithoutPropertiesInput
    publication?: PropertyPublicationCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryCreateNestedManyWithoutPropertyInput
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutStationsInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
    publication?: PropertyPublicationUncheckedCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutPropertyInput
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutStationsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutStationsInput, PropertyUncheckedCreateWithoutStationsInput>
  }

  export type StationCreateWithoutPropertyStationsInput = {
    id?: string
    code: string
    name: string
    nameKana?: string | null
    prefecture?: string | null
    city?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    displayOrder?: number
    isActive?: boolean
    route?: RouteMasterCreateNestedOneWithoutStationsInput
  }

  export type StationUncheckedCreateWithoutPropertyStationsInput = {
    id?: string
    code: string
    name: string
    nameKana?: string | null
    routeId?: string | null
    prefecture?: string | null
    city?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    displayOrder?: number
    isActive?: boolean
  }

  export type StationCreateOrConnectWithoutPropertyStationsInput = {
    where: StationWhereUniqueInput
    create: XOR<StationCreateWithoutPropertyStationsInput, StationUncheckedCreateWithoutPropertyStationsInput>
  }

  export type PropertyUpsertWithoutStationsInput = {
    update: XOR<PropertyUpdateWithoutStationsInput, PropertyUncheckedUpdateWithoutStationsInput>
    create: XOR<PropertyCreateWithoutStationsInput, PropertyUncheckedCreateWithoutStationsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutStationsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutStationsInput, PropertyUncheckedUpdateWithoutStationsInput>
  }

  export type PropertyUpdateWithoutStationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyType?: PropertyTypeMasterUpdateOneWithoutPropertiesNestedInput
    propertyCategory?: PropertyCategoryMasterUpdateOneWithoutPropertiesNestedInput
    area?: AreaMasterUpdateOneWithoutPropertiesNestedInput
    layoutType?: FloorPlanMasterUpdateOneWithoutPropertiesNestedInput
    agent?: AgentUpdateOneWithoutPropertiesNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    publication?: PropertyPublicationUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutStationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    publication?: PropertyPublicationUncheckedUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type StationUpsertWithoutPropertyStationsInput = {
    update: XOR<StationUpdateWithoutPropertyStationsInput, StationUncheckedUpdateWithoutPropertyStationsInput>
    create: XOR<StationCreateWithoutPropertyStationsInput, StationUncheckedCreateWithoutPropertyStationsInput>
    where?: StationWhereInput
  }

  export type StationUpdateToOneWithWhereWithoutPropertyStationsInput = {
    where?: StationWhereInput
    data: XOR<StationUpdateWithoutPropertyStationsInput, StationUncheckedUpdateWithoutPropertyStationsInput>
  }

  export type StationUpdateWithoutPropertyStationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKana?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    route?: RouteMasterUpdateOneWithoutStationsNestedInput
  }

  export type StationUncheckedUpdateWithoutPropertyStationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKana?: NullableStringFieldUpdateOperationsInput | string | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateWithoutFavoritesInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutAuthorInput
    answers?: AnswerCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentCreateNestedManyWithoutUserInput
    mails?: MailCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateWithoutFavoritesInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutAuthorInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentUncheckedCreateNestedManyWithoutUserInput
    mails?: MailUncheckedCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserCreateOrConnectWithoutFavoritesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
  }

  export type PropertyCreateWithoutFavoritesInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutPropertiesInput
    propertyCategory?: PropertyCategoryMasterCreateNestedOneWithoutPropertiesInput
    area?: AreaMasterCreateNestedOneWithoutPropertiesInput
    layoutType?: FloorPlanMasterCreateNestedOneWithoutPropertiesInput
    agent?: AgentCreateNestedOneWithoutPropertiesInput
    user: UserCreateNestedOneWithoutPropertiesInput
    publication?: PropertyPublicationCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryCreateNestedManyWithoutPropertyInput
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutFavoritesInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
    publication?: PropertyPublicationUncheckedCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutPropertyInput
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutFavoritesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutFavoritesInput, PropertyUncheckedCreateWithoutFavoritesInput>
  }

  export type UserUpsertWithoutFavoritesInput = {
    update: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUpdateManyWithoutUserNestedInput
    mails?: MailUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUncheckedUpdateManyWithoutUserNestedInput
    mails?: MailUncheckedUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type PropertyUpsertWithoutFavoritesInput = {
    update: XOR<PropertyUpdateWithoutFavoritesInput, PropertyUncheckedUpdateWithoutFavoritesInput>
    create: XOR<PropertyCreateWithoutFavoritesInput, PropertyUncheckedCreateWithoutFavoritesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutFavoritesInput, PropertyUncheckedUpdateWithoutFavoritesInput>
  }

  export type PropertyUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyType?: PropertyTypeMasterUpdateOneWithoutPropertiesNestedInput
    propertyCategory?: PropertyCategoryMasterUpdateOneWithoutPropertiesNestedInput
    area?: AreaMasterUpdateOneWithoutPropertiesNestedInput
    layoutType?: FloorPlanMasterUpdateOneWithoutPropertiesNestedInput
    agent?: AgentUpdateOneWithoutPropertiesNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    publication?: PropertyPublicationUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    publication?: PropertyPublicationUncheckedUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutPropertyViewsInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutPropertiesInput
    propertyCategory?: PropertyCategoryMasterCreateNestedOneWithoutPropertiesInput
    area?: AreaMasterCreateNestedOneWithoutPropertiesInput
    layoutType?: FloorPlanMasterCreateNestedOneWithoutPropertiesInput
    agent?: AgentCreateNestedOneWithoutPropertiesInput
    user: UserCreateNestedOneWithoutPropertiesInput
    publication?: PropertyPublicationCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryCreateNestedManyWithoutPropertyInput
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPropertyViewsInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
    publication?: PropertyPublicationUncheckedCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutPropertyInput
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPropertyViewsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPropertyViewsInput, PropertyUncheckedCreateWithoutPropertyViewsInput>
  }

  export type UserCreateWithoutPropertyViewsInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutAuthorInput
    answers?: AnswerCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentCreateNestedManyWithoutUserInput
    mails?: MailCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateWithoutPropertyViewsInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutAuthorInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentUncheckedCreateNestedManyWithoutUserInput
    mails?: MailUncheckedCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserCreateOrConnectWithoutPropertyViewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPropertyViewsInput, UserUncheckedCreateWithoutPropertyViewsInput>
  }

  export type PropertyUpsertWithoutPropertyViewsInput = {
    update: XOR<PropertyUpdateWithoutPropertyViewsInput, PropertyUncheckedUpdateWithoutPropertyViewsInput>
    create: XOR<PropertyCreateWithoutPropertyViewsInput, PropertyUncheckedCreateWithoutPropertyViewsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPropertyViewsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPropertyViewsInput, PropertyUncheckedUpdateWithoutPropertyViewsInput>
  }

  export type PropertyUpdateWithoutPropertyViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyType?: PropertyTypeMasterUpdateOneWithoutPropertiesNestedInput
    propertyCategory?: PropertyCategoryMasterUpdateOneWithoutPropertiesNestedInput
    area?: AreaMasterUpdateOneWithoutPropertiesNestedInput
    layoutType?: FloorPlanMasterUpdateOneWithoutPropertiesNestedInput
    agent?: AgentUpdateOneWithoutPropertiesNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    publication?: PropertyPublicationUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPropertyViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    publication?: PropertyPublicationUncheckedUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type UserUpsertWithoutPropertyViewsInput = {
    update: XOR<UserUpdateWithoutPropertyViewsInput, UserUncheckedUpdateWithoutPropertyViewsInput>
    create: XOR<UserCreateWithoutPropertyViewsInput, UserUncheckedCreateWithoutPropertyViewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPropertyViewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPropertyViewsInput, UserUncheckedUpdateWithoutPropertyViewsInput>
  }

  export type UserUpdateWithoutPropertyViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUpdateManyWithoutUserNestedInput
    mails?: MailUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPropertyViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUncheckedUpdateManyWithoutUserNestedInput
    mails?: MailUncheckedUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type PropertyCreateWithoutPropertyViewDailiesInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutPropertiesInput
    propertyCategory?: PropertyCategoryMasterCreateNestedOneWithoutPropertiesInput
    area?: AreaMasterCreateNestedOneWithoutPropertiesInput
    layoutType?: FloorPlanMasterCreateNestedOneWithoutPropertiesInput
    agent?: AgentCreateNestedOneWithoutPropertiesInput
    user: UserCreateNestedOneWithoutPropertiesInput
    publication?: PropertyPublicationCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryCreateNestedManyWithoutPropertyInput
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPropertyViewDailiesInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
    publication?: PropertyPublicationUncheckedCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutPropertyInput
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPropertyViewDailiesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPropertyViewDailiesInput, PropertyUncheckedCreateWithoutPropertyViewDailiesInput>
  }

  export type PropertyUpsertWithoutPropertyViewDailiesInput = {
    update: XOR<PropertyUpdateWithoutPropertyViewDailiesInput, PropertyUncheckedUpdateWithoutPropertyViewDailiesInput>
    create: XOR<PropertyCreateWithoutPropertyViewDailiesInput, PropertyUncheckedCreateWithoutPropertyViewDailiesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPropertyViewDailiesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPropertyViewDailiesInput, PropertyUncheckedUpdateWithoutPropertyViewDailiesInput>
  }

  export type PropertyUpdateWithoutPropertyViewDailiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyType?: PropertyTypeMasterUpdateOneWithoutPropertiesNestedInput
    propertyCategory?: PropertyCategoryMasterUpdateOneWithoutPropertiesNestedInput
    area?: AreaMasterUpdateOneWithoutPropertiesNestedInput
    layoutType?: FloorPlanMasterUpdateOneWithoutPropertiesNestedInput
    agent?: AgentUpdateOneWithoutPropertiesNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    publication?: PropertyPublicationUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPropertyViewDailiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    publication?: PropertyPublicationUncheckedUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type UserCreateWithoutInquiriesInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutAuthorInput
    answers?: AnswerCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentCreateNestedManyWithoutUserInput
    mails?: MailCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateWithoutInquiriesInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutAuthorInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentUncheckedCreateNestedManyWithoutUserInput
    mails?: MailUncheckedCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserCreateOrConnectWithoutInquiriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInquiriesInput, UserUncheckedCreateWithoutInquiriesInput>
  }

  export type AgentCreateWithoutAssignedInquiriesInput = {
    id?: string
    position?: string | null
    department?: string | null
    licenseNumber?: string | null
    licenseExpireDate?: Date | string | null
    goodCount?: number
    responseRate?: Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAgentInput
    branch: BranchCreateNestedOneWithoutAgentsInput
    properties?: PropertyCreateNestedManyWithoutAgentInput
    answers?: AnswerCreateNestedManyWithoutAgentInput
    bulkAssessmentResponses?: BulkAssessmentResponseCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutAssignedInquiriesInput = {
    id?: string
    position?: string | null
    department?: string | null
    licenseNumber?: string | null
    licenseExpireDate?: Date | string | null
    goodCount?: number
    responseRate?: Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: number | null
    userId: string
    branchId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    properties?: PropertyUncheckedCreateNestedManyWithoutAgentInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAgentInput
    bulkAssessmentResponses?: BulkAssessmentResponseUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutAssignedInquiriesInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutAssignedInquiriesInput, AgentUncheckedCreateWithoutAssignedInquiriesInput>
  }

  export type PropertyCreateWithoutInquiriesInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutPropertiesInput
    propertyCategory?: PropertyCategoryMasterCreateNestedOneWithoutPropertiesInput
    area?: AreaMasterCreateNestedOneWithoutPropertiesInput
    layoutType?: FloorPlanMasterCreateNestedOneWithoutPropertiesInput
    agent?: AgentCreateNestedOneWithoutPropertiesInput
    user: UserCreateNestedOneWithoutPropertiesInput
    publication?: PropertyPublicationCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryCreateNestedManyWithoutPropertyInput
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutInquiriesInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
    publication?: PropertyPublicationUncheckedCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutPropertyInput
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationUncheckedCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutInquiriesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutInquiriesInput, PropertyUncheckedCreateWithoutInquiriesInput>
  }

  export type InquiryMessageCreateWithoutInquiryInput = {
    id?: string
    senderId?: string | null
    senderType: $Enums.SenderType
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type InquiryMessageUncheckedCreateWithoutInquiryInput = {
    id?: string
    senderId?: string | null
    senderType: $Enums.SenderType
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type InquiryMessageCreateOrConnectWithoutInquiryInput = {
    where: InquiryMessageWhereUniqueInput
    create: XOR<InquiryMessageCreateWithoutInquiryInput, InquiryMessageUncheckedCreateWithoutInquiryInput>
  }

  export type InquiryMessageCreateManyInquiryInputEnvelope = {
    data: InquiryMessageCreateManyInquiryInput | InquiryMessageCreateManyInquiryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInquiriesInput = {
    update: XOR<UserUpdateWithoutInquiriesInput, UserUncheckedUpdateWithoutInquiriesInput>
    create: XOR<UserCreateWithoutInquiriesInput, UserUncheckedCreateWithoutInquiriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInquiriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInquiriesInput, UserUncheckedUpdateWithoutInquiriesInput>
  }

  export type UserUpdateWithoutInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUpdateManyWithoutUserNestedInput
    mails?: MailUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUncheckedUpdateManyWithoutUserNestedInput
    mails?: MailUncheckedUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type AgentUpsertWithoutAssignedInquiriesInput = {
    update: XOR<AgentUpdateWithoutAssignedInquiriesInput, AgentUncheckedUpdateWithoutAssignedInquiriesInput>
    create: XOR<AgentCreateWithoutAssignedInquiriesInput, AgentUncheckedCreateWithoutAssignedInquiriesInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutAssignedInquiriesInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutAssignedInquiriesInput, AgentUncheckedUpdateWithoutAssignedInquiriesInput>
  }

  export type AgentUpdateWithoutAssignedInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goodCount?: IntFieldUpdateOperationsInput | number
    responseRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    branch?: BranchUpdateOneRequiredWithoutAgentsNestedInput
    properties?: PropertyUpdateManyWithoutAgentNestedInput
    answers?: AnswerUpdateManyWithoutAgentNestedInput
    bulkAssessmentResponses?: BulkAssessmentResponseUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutAssignedInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goodCount?: IntFieldUpdateOperationsInput | number
    responseRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    properties?: PropertyUncheckedUpdateManyWithoutAgentNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAgentNestedInput
    bulkAssessmentResponses?: BulkAssessmentResponseUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type PropertyUpsertWithoutInquiriesInput = {
    update: XOR<PropertyUpdateWithoutInquiriesInput, PropertyUncheckedUpdateWithoutInquiriesInput>
    create: XOR<PropertyCreateWithoutInquiriesInput, PropertyUncheckedCreateWithoutInquiriesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutInquiriesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutInquiriesInput, PropertyUncheckedUpdateWithoutInquiriesInput>
  }

  export type PropertyUpdateWithoutInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyType?: PropertyTypeMasterUpdateOneWithoutPropertiesNestedInput
    propertyCategory?: PropertyCategoryMasterUpdateOneWithoutPropertiesNestedInput
    area?: AreaMasterUpdateOneWithoutPropertiesNestedInput
    layoutType?: FloorPlanMasterUpdateOneWithoutPropertiesNestedInput
    agent?: AgentUpdateOneWithoutPropertiesNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    publication?: PropertyPublicationUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    publication?: PropertyPublicationUncheckedUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUncheckedUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type InquiryMessageUpsertWithWhereUniqueWithoutInquiryInput = {
    where: InquiryMessageWhereUniqueInput
    update: XOR<InquiryMessageUpdateWithoutInquiryInput, InquiryMessageUncheckedUpdateWithoutInquiryInput>
    create: XOR<InquiryMessageCreateWithoutInquiryInput, InquiryMessageUncheckedCreateWithoutInquiryInput>
  }

  export type InquiryMessageUpdateWithWhereUniqueWithoutInquiryInput = {
    where: InquiryMessageWhereUniqueInput
    data: XOR<InquiryMessageUpdateWithoutInquiryInput, InquiryMessageUncheckedUpdateWithoutInquiryInput>
  }

  export type InquiryMessageUpdateManyWithWhereWithoutInquiryInput = {
    where: InquiryMessageScalarWhereInput
    data: XOR<InquiryMessageUpdateManyMutationInput, InquiryMessageUncheckedUpdateManyWithoutInquiryInput>
  }

  export type InquiryMessageScalarWhereInput = {
    AND?: InquiryMessageScalarWhereInput | InquiryMessageScalarWhereInput[]
    OR?: InquiryMessageScalarWhereInput[]
    NOT?: InquiryMessageScalarWhereInput | InquiryMessageScalarWhereInput[]
    id?: UuidFilter<"InquiryMessage"> | string
    inquiryId?: UuidFilter<"InquiryMessage"> | string
    senderId?: UuidNullableFilter<"InquiryMessage"> | string | null
    senderType?: EnumSenderTypeFilter<"InquiryMessage"> | $Enums.SenderType
    message?: StringFilter<"InquiryMessage"> | string
    attachments?: JsonNullableFilter<"InquiryMessage">
    isInternal?: BoolFilter<"InquiryMessage"> | boolean
    createdAt?: DateTimeFilter<"InquiryMessage"> | Date | string
  }

  export type InquiryCreateWithoutMessagesInput = {
    id?: string
    inquiryNumber: string
    targetType: $Enums.TargetType
    name: string
    furigana?: string | null
    email: string
    phone?: string | null
    companyName?: string | null
    inquiryType?: $Enums.InquiryType
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    assignedAt?: Date | string | null
    responseCount?: number
    lastRespondedAt?: Date | string | null
    closedAt?: Date | string | null
    closedReason?: string | null
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutInquiriesInput
    assignedAgent?: AgentCreateNestedOneWithoutAssignedInquiriesInput
    property?: PropertyCreateNestedOneWithoutInquiriesInput
  }

  export type InquiryUncheckedCreateWithoutMessagesInput = {
    id?: string
    inquiryNumber: string
    targetType: $Enums.TargetType
    targetId?: string | null
    name: string
    furigana?: string | null
    email: string
    phone?: string | null
    companyName?: string | null
    inquiryType?: $Enums.InquiryType
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    userId?: string | null
    assignedAgentId?: string | null
    assignedAt?: Date | string | null
    responseCount?: number
    lastRespondedAt?: Date | string | null
    closedAt?: Date | string | null
    closedReason?: string | null
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InquiryCreateOrConnectWithoutMessagesInput = {
    where: InquiryWhereUniqueInput
    create: XOR<InquiryCreateWithoutMessagesInput, InquiryUncheckedCreateWithoutMessagesInput>
  }

  export type InquiryUpsertWithoutMessagesInput = {
    update: XOR<InquiryUpdateWithoutMessagesInput, InquiryUncheckedUpdateWithoutMessagesInput>
    create: XOR<InquiryCreateWithoutMessagesInput, InquiryUncheckedCreateWithoutMessagesInput>
    where?: InquiryWhereInput
  }

  export type InquiryUpdateToOneWithWhereWithoutMessagesInput = {
    where?: InquiryWhereInput
    data: XOR<InquiryUpdateWithoutMessagesInput, InquiryUncheckedUpdateWithoutMessagesInput>
  }

  export type InquiryUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryNumber?: StringFieldUpdateOperationsInput | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    name?: StringFieldUpdateOperationsInput | string
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    inquiryType?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCount?: IntFieldUpdateOperationsInput | number
    lastRespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutInquiriesNestedInput
    assignedAgent?: AgentUpdateOneWithoutAssignedInquiriesNestedInput
    property?: PropertyUpdateOneWithoutInquiriesNestedInput
  }

  export type InquiryUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryNumber?: StringFieldUpdateOperationsInput | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    inquiryType?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCount?: IntFieldUpdateOperationsInput | number
    lastRespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutBulkAssessmentsInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutAuthorInput
    answers?: AnswerCreateNestedManyWithoutAuthorInput
    mails?: MailCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateWithoutBulkAssessmentsInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutAuthorInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAuthorInput
    mails?: MailUncheckedCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserCreateOrConnectWithoutBulkAssessmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBulkAssessmentsInput, UserUncheckedCreateWithoutBulkAssessmentsInput>
  }

  export type PropertyTypeMasterCreateWithoutBulkAssessmentsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    displayOrder?: number
    isActive?: boolean
    properties?: PropertyCreateNestedManyWithoutPropertyTypeInput
  }

  export type PropertyTypeMasterUncheckedCreateWithoutBulkAssessmentsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    displayOrder?: number
    isActive?: boolean
    properties?: PropertyUncheckedCreateNestedManyWithoutPropertyTypeInput
  }

  export type PropertyTypeMasterCreateOrConnectWithoutBulkAssessmentsInput = {
    where: PropertyTypeMasterWhereUniqueInput
    create: XOR<PropertyTypeMasterCreateWithoutBulkAssessmentsInput, PropertyTypeMasterUncheckedCreateWithoutBulkAssessmentsInput>
  }

  export type BulkAssessmentResponseCreateWithoutAssessmentInput = {
    id?: string
    assessedPrice?: bigint | number | null
    priceRangeMin?: bigint | number | null
    priceRangeMax?: bigint | number | null
    comments?: string | null
    proposalDocument?: string | null
    status?: $Enums.ResponseStatus
    submittedAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    agent: AgentCreateNestedOneWithoutBulkAssessmentResponsesInput
  }

  export type BulkAssessmentResponseUncheckedCreateWithoutAssessmentInput = {
    id?: string
    agentId: string
    assessedPrice?: bigint | number | null
    priceRangeMin?: bigint | number | null
    priceRangeMax?: bigint | number | null
    comments?: string | null
    proposalDocument?: string | null
    status?: $Enums.ResponseStatus
    submittedAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BulkAssessmentResponseCreateOrConnectWithoutAssessmentInput = {
    where: BulkAssessmentResponseWhereUniqueInput
    create: XOR<BulkAssessmentResponseCreateWithoutAssessmentInput, BulkAssessmentResponseUncheckedCreateWithoutAssessmentInput>
  }

  export type BulkAssessmentResponseCreateManyAssessmentInputEnvelope = {
    data: BulkAssessmentResponseCreateManyAssessmentInput | BulkAssessmentResponseCreateManyAssessmentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBulkAssessmentsInput = {
    update: XOR<UserUpdateWithoutBulkAssessmentsInput, UserUncheckedUpdateWithoutBulkAssessmentsInput>
    create: XOR<UserCreateWithoutBulkAssessmentsInput, UserUncheckedCreateWithoutBulkAssessmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBulkAssessmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBulkAssessmentsInput, UserUncheckedUpdateWithoutBulkAssessmentsInput>
  }

  export type UserUpdateWithoutBulkAssessmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUpdateManyWithoutAuthorNestedInput
    mails?: MailUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateWithoutBulkAssessmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAuthorNestedInput
    mails?: MailUncheckedUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type PropertyTypeMasterUpsertWithoutBulkAssessmentsInput = {
    update: XOR<PropertyTypeMasterUpdateWithoutBulkAssessmentsInput, PropertyTypeMasterUncheckedUpdateWithoutBulkAssessmentsInput>
    create: XOR<PropertyTypeMasterCreateWithoutBulkAssessmentsInput, PropertyTypeMasterUncheckedCreateWithoutBulkAssessmentsInput>
    where?: PropertyTypeMasterWhereInput
  }

  export type PropertyTypeMasterUpdateToOneWithWhereWithoutBulkAssessmentsInput = {
    where?: PropertyTypeMasterWhereInput
    data: XOR<PropertyTypeMasterUpdateWithoutBulkAssessmentsInput, PropertyTypeMasterUncheckedUpdateWithoutBulkAssessmentsInput>
  }

  export type PropertyTypeMasterUpdateWithoutBulkAssessmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    properties?: PropertyUpdateManyWithoutPropertyTypeNestedInput
  }

  export type PropertyTypeMasterUncheckedUpdateWithoutBulkAssessmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    properties?: PropertyUncheckedUpdateManyWithoutPropertyTypeNestedInput
  }

  export type BulkAssessmentResponseUpsertWithWhereUniqueWithoutAssessmentInput = {
    where: BulkAssessmentResponseWhereUniqueInput
    update: XOR<BulkAssessmentResponseUpdateWithoutAssessmentInput, BulkAssessmentResponseUncheckedUpdateWithoutAssessmentInput>
    create: XOR<BulkAssessmentResponseCreateWithoutAssessmentInput, BulkAssessmentResponseUncheckedCreateWithoutAssessmentInput>
  }

  export type BulkAssessmentResponseUpdateWithWhereUniqueWithoutAssessmentInput = {
    where: BulkAssessmentResponseWhereUniqueInput
    data: XOR<BulkAssessmentResponseUpdateWithoutAssessmentInput, BulkAssessmentResponseUncheckedUpdateWithoutAssessmentInput>
  }

  export type BulkAssessmentResponseUpdateManyWithWhereWithoutAssessmentInput = {
    where: BulkAssessmentResponseScalarWhereInput
    data: XOR<BulkAssessmentResponseUpdateManyMutationInput, BulkAssessmentResponseUncheckedUpdateManyWithoutAssessmentInput>
  }

  export type BulkAssessmentCreateWithoutResponsesInput = {
    id?: string
    assessmentNumber: string
    propertyAddress: string
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    constructionYear?: number | null
    ownerName: string
    email: string
    phone?: string | null
    preferredContactMethod?: string | null
    preferredContactTime?: string | null
    status?: $Enums.AssessmentStatus
    agentCount?: number
    responseCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    completedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutBulkAssessmentsInput
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutBulkAssessmentsInput
  }

  export type BulkAssessmentUncheckedCreateWithoutResponsesInput = {
    id?: string
    assessmentNumber: string
    propertyAddress: string
    propertyTypeId?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    constructionYear?: number | null
    ownerName: string
    email: string
    phone?: string | null
    preferredContactMethod?: string | null
    preferredContactTime?: string | null
    status?: $Enums.AssessmentStatus
    agentCount?: number
    responseCount?: number
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type BulkAssessmentCreateOrConnectWithoutResponsesInput = {
    where: BulkAssessmentWhereUniqueInput
    create: XOR<BulkAssessmentCreateWithoutResponsesInput, BulkAssessmentUncheckedCreateWithoutResponsesInput>
  }

  export type AgentCreateWithoutBulkAssessmentResponsesInput = {
    id?: string
    position?: string | null
    department?: string | null
    licenseNumber?: string | null
    licenseExpireDate?: Date | string | null
    goodCount?: number
    responseRate?: Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAgentInput
    branch: BranchCreateNestedOneWithoutAgentsInput
    properties?: PropertyCreateNestedManyWithoutAgentInput
    assignedInquiries?: InquiryCreateNestedManyWithoutAssignedAgentInput
    answers?: AnswerCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutBulkAssessmentResponsesInput = {
    id?: string
    position?: string | null
    department?: string | null
    licenseNumber?: string | null
    licenseExpireDate?: Date | string | null
    goodCount?: number
    responseRate?: Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: number | null
    userId: string
    branchId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    properties?: PropertyUncheckedCreateNestedManyWithoutAgentInput
    assignedInquiries?: InquiryUncheckedCreateNestedManyWithoutAssignedAgentInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutBulkAssessmentResponsesInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutBulkAssessmentResponsesInput, AgentUncheckedCreateWithoutBulkAssessmentResponsesInput>
  }

  export type BulkAssessmentUpsertWithoutResponsesInput = {
    update: XOR<BulkAssessmentUpdateWithoutResponsesInput, BulkAssessmentUncheckedUpdateWithoutResponsesInput>
    create: XOR<BulkAssessmentCreateWithoutResponsesInput, BulkAssessmentUncheckedCreateWithoutResponsesInput>
    where?: BulkAssessmentWhereInput
  }

  export type BulkAssessmentUpdateToOneWithWhereWithoutResponsesInput = {
    where?: BulkAssessmentWhereInput
    data: XOR<BulkAssessmentUpdateWithoutResponsesInput, BulkAssessmentUncheckedUpdateWithoutResponsesInput>
  }

  export type BulkAssessmentUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentNumber?: StringFieldUpdateOperationsInput | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    constructionYear?: NullableIntFieldUpdateOperationsInput | number | null
    ownerName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    agentCount?: IntFieldUpdateOperationsInput | number
    responseCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutBulkAssessmentsNestedInput
    propertyType?: PropertyTypeMasterUpdateOneWithoutBulkAssessmentsNestedInput
  }

  export type BulkAssessmentUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentNumber?: StringFieldUpdateOperationsInput | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    constructionYear?: NullableIntFieldUpdateOperationsInput | number | null
    ownerName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    agentCount?: IntFieldUpdateOperationsInput | number
    responseCount?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgentUpsertWithoutBulkAssessmentResponsesInput = {
    update: XOR<AgentUpdateWithoutBulkAssessmentResponsesInput, AgentUncheckedUpdateWithoutBulkAssessmentResponsesInput>
    create: XOR<AgentCreateWithoutBulkAssessmentResponsesInput, AgentUncheckedCreateWithoutBulkAssessmentResponsesInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutBulkAssessmentResponsesInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutBulkAssessmentResponsesInput, AgentUncheckedUpdateWithoutBulkAssessmentResponsesInput>
  }

  export type AgentUpdateWithoutBulkAssessmentResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goodCount?: IntFieldUpdateOperationsInput | number
    responseRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    branch?: BranchUpdateOneRequiredWithoutAgentsNestedInput
    properties?: PropertyUpdateManyWithoutAgentNestedInput
    assignedInquiries?: InquiryUpdateManyWithoutAssignedAgentNestedInput
    answers?: AnswerUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutBulkAssessmentResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goodCount?: IntFieldUpdateOperationsInput | number
    responseRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    properties?: PropertyUncheckedUpdateManyWithoutAgentNestedInput
    assignedInquiries?: InquiryUncheckedUpdateManyWithoutAssignedAgentNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type UserCreateWithoutQuestionsInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentCreateNestedManyWithoutUserInput
    mails?: MailCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateWithoutQuestionsInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentUncheckedCreateNestedManyWithoutUserInput
    mails?: MailUncheckedCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserCreateOrConnectWithoutQuestionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuestionsInput, UserUncheckedCreateWithoutQuestionsInput>
  }

  export type QuestionCategoryCreateWithoutQuestionsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    displayOrder?: number
    isActive?: boolean
  }

  export type QuestionCategoryUncheckedCreateWithoutQuestionsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    displayOrder?: number
    isActive?: boolean
  }

  export type QuestionCategoryCreateOrConnectWithoutQuestionsInput = {
    where: QuestionCategoryWhereUniqueInput
    create: XOR<QuestionCategoryCreateWithoutQuestionsInput, QuestionCategoryUncheckedCreateWithoutQuestionsInput>
  }

  export type AnswerCreateWithoutQuestionInput = {
    id?: string
    content: string
    goodCount?: number
    isBestAnswer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    author?: UserCreateNestedOneWithoutAnswersInput
    agent?: AgentCreateNestedOneWithoutAnswersInput
  }

  export type AnswerUncheckedCreateWithoutQuestionInput = {
    id?: string
    content: string
    goodCount?: number
    isBestAnswer?: boolean
    authorId?: string | null
    agentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AnswerCreateOrConnectWithoutQuestionInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput>
  }

  export type AnswerCreateManyQuestionInputEnvelope = {
    data: AnswerCreateManyQuestionInput | AnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutQuestionsInput = {
    update: XOR<UserUpdateWithoutQuestionsInput, UserUncheckedUpdateWithoutQuestionsInput>
    create: XOR<UserCreateWithoutQuestionsInput, UserUncheckedCreateWithoutQuestionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuestionsInput, UserUncheckedUpdateWithoutQuestionsInput>
  }

  export type UserUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutUserNestedInput
    answers?: AnswerUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUpdateManyWithoutUserNestedInput
    mails?: MailUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUncheckedUpdateManyWithoutUserNestedInput
    mails?: MailUncheckedUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type QuestionCategoryUpsertWithoutQuestionsInput = {
    update: XOR<QuestionCategoryUpdateWithoutQuestionsInput, QuestionCategoryUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuestionCategoryCreateWithoutQuestionsInput, QuestionCategoryUncheckedCreateWithoutQuestionsInput>
    where?: QuestionCategoryWhereInput
  }

  export type QuestionCategoryUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: QuestionCategoryWhereInput
    data: XOR<QuestionCategoryUpdateWithoutQuestionsInput, QuestionCategoryUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuestionCategoryUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuestionCategoryUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: AnswerWhereUniqueInput
    update: XOR<AnswerUpdateWithoutQuestionInput, AnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput>
  }

  export type AnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: AnswerWhereUniqueInput
    data: XOR<AnswerUpdateWithoutQuestionInput, AnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type AnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: AnswerScalarWhereInput
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type QuestionCreateWithoutAnswersInput = {
    id?: string
    questionNumber: string
    title: string
    content: string
    tags?: QuestionCreatetagsInput | string[]
    viewCount?: number
    answerCount?: number
    status?: $Enums.QuestionStatus
    bestAnswerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    author: UserCreateNestedOneWithoutQuestionsInput
    category?: QuestionCategoryCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionUncheckedCreateWithoutAnswersInput = {
    id?: string
    questionNumber: string
    title: string
    content: string
    categoryId?: string | null
    tags?: QuestionCreatetagsInput | string[]
    viewCount?: number
    answerCount?: number
    status?: $Enums.QuestionStatus
    authorId: string
    bestAnswerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type QuestionCreateOrConnectWithoutAnswersInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
  }

  export type UserCreateWithoutAnswersInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentCreateNestedManyWithoutUserInput
    mails?: MailCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateWithoutAnswersInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentUncheckedCreateNestedManyWithoutUserInput
    mails?: MailUncheckedCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserCreateOrConnectWithoutAnswersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnswersInput, UserUncheckedCreateWithoutAnswersInput>
  }

  export type AgentCreateWithoutAnswersInput = {
    id?: string
    position?: string | null
    department?: string | null
    licenseNumber?: string | null
    licenseExpireDate?: Date | string | null
    goodCount?: number
    responseRate?: Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAgentInput
    branch: BranchCreateNestedOneWithoutAgentsInput
    properties?: PropertyCreateNestedManyWithoutAgentInput
    assignedInquiries?: InquiryCreateNestedManyWithoutAssignedAgentInput
    bulkAssessmentResponses?: BulkAssessmentResponseCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutAnswersInput = {
    id?: string
    position?: string | null
    department?: string | null
    licenseNumber?: string | null
    licenseExpireDate?: Date | string | null
    goodCount?: number
    responseRate?: Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: number | null
    userId: string
    branchId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    properties?: PropertyUncheckedCreateNestedManyWithoutAgentInput
    assignedInquiries?: InquiryUncheckedCreateNestedManyWithoutAssignedAgentInput
    bulkAssessmentResponses?: BulkAssessmentResponseUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutAnswersInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutAnswersInput, AgentUncheckedCreateWithoutAnswersInput>
  }

  export type QuestionUpsertWithoutAnswersInput = {
    update: XOR<QuestionUpdateWithoutAnswersInput, QuestionUncheckedUpdateWithoutAnswersInput>
    create: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutAnswersInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutAnswersInput, QuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type QuestionUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tags?: QuestionUpdatetagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    answerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    bestAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: UserUpdateOneRequiredWithoutQuestionsNestedInput
    category?: QuestionCategoryUpdateOneWithoutQuestionsNestedInput
  }

  export type QuestionUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: QuestionUpdatetagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    answerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    authorId?: StringFieldUpdateOperationsInput | string
    bestAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutAnswersInput = {
    update: XOR<UserUpdateWithoutAnswersInput, UserUncheckedUpdateWithoutAnswersInput>
    create: XOR<UserCreateWithoutAnswersInput, UserUncheckedCreateWithoutAnswersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnswersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnswersInput, UserUncheckedUpdateWithoutAnswersInput>
  }

  export type UserUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUpdateManyWithoutUserNestedInput
    mails?: MailUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUncheckedUpdateManyWithoutUserNestedInput
    mails?: MailUncheckedUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type AgentUpsertWithoutAnswersInput = {
    update: XOR<AgentUpdateWithoutAnswersInput, AgentUncheckedUpdateWithoutAnswersInput>
    create: XOR<AgentCreateWithoutAnswersInput, AgentUncheckedCreateWithoutAnswersInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutAnswersInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutAnswersInput, AgentUncheckedUpdateWithoutAnswersInput>
  }

  export type AgentUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goodCount?: IntFieldUpdateOperationsInput | number
    responseRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    branch?: BranchUpdateOneRequiredWithoutAgentsNestedInput
    properties?: PropertyUpdateManyWithoutAgentNestedInput
    assignedInquiries?: InquiryUpdateManyWithoutAssignedAgentNestedInput
    bulkAssessmentResponses?: BulkAssessmentResponseUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goodCount?: IntFieldUpdateOperationsInput | number
    responseRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    properties?: PropertyUncheckedUpdateManyWithoutAgentNestedInput
    assignedInquiries?: InquiryUncheckedUpdateManyWithoutAssignedAgentNestedInput
    bulkAssessmentResponses?: BulkAssessmentResponseUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type PropertyFeatureCreateWithoutFeatureInput = {
    id?: string
    property: PropertyCreateNestedOneWithoutFeaturesInput
  }

  export type PropertyFeatureUncheckedCreateWithoutFeatureInput = {
    id?: string
    propertyId: string
  }

  export type PropertyFeatureCreateOrConnectWithoutFeatureInput = {
    where: PropertyFeatureWhereUniqueInput
    create: XOR<PropertyFeatureCreateWithoutFeatureInput, PropertyFeatureUncheckedCreateWithoutFeatureInput>
  }

  export type PropertyFeatureCreateManyFeatureInputEnvelope = {
    data: PropertyFeatureCreateManyFeatureInput | PropertyFeatureCreateManyFeatureInput[]
    skipDuplicates?: boolean
  }

  export type PropertyFeatureUpsertWithWhereUniqueWithoutFeatureInput = {
    where: PropertyFeatureWhereUniqueInput
    update: XOR<PropertyFeatureUpdateWithoutFeatureInput, PropertyFeatureUncheckedUpdateWithoutFeatureInput>
    create: XOR<PropertyFeatureCreateWithoutFeatureInput, PropertyFeatureUncheckedCreateWithoutFeatureInput>
  }

  export type PropertyFeatureUpdateWithWhereUniqueWithoutFeatureInput = {
    where: PropertyFeatureWhereUniqueInput
    data: XOR<PropertyFeatureUpdateWithoutFeatureInput, PropertyFeatureUncheckedUpdateWithoutFeatureInput>
  }

  export type PropertyFeatureUpdateManyWithWhereWithoutFeatureInput = {
    where: PropertyFeatureScalarWhereInput
    data: XOR<PropertyFeatureUpdateManyMutationInput, PropertyFeatureUncheckedUpdateManyWithoutFeatureInput>
  }

  export type AreaMasterCreateWithoutRegionInput = {
    id?: string
    prefectureCode: string
    prefecture: string
    cityCode?: string | null
    city: string
    displayOrder?: number
    isActive?: boolean
    properties?: PropertyCreateNestedManyWithoutAreaInput
  }

  export type AreaMasterUncheckedCreateWithoutRegionInput = {
    id?: string
    prefectureCode: string
    prefecture: string
    cityCode?: string | null
    city: string
    displayOrder?: number
    isActive?: boolean
    properties?: PropertyUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaMasterCreateOrConnectWithoutRegionInput = {
    where: AreaMasterWhereUniqueInput
    create: XOR<AreaMasterCreateWithoutRegionInput, AreaMasterUncheckedCreateWithoutRegionInput>
  }

  export type AreaMasterCreateManyRegionInputEnvelope = {
    data: AreaMasterCreateManyRegionInput | AreaMasterCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type AreaMasterUpsertWithWhereUniqueWithoutRegionInput = {
    where: AreaMasterWhereUniqueInput
    update: XOR<AreaMasterUpdateWithoutRegionInput, AreaMasterUncheckedUpdateWithoutRegionInput>
    create: XOR<AreaMasterCreateWithoutRegionInput, AreaMasterUncheckedCreateWithoutRegionInput>
  }

  export type AreaMasterUpdateWithWhereUniqueWithoutRegionInput = {
    where: AreaMasterWhereUniqueInput
    data: XOR<AreaMasterUpdateWithoutRegionInput, AreaMasterUncheckedUpdateWithoutRegionInput>
  }

  export type AreaMasterUpdateManyWithWhereWithoutRegionInput = {
    where: AreaMasterScalarWhereInput
    data: XOR<AreaMasterUpdateManyMutationInput, AreaMasterUncheckedUpdateManyWithoutRegionInput>
  }

  export type AreaMasterScalarWhereInput = {
    AND?: AreaMasterScalarWhereInput | AreaMasterScalarWhereInput[]
    OR?: AreaMasterScalarWhereInput[]
    NOT?: AreaMasterScalarWhereInput | AreaMasterScalarWhereInput[]
    id?: UuidFilter<"AreaMaster"> | string
    regionId?: UuidNullableFilter<"AreaMaster"> | string | null
    prefectureCode?: StringFilter<"AreaMaster"> | string
    prefecture?: StringFilter<"AreaMaster"> | string
    cityCode?: StringNullableFilter<"AreaMaster"> | string | null
    city?: StringFilter<"AreaMaster"> | string
    displayOrder?: IntFilter<"AreaMaster"> | number
    isActive?: BoolFilter<"AreaMaster"> | boolean
  }

  export type RegionMasterCreateWithoutAreasInput = {
    id?: string
    code: string
    name: string
    displayOrder?: number
    isActive?: boolean
  }

  export type RegionMasterUncheckedCreateWithoutAreasInput = {
    id?: string
    code: string
    name: string
    displayOrder?: number
    isActive?: boolean
  }

  export type RegionMasterCreateOrConnectWithoutAreasInput = {
    where: RegionMasterWhereUniqueInput
    create: XOR<RegionMasterCreateWithoutAreasInput, RegionMasterUncheckedCreateWithoutAreasInput>
  }

  export type PropertyCreateWithoutAreaInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutPropertiesInput
    propertyCategory?: PropertyCategoryMasterCreateNestedOneWithoutPropertiesInput
    layoutType?: FloorPlanMasterCreateNestedOneWithoutPropertiesInput
    agent?: AgentCreateNestedOneWithoutPropertiesInput
    user: UserCreateNestedOneWithoutPropertiesInput
    publication?: PropertyPublicationCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryCreateNestedManyWithoutPropertyInput
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutAreaInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
    publication?: PropertyPublicationUncheckedCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutPropertyInput
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutAreaInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutAreaInput, PropertyUncheckedCreateWithoutAreaInput>
  }

  export type PropertyCreateManyAreaInputEnvelope = {
    data: PropertyCreateManyAreaInput | PropertyCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type RegionMasterUpsertWithoutAreasInput = {
    update: XOR<RegionMasterUpdateWithoutAreasInput, RegionMasterUncheckedUpdateWithoutAreasInput>
    create: XOR<RegionMasterCreateWithoutAreasInput, RegionMasterUncheckedCreateWithoutAreasInput>
    where?: RegionMasterWhereInput
  }

  export type RegionMasterUpdateToOneWithWhereWithoutAreasInput = {
    where?: RegionMasterWhereInput
    data: XOR<RegionMasterUpdateWithoutAreasInput, RegionMasterUncheckedUpdateWithoutAreasInput>
  }

  export type RegionMasterUpdateWithoutAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RegionMasterUncheckedUpdateWithoutAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertyUpsertWithWhereUniqueWithoutAreaInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutAreaInput, PropertyUncheckedUpdateWithoutAreaInput>
    create: XOR<PropertyCreateWithoutAreaInput, PropertyUncheckedCreateWithoutAreaInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutAreaInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutAreaInput, PropertyUncheckedUpdateWithoutAreaInput>
  }

  export type PropertyUpdateManyWithWhereWithoutAreaInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutAreaInput>
  }

  export type PropertyCreateWithoutPropertyTypeInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyCategory?: PropertyCategoryMasterCreateNestedOneWithoutPropertiesInput
    area?: AreaMasterCreateNestedOneWithoutPropertiesInput
    layoutType?: FloorPlanMasterCreateNestedOneWithoutPropertiesInput
    agent?: AgentCreateNestedOneWithoutPropertiesInput
    user: UserCreateNestedOneWithoutPropertiesInput
    publication?: PropertyPublicationCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryCreateNestedManyWithoutPropertyInput
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPropertyTypeInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
    publication?: PropertyPublicationUncheckedCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutPropertyInput
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPropertyTypeInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPropertyTypeInput, PropertyUncheckedCreateWithoutPropertyTypeInput>
  }

  export type PropertyCreateManyPropertyTypeInputEnvelope = {
    data: PropertyCreateManyPropertyTypeInput | PropertyCreateManyPropertyTypeInput[]
    skipDuplicates?: boolean
  }

  export type BulkAssessmentCreateWithoutPropertyTypeInput = {
    id?: string
    assessmentNumber: string
    propertyAddress: string
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    constructionYear?: number | null
    ownerName: string
    email: string
    phone?: string | null
    preferredContactMethod?: string | null
    preferredContactTime?: string | null
    status?: $Enums.AssessmentStatus
    agentCount?: number
    responseCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    completedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutBulkAssessmentsInput
    responses?: BulkAssessmentResponseCreateNestedManyWithoutAssessmentInput
  }

  export type BulkAssessmentUncheckedCreateWithoutPropertyTypeInput = {
    id?: string
    assessmentNumber: string
    propertyAddress: string
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    constructionYear?: number | null
    ownerName: string
    email: string
    phone?: string | null
    preferredContactMethod?: string | null
    preferredContactTime?: string | null
    status?: $Enums.AssessmentStatus
    agentCount?: number
    responseCount?: number
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    completedAt?: Date | string | null
    responses?: BulkAssessmentResponseUncheckedCreateNestedManyWithoutAssessmentInput
  }

  export type BulkAssessmentCreateOrConnectWithoutPropertyTypeInput = {
    where: BulkAssessmentWhereUniqueInput
    create: XOR<BulkAssessmentCreateWithoutPropertyTypeInput, BulkAssessmentUncheckedCreateWithoutPropertyTypeInput>
  }

  export type BulkAssessmentCreateManyPropertyTypeInputEnvelope = {
    data: BulkAssessmentCreateManyPropertyTypeInput | BulkAssessmentCreateManyPropertyTypeInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithWhereUniqueWithoutPropertyTypeInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutPropertyTypeInput, PropertyUncheckedUpdateWithoutPropertyTypeInput>
    create: XOR<PropertyCreateWithoutPropertyTypeInput, PropertyUncheckedCreateWithoutPropertyTypeInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutPropertyTypeInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutPropertyTypeInput, PropertyUncheckedUpdateWithoutPropertyTypeInput>
  }

  export type PropertyUpdateManyWithWhereWithoutPropertyTypeInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutPropertyTypeInput>
  }

  export type BulkAssessmentUpsertWithWhereUniqueWithoutPropertyTypeInput = {
    where: BulkAssessmentWhereUniqueInput
    update: XOR<BulkAssessmentUpdateWithoutPropertyTypeInput, BulkAssessmentUncheckedUpdateWithoutPropertyTypeInput>
    create: XOR<BulkAssessmentCreateWithoutPropertyTypeInput, BulkAssessmentUncheckedCreateWithoutPropertyTypeInput>
  }

  export type BulkAssessmentUpdateWithWhereUniqueWithoutPropertyTypeInput = {
    where: BulkAssessmentWhereUniqueInput
    data: XOR<BulkAssessmentUpdateWithoutPropertyTypeInput, BulkAssessmentUncheckedUpdateWithoutPropertyTypeInput>
  }

  export type BulkAssessmentUpdateManyWithWhereWithoutPropertyTypeInput = {
    where: BulkAssessmentScalarWhereInput
    data: XOR<BulkAssessmentUpdateManyMutationInput, BulkAssessmentUncheckedUpdateManyWithoutPropertyTypeInput>
  }

  export type PropertyCreateWithoutPropertyCategoryInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutPropertiesInput
    area?: AreaMasterCreateNestedOneWithoutPropertiesInput
    layoutType?: FloorPlanMasterCreateNestedOneWithoutPropertiesInput
    agent?: AgentCreateNestedOneWithoutPropertiesInput
    user: UserCreateNestedOneWithoutPropertiesInput
    publication?: PropertyPublicationCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryCreateNestedManyWithoutPropertyInput
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPropertyCategoryInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
    publication?: PropertyPublicationUncheckedCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutPropertyInput
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPropertyCategoryInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPropertyCategoryInput, PropertyUncheckedCreateWithoutPropertyCategoryInput>
  }

  export type PropertyCreateManyPropertyCategoryInputEnvelope = {
    data: PropertyCreateManyPropertyCategoryInput | PropertyCreateManyPropertyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithWhereUniqueWithoutPropertyCategoryInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutPropertyCategoryInput, PropertyUncheckedUpdateWithoutPropertyCategoryInput>
    create: XOR<PropertyCreateWithoutPropertyCategoryInput, PropertyUncheckedCreateWithoutPropertyCategoryInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutPropertyCategoryInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutPropertyCategoryInput, PropertyUncheckedUpdateWithoutPropertyCategoryInput>
  }

  export type PropertyUpdateManyWithWhereWithoutPropertyCategoryInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutPropertyCategoryInput>
  }

  export type PropertyCreateWithoutLayoutTypeInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    propertyType?: PropertyTypeMasterCreateNestedOneWithoutPropertiesInput
    propertyCategory?: PropertyCategoryMasterCreateNestedOneWithoutPropertiesInput
    area?: AreaMasterCreateNestedOneWithoutPropertiesInput
    agent?: AgentCreateNestedOneWithoutPropertiesInput
    user: UserCreateNestedOneWithoutPropertiesInput
    publication?: PropertyPublicationCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryCreateNestedManyWithoutPropertyInput
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutLayoutTypeInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
    publication?: PropertyPublicationUncheckedCreateNestedOneWithoutPropertyInput
    priceHistories?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutPropertyInput
    statusHistories?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutPropertyInput
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    stations?: PropertyStationUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutPropertyInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    propertyViewDailies?: PropertyViewDailyUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutLayoutTypeInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutLayoutTypeInput, PropertyUncheckedCreateWithoutLayoutTypeInput>
  }

  export type PropertyCreateManyLayoutTypeInputEnvelope = {
    data: PropertyCreateManyLayoutTypeInput | PropertyCreateManyLayoutTypeInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithWhereUniqueWithoutLayoutTypeInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutLayoutTypeInput, PropertyUncheckedUpdateWithoutLayoutTypeInput>
    create: XOR<PropertyCreateWithoutLayoutTypeInput, PropertyUncheckedCreateWithoutLayoutTypeInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutLayoutTypeInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutLayoutTypeInput, PropertyUncheckedUpdateWithoutLayoutTypeInput>
  }

  export type PropertyUpdateManyWithWhereWithoutLayoutTypeInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutLayoutTypeInput>
  }

  export type StationCreateWithoutRouteInput = {
    id?: string
    code: string
    name: string
    nameKana?: string | null
    prefecture?: string | null
    city?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    displayOrder?: number
    isActive?: boolean
    propertyStations?: PropertyStationCreateNestedManyWithoutStationInput
  }

  export type StationUncheckedCreateWithoutRouteInput = {
    id?: string
    code: string
    name: string
    nameKana?: string | null
    prefecture?: string | null
    city?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    displayOrder?: number
    isActive?: boolean
    propertyStations?: PropertyStationUncheckedCreateNestedManyWithoutStationInput
  }

  export type StationCreateOrConnectWithoutRouteInput = {
    where: StationWhereUniqueInput
    create: XOR<StationCreateWithoutRouteInput, StationUncheckedCreateWithoutRouteInput>
  }

  export type StationCreateManyRouteInputEnvelope = {
    data: StationCreateManyRouteInput | StationCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type StationUpsertWithWhereUniqueWithoutRouteInput = {
    where: StationWhereUniqueInput
    update: XOR<StationUpdateWithoutRouteInput, StationUncheckedUpdateWithoutRouteInput>
    create: XOR<StationCreateWithoutRouteInput, StationUncheckedCreateWithoutRouteInput>
  }

  export type StationUpdateWithWhereUniqueWithoutRouteInput = {
    where: StationWhereUniqueInput
    data: XOR<StationUpdateWithoutRouteInput, StationUncheckedUpdateWithoutRouteInput>
  }

  export type StationUpdateManyWithWhereWithoutRouteInput = {
    where: StationScalarWhereInput
    data: XOR<StationUpdateManyMutationInput, StationUncheckedUpdateManyWithoutRouteInput>
  }

  export type StationScalarWhereInput = {
    AND?: StationScalarWhereInput | StationScalarWhereInput[]
    OR?: StationScalarWhereInput[]
    NOT?: StationScalarWhereInput | StationScalarWhereInput[]
    id?: UuidFilter<"Station"> | string
    code?: StringFilter<"Station"> | string
    name?: StringFilter<"Station"> | string
    nameKana?: StringNullableFilter<"Station"> | string | null
    routeId?: UuidNullableFilter<"Station"> | string | null
    prefecture?: StringNullableFilter<"Station"> | string | null
    city?: StringNullableFilter<"Station"> | string | null
    latitude?: DecimalNullableFilter<"Station"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Station"> | Decimal | DecimalJsLike | number | string | null
    displayOrder?: IntFilter<"Station"> | number
    isActive?: BoolFilter<"Station"> | boolean
  }

  export type RouteMasterCreateWithoutStationsInput = {
    id?: string
    code: string
    name: string
    companyName?: string | null
    lineColor?: string | null
    displayOrder?: number
    isActive?: boolean
  }

  export type RouteMasterUncheckedCreateWithoutStationsInput = {
    id?: string
    code: string
    name: string
    companyName?: string | null
    lineColor?: string | null
    displayOrder?: number
    isActive?: boolean
  }

  export type RouteMasterCreateOrConnectWithoutStationsInput = {
    where: RouteMasterWhereUniqueInput
    create: XOR<RouteMasterCreateWithoutStationsInput, RouteMasterUncheckedCreateWithoutStationsInput>
  }

  export type PropertyStationCreateWithoutStationInput = {
    id?: string
    walkMinutes?: number | null
    busMinutes?: number | null
    busStopName?: string | null
    isPrimary?: boolean
    property: PropertyCreateNestedOneWithoutStationsInput
  }

  export type PropertyStationUncheckedCreateWithoutStationInput = {
    id?: string
    propertyId: string
    walkMinutes?: number | null
    busMinutes?: number | null
    busStopName?: string | null
    isPrimary?: boolean
  }

  export type PropertyStationCreateOrConnectWithoutStationInput = {
    where: PropertyStationWhereUniqueInput
    create: XOR<PropertyStationCreateWithoutStationInput, PropertyStationUncheckedCreateWithoutStationInput>
  }

  export type PropertyStationCreateManyStationInputEnvelope = {
    data: PropertyStationCreateManyStationInput | PropertyStationCreateManyStationInput[]
    skipDuplicates?: boolean
  }

  export type RouteMasterUpsertWithoutStationsInput = {
    update: XOR<RouteMasterUpdateWithoutStationsInput, RouteMasterUncheckedUpdateWithoutStationsInput>
    create: XOR<RouteMasterCreateWithoutStationsInput, RouteMasterUncheckedCreateWithoutStationsInput>
    where?: RouteMasterWhereInput
  }

  export type RouteMasterUpdateToOneWithWhereWithoutStationsInput = {
    where?: RouteMasterWhereInput
    data: XOR<RouteMasterUpdateWithoutStationsInput, RouteMasterUncheckedUpdateWithoutStationsInput>
  }

  export type RouteMasterUpdateWithoutStationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    lineColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RouteMasterUncheckedUpdateWithoutStationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    lineColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertyStationUpsertWithWhereUniqueWithoutStationInput = {
    where: PropertyStationWhereUniqueInput
    update: XOR<PropertyStationUpdateWithoutStationInput, PropertyStationUncheckedUpdateWithoutStationInput>
    create: XOR<PropertyStationCreateWithoutStationInput, PropertyStationUncheckedCreateWithoutStationInput>
  }

  export type PropertyStationUpdateWithWhereUniqueWithoutStationInput = {
    where: PropertyStationWhereUniqueInput
    data: XOR<PropertyStationUpdateWithoutStationInput, PropertyStationUncheckedUpdateWithoutStationInput>
  }

  export type PropertyStationUpdateManyWithWhereWithoutStationInput = {
    where: PropertyStationScalarWhereInput
    data: XOR<PropertyStationUpdateManyMutationInput, PropertyStationUncheckedUpdateManyWithoutStationInput>
  }

  export type QuestionCreateWithoutCategoryInput = {
    id?: string
    questionNumber: string
    title: string
    content: string
    tags?: QuestionCreatetagsInput | string[]
    viewCount?: number
    answerCount?: number
    status?: $Enums.QuestionStatus
    bestAnswerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    author: UserCreateNestedOneWithoutQuestionsInput
    answers?: AnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutCategoryInput = {
    id?: string
    questionNumber: string
    title: string
    content: string
    tags?: QuestionCreatetagsInput | string[]
    viewCount?: number
    answerCount?: number
    status?: $Enums.QuestionStatus
    authorId: string
    bestAnswerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutCategoryInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutCategoryInput, QuestionUncheckedCreateWithoutCategoryInput>
  }

  export type QuestionCreateManyCategoryInputEnvelope = {
    data: QuestionCreateManyCategoryInput | QuestionCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type QuestionUpsertWithWhereUniqueWithoutCategoryInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutCategoryInput, QuestionUncheckedUpdateWithoutCategoryInput>
    create: XOR<QuestionCreateWithoutCategoryInput, QuestionUncheckedCreateWithoutCategoryInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutCategoryInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutCategoryInput, QuestionUncheckedUpdateWithoutCategoryInput>
  }

  export type QuestionUpdateManyWithWhereWithoutCategoryInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutCategoryInput>
  }

  export type UserCreateWithoutMailsInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutAuthorInput
    answers?: AnswerCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateWithoutMailsInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutAuthorInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentUncheckedCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserCreateOrConnectWithoutMailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMailsInput, UserUncheckedCreateWithoutMailsInput>
  }

  export type UserUpsertWithoutMailsInput = {
    update: XOR<UserUpdateWithoutMailsInput, UserUncheckedUpdateWithoutMailsInput>
    create: XOR<UserCreateWithoutMailsInput, UserUncheckedCreateWithoutMailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMailsInput, UserUncheckedUpdateWithoutMailsInput>
  }

  export type UserUpdateWithoutMailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateWithoutMailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUncheckedUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type UserCreateWithoutFileBoxesInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutAuthorInput
    answers?: AnswerCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentCreateNestedManyWithoutUserInput
    mails?: MailCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateWithoutFileBoxesInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutAuthorInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentUncheckedCreateNestedManyWithoutUserInput
    mails?: MailUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserCreateOrConnectWithoutFileBoxesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFileBoxesInput, UserUncheckedCreateWithoutFileBoxesInput>
  }

  export type PropertyImageCreateWithoutFileBoxInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    imageType?: $Enums.ImageType
    displayOrder?: number
    isMain?: boolean
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    property: PropertyCreateNestedOneWithoutImagesInput
  }

  export type PropertyImageUncheckedCreateWithoutFileBoxInput = {
    id?: string
    propertyId: string
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    imageType?: $Enums.ImageType
    displayOrder?: number
    isMain?: boolean
    width?: number | null
    height?: number | null
    createdAt?: Date | string
  }

  export type PropertyImageCreateOrConnectWithoutFileBoxInput = {
    where: PropertyImageWhereUniqueInput
    create: XOR<PropertyImageCreateWithoutFileBoxInput, PropertyImageUncheckedCreateWithoutFileBoxInput>
  }

  export type PropertyImageCreateManyFileBoxInputEnvelope = {
    data: PropertyImageCreateManyFileBoxInput | PropertyImageCreateManyFileBoxInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutFileBoxesInput = {
    update: XOR<UserUpdateWithoutFileBoxesInput, UserUncheckedUpdateWithoutFileBoxesInput>
    create: XOR<UserCreateWithoutFileBoxesInput, UserUncheckedCreateWithoutFileBoxesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFileBoxesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFileBoxesInput, UserUncheckedUpdateWithoutFileBoxesInput>
  }

  export type UserUpdateWithoutFileBoxesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUpdateManyWithoutUserNestedInput
    mails?: MailUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateWithoutFileBoxesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUncheckedUpdateManyWithoutUserNestedInput
    mails?: MailUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type PropertyImageUpsertWithWhereUniqueWithoutFileBoxInput = {
    where: PropertyImageWhereUniqueInput
    update: XOR<PropertyImageUpdateWithoutFileBoxInput, PropertyImageUncheckedUpdateWithoutFileBoxInput>
    create: XOR<PropertyImageCreateWithoutFileBoxInput, PropertyImageUncheckedCreateWithoutFileBoxInput>
  }

  export type PropertyImageUpdateWithWhereUniqueWithoutFileBoxInput = {
    where: PropertyImageWhereUniqueInput
    data: XOR<PropertyImageUpdateWithoutFileBoxInput, PropertyImageUncheckedUpdateWithoutFileBoxInput>
  }

  export type PropertyImageUpdateManyWithWhereWithoutFileBoxInput = {
    where: PropertyImageScalarWhereInput
    data: XOR<PropertyImageUpdateManyMutationInput, PropertyImageUncheckedUpdateManyWithoutFileBoxInput>
  }

  export type UserCreateWithoutSystemSettingsUpdatedInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutAuthorInput
    answers?: AnswerCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentCreateNestedManyWithoutUserInput
    mails?: MailCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateWithoutSystemSettingsUpdatedInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutAuthorInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentUncheckedCreateNestedManyWithoutUserInput
    mails?: MailUncheckedCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserCreateOrConnectWithoutSystemSettingsUpdatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSystemSettingsUpdatedInput, UserUncheckedCreateWithoutSystemSettingsUpdatedInput>
  }

  export type UserUpsertWithoutSystemSettingsUpdatedInput = {
    update: XOR<UserUpdateWithoutSystemSettingsUpdatedInput, UserUncheckedUpdateWithoutSystemSettingsUpdatedInput>
    create: XOR<UserCreateWithoutSystemSettingsUpdatedInput, UserUncheckedCreateWithoutSystemSettingsUpdatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSystemSettingsUpdatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSystemSettingsUpdatedInput, UserUncheckedUpdateWithoutSystemSettingsUpdatedInput>
  }

  export type UserUpdateWithoutSystemSettingsUpdatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUpdateManyWithoutUserNestedInput
    mails?: MailUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSystemSettingsUpdatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUncheckedUpdateManyWithoutUserNestedInput
    mails?: MailUncheckedUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutAuthorInput
    answers?: AnswerCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentCreateNestedManyWithoutUserInput
    mails?: MailCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingCreateNestedManyWithoutUpdatedByInput
    priceHistoryChanges?: PropertyPriceHistoryCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutAuthorInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentUncheckedCreateNestedManyWithoutUserInput
    mails?: MailUncheckedCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUpdateManyWithoutUserNestedInput
    mails?: MailUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUpdateManyWithoutUpdatedByNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUncheckedUpdateManyWithoutUserNestedInput
    mails?: MailUncheckedUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUncheckedUpdateManyWithoutUpdatedByNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutAuthorInput
    answers?: AnswerCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentCreateNestedManyWithoutUserInput
    mails?: MailCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name?: string | null
    furigana?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    phone?: string | null
    avatarUrl?: string | null
    status?: $Enums.UserStatus
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    propertyViews?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutAuthorInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAuthorInput
    bulkAssessments?: BulkAssessmentUncheckedCreateNestedManyWithoutUserInput
    mails?: MailUncheckedCreateNestedManyWithoutUserInput
    fileBoxes?: FileBoxUncheckedCreateNestedManyWithoutUserInput
    systemSettingsUpdated?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedCreateNestedManyWithoutChangedByInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUpdateManyWithoutUserNestedInput
    mails?: MailUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutAuthorNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAuthorNestedInput
    bulkAssessments?: BulkAssessmentUncheckedUpdateManyWithoutUserNestedInput
    mails?: MailUncheckedUpdateManyWithoutUserNestedInput
    fileBoxes?: FileBoxUncheckedUpdateManyWithoutUserNestedInput
    systemSettingsUpdated?: SystemSettingUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    priceHistoryChanges?: PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    statusHistoryChanges?: PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type UserRoleCreateManyUserInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type PropertyCreateManyUserInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type InquiryCreateManyUserInput = {
    id?: string
    inquiryNumber: string
    targetType: $Enums.TargetType
    targetId?: string | null
    name: string
    furigana?: string | null
    email: string
    phone?: string | null
    companyName?: string | null
    inquiryType?: $Enums.InquiryType
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    assignedAgentId?: string | null
    assignedAt?: Date | string | null
    responseCount?: number
    lastRespondedAt?: Date | string | null
    closedAt?: Date | string | null
    closedReason?: string | null
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FavoriteCreateManyUserInput = {
    id?: string
    propertyId: string
    createdAt?: Date | string
  }

  export type PropertyViewCreateManyUserInput = {
    id?: string
    propertyId: string
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    referer?: string | null
    viewedAt?: Date | string
    viewDurationSeconds?: number | null
  }

  export type QuestionCreateManyAuthorInput = {
    id?: string
    questionNumber: string
    title: string
    content: string
    categoryId?: string | null
    tags?: QuestionCreatetagsInput | string[]
    viewCount?: number
    answerCount?: number
    status?: $Enums.QuestionStatus
    bestAnswerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AnswerCreateManyAuthorInput = {
    id?: string
    questionId: string
    content: string
    goodCount?: number
    isBestAnswer?: boolean
    agentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BulkAssessmentCreateManyUserInput = {
    id?: string
    assessmentNumber: string
    propertyAddress: string
    propertyTypeId?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    constructionYear?: number | null
    ownerName: string
    email: string
    phone?: string | null
    preferredContactMethod?: string | null
    preferredContactTime?: string | null
    status?: $Enums.AssessmentStatus
    agentCount?: number
    responseCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type MailCreateManyUserInput = {
    id?: string
    fromEmail: string
    fromName?: string | null
    toEmail: string
    toName?: string | null
    ccEmail?: MailCreateccEmailInput | string[]
    bccEmail?: MailCreatebccEmailInput | string[]
    subject: string
    bodyText: string
    bodyHtml?: string | null
    status?: $Enums.MailStatus
    mailType?: $Enums.MailType
    templateCode?: string | null
    templateVariables?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    retryCount?: number
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type FileBoxCreateManyUserInput = {
    id?: string
    bucketName: string
    storagePath: string
    fileName: string
    originalName: string
    publicUrl?: string | null
    mimeType: string
    fileSize: bigint | number
    category?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    title: string
    message: string
    linkUrl?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SystemSettingCreateManyUpdatedByInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    valueType: string
    category?: string | null
    description?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    tableName: string
    recordId: string
    action: $Enums.AuditAction
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: AuditLogCreatechangedFieldsInput | string[]
    userEmail?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    createdAt?: Date | string
  }

  export type PropertyPriceHistoryCreateManyChangedByInput = {
    id?: string
    propertyId: string
    previousPrice?: bigint | number | null
    newPrice: bigint | number
    changePercent?: Decimal | DecimalJsLike | number | string | null
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type PropertyStatusHistoryCreateManyChangedByInput = {
    id?: string
    propertyId: string
    previousStatus?: string | null
    newStatus: string
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type UserRoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyType?: PropertyTypeMasterUpdateOneWithoutPropertiesNestedInput
    propertyCategory?: PropertyCategoryMasterUpdateOneWithoutPropertiesNestedInput
    area?: AreaMasterUpdateOneWithoutPropertiesNestedInput
    layoutType?: FloorPlanMasterUpdateOneWithoutPropertiesNestedInput
    agent?: AgentUpdateOneWithoutPropertiesNestedInput
    publication?: PropertyPublicationUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publication?: PropertyPublicationUncheckedUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InquiryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryNumber?: StringFieldUpdateOperationsInput | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    name?: StringFieldUpdateOperationsInput | string
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    inquiryType?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCount?: IntFieldUpdateOperationsInput | number
    lastRespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAgent?: AgentUpdateOneWithoutAssignedInquiriesNestedInput
    property?: PropertyUpdateOneWithoutInquiriesNestedInput
    messages?: InquiryMessageUpdateManyWithoutInquiryNestedInput
  }

  export type InquiryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryNumber?: StringFieldUpdateOperationsInput | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    inquiryType?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    assignedAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCount?: IntFieldUpdateOperationsInput | number
    lastRespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: InquiryMessageUncheckedUpdateManyWithoutInquiryNestedInput
  }

  export type InquiryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryNumber?: StringFieldUpdateOperationsInput | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    inquiryType?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    assignedAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCount?: IntFieldUpdateOperationsInput | number
    lastRespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    property?: PropertyUpdateOneRequiredWithoutPropertyViewsNestedInput
  }

  export type PropertyViewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyViewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tags?: QuestionUpdatetagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    answerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    bestAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: QuestionCategoryUpdateOneWithoutQuestionsNestedInput
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: QuestionUpdatetagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    answerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    bestAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: QuestionUpdatetagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    answerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    bestAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnswerUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goodCount?: IntFieldUpdateOperationsInput | number
    isBestAnswer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question?: QuestionUpdateOneRequiredWithoutAnswersNestedInput
    agent?: AgentUpdateOneWithoutAnswersNestedInput
  }

  export type AnswerUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goodCount?: IntFieldUpdateOperationsInput | number
    isBestAnswer?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnswerUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goodCount?: IntFieldUpdateOperationsInput | number
    isBestAnswer?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BulkAssessmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentNumber?: StringFieldUpdateOperationsInput | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    constructionYear?: NullableIntFieldUpdateOperationsInput | number | null
    ownerName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    agentCount?: IntFieldUpdateOperationsInput | number
    responseCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyType?: PropertyTypeMasterUpdateOneWithoutBulkAssessmentsNestedInput
    responses?: BulkAssessmentResponseUpdateManyWithoutAssessmentNestedInput
  }

  export type BulkAssessmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentNumber?: StringFieldUpdateOperationsInput | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    constructionYear?: NullableIntFieldUpdateOperationsInput | number | null
    ownerName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    agentCount?: IntFieldUpdateOperationsInput | number
    responseCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responses?: BulkAssessmentResponseUncheckedUpdateManyWithoutAssessmentNestedInput
  }

  export type BulkAssessmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentNumber?: StringFieldUpdateOperationsInput | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    constructionYear?: NullableIntFieldUpdateOperationsInput | number | null
    ownerName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    agentCount?: IntFieldUpdateOperationsInput | number
    responseCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MailUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: StringFieldUpdateOperationsInput | string
    toName?: NullableStringFieldUpdateOperationsInput | string | null
    ccEmail?: MailUpdateccEmailInput | string[]
    bccEmail?: MailUpdatebccEmailInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    bodyText?: StringFieldUpdateOperationsInput | string
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMailStatusFieldUpdateOperationsInput | $Enums.MailStatus
    mailType?: EnumMailTypeFieldUpdateOperationsInput | $Enums.MailType
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    templateVariables?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: StringFieldUpdateOperationsInput | string
    toName?: NullableStringFieldUpdateOperationsInput | string | null
    ccEmail?: MailUpdateccEmailInput | string[]
    bccEmail?: MailUpdatebccEmailInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    bodyText?: StringFieldUpdateOperationsInput | string
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMailStatusFieldUpdateOperationsInput | $Enums.MailStatus
    mailType?: EnumMailTypeFieldUpdateOperationsInput | $Enums.MailType
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    templateVariables?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: StringFieldUpdateOperationsInput | string
    toName?: NullableStringFieldUpdateOperationsInput | string | null
    ccEmail?: MailUpdateccEmailInput | string[]
    bccEmail?: MailUpdatebccEmailInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    bodyText?: StringFieldUpdateOperationsInput | string
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMailStatusFieldUpdateOperationsInput | $Enums.MailStatus
    mailType?: EnumMailTypeFieldUpdateOperationsInput | $Enums.MailType
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    templateVariables?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileBoxUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyImages?: PropertyImageUpdateManyWithoutFileBoxNestedInput
  }

  export type FileBoxUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyImages?: PropertyImageUncheckedUpdateManyWithoutFileBoxNestedInput
  }

  export type FileBoxUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    valueType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    valueType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    valueType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: AuditLogUpdatechangedFieldsInput | string[]
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: AuditLogUpdatechangedFieldsInput | string[]
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: AuditLogUpdatechangedFieldsInput | string[]
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPriceHistoryUpdateWithoutChangedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    changePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutPriceHistoriesNestedInput
  }

  export type PropertyPriceHistoryUncheckedUpdateWithoutChangedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    previousPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    changePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPriceHistoryUncheckedUpdateManyWithoutChangedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    previousPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    changePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyStatusHistoryUpdateWithoutChangedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutStatusHistoriesNestedInput
  }

  export type PropertyStatusHistoryUncheckedUpdateWithoutChangedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyStatusHistoryUncheckedUpdateManyWithoutChangedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyRoleInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateManyCompanyInput = {
    id?: string
    branchName: string
    postalCode: string
    prefecture: string
    city: string
    address: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    phone: string
    fax?: string | null
    businessHours?: string | null
    isHeadquarters?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BranchUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    phone?: StringFieldUpdateOperationsInput | string
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    businessHours?: NullableStringFieldUpdateOperationsInput | string | null
    isHeadquarters?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agents?: AgentUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    phone?: StringFieldUpdateOperationsInput | string
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    businessHours?: NullableStringFieldUpdateOperationsInput | string | null
    isHeadquarters?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agents?: AgentUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    phone?: StringFieldUpdateOperationsInput | string
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    businessHours?: NullableStringFieldUpdateOperationsInput | string | null
    isHeadquarters?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgentCreateManyBranchInput = {
    id?: string
    position?: string | null
    department?: string | null
    licenseNumber?: string | null
    licenseExpireDate?: Date | string | null
    goodCount?: number
    responseRate?: Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: number | null
    userId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AgentUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goodCount?: IntFieldUpdateOperationsInput | number
    responseRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    properties?: PropertyUpdateManyWithoutAgentNestedInput
    assignedInquiries?: InquiryUpdateManyWithoutAssignedAgentNestedInput
    answers?: AnswerUpdateManyWithoutAgentNestedInput
    bulkAssessmentResponses?: BulkAssessmentResponseUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goodCount?: IntFieldUpdateOperationsInput | number
    responseRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    properties?: PropertyUncheckedUpdateManyWithoutAgentNestedInput
    assignedInquiries?: InquiryUncheckedUpdateManyWithoutAssignedAgentNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutAgentNestedInput
    bulkAssessmentResponses?: BulkAssessmentResponseUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goodCount?: IntFieldUpdateOperationsInput | number
    responseRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgResponseMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyCreateManyAgentInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
  }

  export type InquiryCreateManyAssignedAgentInput = {
    id?: string
    inquiryNumber: string
    targetType: $Enums.TargetType
    targetId?: string | null
    name: string
    furigana?: string | null
    email: string
    phone?: string | null
    companyName?: string | null
    inquiryType?: $Enums.InquiryType
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    userId?: string | null
    assignedAt?: Date | string | null
    responseCount?: number
    lastRespondedAt?: Date | string | null
    closedAt?: Date | string | null
    closedReason?: string | null
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnswerCreateManyAgentInput = {
    id?: string
    questionId: string
    content: string
    goodCount?: number
    isBestAnswer?: boolean
    authorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BulkAssessmentResponseCreateManyAgentInput = {
    id?: string
    assessmentId: string
    assessedPrice?: bigint | number | null
    priceRangeMin?: bigint | number | null
    priceRangeMax?: bigint | number | null
    comments?: string | null
    proposalDocument?: string | null
    status?: $Enums.ResponseStatus
    submittedAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PropertyUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyType?: PropertyTypeMasterUpdateOneWithoutPropertiesNestedInput
    propertyCategory?: PropertyCategoryMasterUpdateOneWithoutPropertiesNestedInput
    area?: AreaMasterUpdateOneWithoutPropertiesNestedInput
    layoutType?: FloorPlanMasterUpdateOneWithoutPropertiesNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    publication?: PropertyPublicationUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    publication?: PropertyPublicationUncheckedUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type InquiryUpdateWithoutAssignedAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryNumber?: StringFieldUpdateOperationsInput | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    name?: StringFieldUpdateOperationsInput | string
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    inquiryType?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCount?: IntFieldUpdateOperationsInput | number
    lastRespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutInquiriesNestedInput
    property?: PropertyUpdateOneWithoutInquiriesNestedInput
    messages?: InquiryMessageUpdateManyWithoutInquiryNestedInput
  }

  export type InquiryUncheckedUpdateWithoutAssignedAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryNumber?: StringFieldUpdateOperationsInput | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    inquiryType?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCount?: IntFieldUpdateOperationsInput | number
    lastRespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: InquiryMessageUncheckedUpdateManyWithoutInquiryNestedInput
  }

  export type InquiryUncheckedUpdateManyWithoutAssignedAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryNumber?: StringFieldUpdateOperationsInput | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    inquiryType?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCount?: IntFieldUpdateOperationsInput | number
    lastRespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goodCount?: IntFieldUpdateOperationsInput | number
    isBestAnswer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question?: QuestionUpdateOneRequiredWithoutAnswersNestedInput
    author?: UserUpdateOneWithoutAnswersNestedInput
  }

  export type AnswerUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goodCount?: IntFieldUpdateOperationsInput | number
    isBestAnswer?: BoolFieldUpdateOperationsInput | boolean
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnswerUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goodCount?: IntFieldUpdateOperationsInput | number
    isBestAnswer?: BoolFieldUpdateOperationsInput | boolean
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BulkAssessmentResponseUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessedPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    proposalDocument?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumResponseStatusFieldUpdateOperationsInput | $Enums.ResponseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assessment?: BulkAssessmentUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type BulkAssessmentResponseUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentId?: StringFieldUpdateOperationsInput | string
    assessedPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    proposalDocument?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumResponseStatusFieldUpdateOperationsInput | $Enums.ResponseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulkAssessmentResponseUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentId?: StringFieldUpdateOperationsInput | string
    assessedPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    proposalDocument?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumResponseStatusFieldUpdateOperationsInput | $Enums.ResponseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPriceHistoryCreateManyPropertyInput = {
    id?: string
    previousPrice?: bigint | number | null
    newPrice: bigint | number
    changePercent?: Decimal | DecimalJsLike | number | string | null
    changeReason?: string | null
    changedById?: string | null
    createdAt?: Date | string
  }

  export type PropertyStatusHistoryCreateManyPropertyInput = {
    id?: string
    previousStatus?: string | null
    newStatus: string
    changeReason?: string | null
    changedById?: string | null
    createdAt?: Date | string
  }

  export type PropertyImageCreateManyPropertyInput = {
    id?: string
    fileBoxId?: string | null
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    imageType?: $Enums.ImageType
    displayOrder?: number
    isMain?: boolean
    width?: number | null
    height?: number | null
    createdAt?: Date | string
  }

  export type PropertyFeatureCreateManyPropertyInput = {
    id?: string
    featureId: string
  }

  export type PropertyStationCreateManyPropertyInput = {
    id?: string
    stationId: string
    walkMinutes?: number | null
    busMinutes?: number | null
    busStopName?: string | null
    isPrimary?: boolean
  }

  export type InquiryCreateManyPropertyInput = {
    id?: string
    inquiryNumber: string
    targetType: $Enums.TargetType
    name: string
    furigana?: string | null
    email: string
    phone?: string | null
    companyName?: string | null
    inquiryType?: $Enums.InquiryType
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    userId?: string | null
    assignedAgentId?: string | null
    assignedAt?: Date | string | null
    responseCount?: number
    lastRespondedAt?: Date | string | null
    closedAt?: Date | string | null
    closedReason?: string | null
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FavoriteCreateManyPropertyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type PropertyViewCreateManyPropertyInput = {
    id?: string
    userId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    referer?: string | null
    viewedAt?: Date | string
    viewDurationSeconds?: number | null
  }

  export type PropertyViewDailyCreateManyPropertyInput = {
    id?: string
    viewDate: Date | string
    totalViews?: number
    uniqueUsers?: number
    avgDurationSeconds?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PropertyPriceHistoryUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    changePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedBy?: UserUpdateOneWithoutPriceHistoryChangesNestedInput
  }

  export type PropertyPriceHistoryUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    changePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    changePercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyStatusHistoryUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedBy?: UserUpdateOneWithoutStatusHistoryChangesNestedInput
  }

  export type PropertyStatusHistoryUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyImageUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: EnumImageTypeFieldUpdateOperationsInput | $Enums.ImageType
    displayOrder?: IntFieldUpdateOperationsInput | number
    isMain?: BoolFieldUpdateOperationsInput | boolean
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileBox?: FileBoxUpdateOneWithoutPropertyImagesNestedInput
  }

  export type PropertyImageUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileBoxId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: EnumImageTypeFieldUpdateOperationsInput | $Enums.ImageType
    displayOrder?: IntFieldUpdateOperationsInput | number
    isMain?: BoolFieldUpdateOperationsInput | boolean
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyImageUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileBoxId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: EnumImageTypeFieldUpdateOperationsInput | $Enums.ImageType
    displayOrder?: IntFieldUpdateOperationsInput | number
    isMain?: BoolFieldUpdateOperationsInput | boolean
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyFeatureUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: FeatureMasterUpdateOneRequiredWithoutPropertiesNestedInput
  }

  export type PropertyFeatureUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyFeatureUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyStationUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busStopName?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    station?: StationUpdateOneRequiredWithoutPropertyStationsNestedInput
  }

  export type PropertyStationUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stationId?: StringFieldUpdateOperationsInput | string
    walkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busStopName?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertyStationUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stationId?: StringFieldUpdateOperationsInput | string
    walkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busStopName?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InquiryUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryNumber?: StringFieldUpdateOperationsInput | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    name?: StringFieldUpdateOperationsInput | string
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    inquiryType?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCount?: IntFieldUpdateOperationsInput | number
    lastRespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutInquiriesNestedInput
    assignedAgent?: AgentUpdateOneWithoutAssignedInquiriesNestedInput
    messages?: InquiryMessageUpdateManyWithoutInquiryNestedInput
  }

  export type InquiryUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryNumber?: StringFieldUpdateOperationsInput | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    name?: StringFieldUpdateOperationsInput | string
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    inquiryType?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCount?: IntFieldUpdateOperationsInput | number
    lastRespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: InquiryMessageUncheckedUpdateManyWithoutInquiryNestedInput
  }

  export type InquiryUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryNumber?: StringFieldUpdateOperationsInput | string
    targetType?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    name?: StringFieldUpdateOperationsInput | string
    furigana?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    inquiryType?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCount?: IntFieldUpdateOperationsInput | number
    lastRespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneWithoutPropertyViewsNestedInput
  }

  export type PropertyViewUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyViewUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyViewDailyUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    uniqueUsers?: IntFieldUpdateOperationsInput | number
    avgDurationSeconds?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewDailyUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    uniqueUsers?: IntFieldUpdateOperationsInput | number
    avgDurationSeconds?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewDailyUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    uniqueUsers?: IntFieldUpdateOperationsInput | number
    avgDurationSeconds?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryMessageCreateManyInquiryInput = {
    id?: string
    senderId?: string | null
    senderType: $Enums.SenderType
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type InquiryMessageUpdateWithoutInquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryMessageUncheckedUpdateWithoutInquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryMessageUncheckedUpdateManyWithoutInquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulkAssessmentResponseCreateManyAssessmentInput = {
    id?: string
    agentId: string
    assessedPrice?: bigint | number | null
    priceRangeMin?: bigint | number | null
    priceRangeMax?: bigint | number | null
    comments?: string | null
    proposalDocument?: string | null
    status?: $Enums.ResponseStatus
    submittedAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BulkAssessmentResponseUpdateWithoutAssessmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessedPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    proposalDocument?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumResponseStatusFieldUpdateOperationsInput | $Enums.ResponseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutBulkAssessmentResponsesNestedInput
  }

  export type BulkAssessmentResponseUncheckedUpdateWithoutAssessmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    assessedPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    proposalDocument?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumResponseStatusFieldUpdateOperationsInput | $Enums.ResponseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulkAssessmentResponseUncheckedUpdateManyWithoutAssessmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    assessedPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    priceRangeMax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    proposalDocument?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumResponseStatusFieldUpdateOperationsInput | $Enums.ResponseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerCreateManyQuestionInput = {
    id?: string
    content: string
    goodCount?: number
    isBestAnswer?: boolean
    authorId?: string | null
    agentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AnswerUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goodCount?: IntFieldUpdateOperationsInput | number
    isBestAnswer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: UserUpdateOneWithoutAnswersNestedInput
    agent?: AgentUpdateOneWithoutAnswersNestedInput
  }

  export type AnswerUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goodCount?: IntFieldUpdateOperationsInput | number
    isBestAnswer?: BoolFieldUpdateOperationsInput | boolean
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    goodCount?: IntFieldUpdateOperationsInput | number
    isBestAnswer?: BoolFieldUpdateOperationsInput | boolean
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyFeatureCreateManyFeatureInput = {
    id?: string
    propertyId: string
  }

  export type PropertyFeatureUpdateWithoutFeatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    property?: PropertyUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type PropertyFeatureUncheckedUpdateWithoutFeatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyFeatureUncheckedUpdateManyWithoutFeatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
  }

  export type AreaMasterCreateManyRegionInput = {
    id?: string
    prefectureCode: string
    prefecture: string
    cityCode?: string | null
    city: string
    displayOrder?: number
    isActive?: boolean
  }

  export type AreaMasterUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    prefectureCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    properties?: PropertyUpdateManyWithoutAreaNestedInput
  }

  export type AreaMasterUncheckedUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    prefectureCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    properties?: PropertyUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type AreaMasterUncheckedUpdateManyWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    prefectureCode?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertyCreateManyAreaInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
  }

  export type PropertyUpdateWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyType?: PropertyTypeMasterUpdateOneWithoutPropertiesNestedInput
    propertyCategory?: PropertyCategoryMasterUpdateOneWithoutPropertiesNestedInput
    layoutType?: FloorPlanMasterUpdateOneWithoutPropertiesNestedInput
    agent?: AgentUpdateOneWithoutPropertiesNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    publication?: PropertyPublicationUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    publication?: PropertyPublicationUncheckedUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyCreateManyPropertyTypeInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
  }

  export type BulkAssessmentCreateManyPropertyTypeInput = {
    id?: string
    assessmentNumber: string
    propertyAddress: string
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    constructionYear?: number | null
    ownerName: string
    email: string
    phone?: string | null
    preferredContactMethod?: string | null
    preferredContactTime?: string | null
    status?: $Enums.AssessmentStatus
    agentCount?: number
    responseCount?: number
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type PropertyUpdateWithoutPropertyTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyCategory?: PropertyCategoryMasterUpdateOneWithoutPropertiesNestedInput
    area?: AreaMasterUpdateOneWithoutPropertiesNestedInput
    layoutType?: FloorPlanMasterUpdateOneWithoutPropertiesNestedInput
    agent?: AgentUpdateOneWithoutPropertiesNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    publication?: PropertyPublicationUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPropertyTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    publication?: PropertyPublicationUncheckedUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutPropertyTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type BulkAssessmentUpdateWithoutPropertyTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentNumber?: StringFieldUpdateOperationsInput | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    constructionYear?: NullableIntFieldUpdateOperationsInput | number | null
    ownerName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    agentCount?: IntFieldUpdateOperationsInput | number
    responseCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutBulkAssessmentsNestedInput
    responses?: BulkAssessmentResponseUpdateManyWithoutAssessmentNestedInput
  }

  export type BulkAssessmentUncheckedUpdateWithoutPropertyTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentNumber?: StringFieldUpdateOperationsInput | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    constructionYear?: NullableIntFieldUpdateOperationsInput | number | null
    ownerName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    agentCount?: IntFieldUpdateOperationsInput | number
    responseCount?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responses?: BulkAssessmentResponseUncheckedUpdateManyWithoutAssessmentNestedInput
  }

  export type BulkAssessmentUncheckedUpdateManyWithoutPropertyTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentNumber?: StringFieldUpdateOperationsInput | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    constructionYear?: NullableIntFieldUpdateOperationsInput | number | null
    ownerName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    agentCount?: IntFieldUpdateOperationsInput | number
    responseCount?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyCreateManyPropertyCategoryInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutTypeId?: string | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
  }

  export type PropertyUpdateWithoutPropertyCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyType?: PropertyTypeMasterUpdateOneWithoutPropertiesNestedInput
    area?: AreaMasterUpdateOneWithoutPropertiesNestedInput
    layoutType?: FloorPlanMasterUpdateOneWithoutPropertiesNestedInput
    agent?: AgentUpdateOneWithoutPropertiesNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    publication?: PropertyPublicationUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPropertyCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    publication?: PropertyPublicationUncheckedUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutPropertyCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyCreateManyLayoutTypeInput = {
    id?: string
    propertyCode: string
    propertyName: string
    propertyNameKana?: string | null
    propertyTypeId?: string | null
    propertyCategoryId?: string | null
    areaId?: string | null
    transactionType?: $Enums.TransactionType | null
    propertyCondition?: $Enums.PropertyCondition | null
    postalCode?: string | null
    prefecture?: string | null
    city?: string | null
    town?: string | null
    block?: string | null
    building?: string | null
    roomNumber?: string | null
    fullAddress?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    layoutNumber?: number | null
    layoutDisplay?: string | null
    buildingArea?: Decimal | DecimalJsLike | number | string | null
    landArea?: Decimal | DecimalJsLike | number | string | null
    balconyArea?: Decimal | DecimalJsLike | number | string | null
    buildingStructure?: string | null
    constructionDate?: Date | string | null
    constructionYearMonth?: string | null
    totalFloors?: number | null
    floor?: number | null
    currentPrice?: bigint | number | null
    pricePerTsubo?: bigint | number | null
    managementFee?: number | null
    commonServiceFee?: number | null
    depositMonths?: Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: string | null
    primaryStationName?: string | null
    primaryStationWalkMinutes?: number | null
    featureTags?: PropertyCreatefeatureTagsInput | string[]
    viewCount?: number
    inquiryCount?: number
    favoriteCount?: number
    agentId?: string | null
    remarks?: string | null
    internalMemo?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId: string
  }

  export type PropertyUpdateWithoutLayoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyType?: PropertyTypeMasterUpdateOneWithoutPropertiesNestedInput
    propertyCategory?: PropertyCategoryMasterUpdateOneWithoutPropertiesNestedInput
    area?: AreaMasterUpdateOneWithoutPropertiesNestedInput
    agent?: AgentUpdateOneWithoutPropertiesNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    publication?: PropertyPublicationUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutLayoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    publication?: PropertyPublicationUncheckedUpdateOneWithoutPropertyNestedInput
    priceHistories?: PropertyPriceHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    statusHistories?: PropertyStatusHistoryUncheckedUpdateManyWithoutPropertyNestedInput
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    stations?: PropertyStationUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViews?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    propertyViewDailies?: PropertyViewDailyUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutLayoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyCode?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    propertyNameKana?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: NullableEnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType | null
    propertyCondition?: NullableEnumPropertyConditionFieldUpdateOperationsInput | $Enums.PropertyCondition | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    town?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fullAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    layoutNumber?: NullableIntFieldUpdateOperationsInput | number | null
    layoutDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    buildingArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balconyArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buildingStructure?: NullableStringFieldUpdateOperationsInput | string | null
    constructionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    constructionYearMonth?: NullableStringFieldUpdateOperationsInput | string | null
    totalFloors?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pricePerTsubo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    managementFee?: NullableIntFieldUpdateOperationsInput | number | null
    commonServiceFee?: NullableIntFieldUpdateOperationsInput | number | null
    depositMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    keyMoneyMonths?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryStationWalkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    featureTags?: PropertyUpdatefeatureTagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    inquiryCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    internalMemo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type StationCreateManyRouteInput = {
    id?: string
    code: string
    name: string
    nameKana?: string | null
    prefecture?: string | null
    city?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    displayOrder?: number
    isActive?: boolean
  }

  export type StationUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKana?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    propertyStations?: PropertyStationUpdateManyWithoutStationNestedInput
  }

  export type StationUncheckedUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKana?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    propertyStations?: PropertyStationUncheckedUpdateManyWithoutStationNestedInput
  }

  export type StationUncheckedUpdateManyWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKana?: NullableStringFieldUpdateOperationsInput | string | null
    prefecture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertyStationCreateManyStationInput = {
    id?: string
    propertyId: string
    walkMinutes?: number | null
    busMinutes?: number | null
    busStopName?: string | null
    isPrimary?: boolean
  }

  export type PropertyStationUpdateWithoutStationInput = {
    id?: StringFieldUpdateOperationsInput | string
    walkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busStopName?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    property?: PropertyUpdateOneRequiredWithoutStationsNestedInput
  }

  export type PropertyStationUncheckedUpdateWithoutStationInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    walkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busStopName?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertyStationUncheckedUpdateManyWithoutStationInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    walkMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    busStopName?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuestionCreateManyCategoryInput = {
    id?: string
    questionNumber: string
    title: string
    content: string
    tags?: QuestionCreatetagsInput | string[]
    viewCount?: number
    answerCount?: number
    status?: $Enums.QuestionStatus
    authorId: string
    bestAnswerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type QuestionUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tags?: QuestionUpdatetagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    answerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    bestAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: UserUpdateOneRequiredWithoutQuestionsNestedInput
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tags?: QuestionUpdatetagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    answerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    authorId?: StringFieldUpdateOperationsInput | string
    bestAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tags?: QuestionUpdatetagsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    answerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    authorId?: StringFieldUpdateOperationsInput | string
    bestAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyImageCreateManyFileBoxInput = {
    id?: string
    propertyId: string
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    imageType?: $Enums.ImageType
    displayOrder?: number
    isMain?: boolean
    width?: number | null
    height?: number | null
    createdAt?: Date | string
  }

  export type PropertyImageUpdateWithoutFileBoxInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: EnumImageTypeFieldUpdateOperationsInput | $Enums.ImageType
    displayOrder?: IntFieldUpdateOperationsInput | number
    isMain?: BoolFieldUpdateOperationsInput | boolean
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutImagesNestedInput
  }

  export type PropertyImageUncheckedUpdateWithoutFileBoxInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: EnumImageTypeFieldUpdateOperationsInput | $Enums.ImageType
    displayOrder?: IntFieldUpdateOperationsInput | number
    isMain?: BoolFieldUpdateOperationsInput | boolean
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyImageUncheckedUpdateManyWithoutFileBoxInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    imageType?: EnumImageTypeFieldUpdateOperationsInput | $Enums.ImageType
    displayOrder?: IntFieldUpdateOperationsInput | number
    isMain?: BoolFieldUpdateOperationsInput | boolean
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}